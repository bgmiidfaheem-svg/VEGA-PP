{"file_contents":{"README.md":{"content":"![vega-high-resolution-logo-transparent](https://github.com/Zenda-Cross/vega-app/assets/143804558/b2eb446f-8e7f-4800-81e1-3320c82f33de)\n\n# Vega-App\nAndroid app for streaming media.\n### Features\n- Steam and Download Ad-Free.\n- Multiple sources.\n- Multi Audio and Subs (Hindi, English, etc.).\n- WatchList.\n- External player and Downloader support.\n<br>\n\n[![Discord](https://custom-icon-badges.demolab.com/badge/-Join_Discord-6567a5?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/cr42m6maWy)\n\n___\n\n## Download  ![GitHub Downloads (all assets, all releases)](https://img.shields.io/github/downloads/Zenda-Cross/vega-app/total?link=https%3A%2F%2Fgithub.com%2FZenda-Cross%2Fvega-app%2Freleases)\n> <sub>Download Universal version if you are confused about armeabi-v7a or arm64-v8a.</sub>\n\n[![Download Apk](https://custom-icon-badges.demolab.com/badge/-Download_Apk-blue?style=for-the-badge&logo=download&logoColor=white \"Download Apk\")](https://github.com/Zenda-Cross/vega-app/releases/latest)\n\n<br>\n\n## Screenshots\n![Screenshots](https://github.com/user-attachments/assets/b86af756-e66e-4ae7-b2af-61b25cfd8d4e)\n\n___\n\n## Stack\n<p align=\"left\">\n     \n[![React-Native](https://custom-icon-badges.demolab.com/badge/-React_Native-287aad?style=for-the-badge&logo=react&logoColor=white)](https://reactnative.dev/)\n[![TypeScript](https://custom-icon-badges.demolab.com/badge/Typescript-3078C6?style=for-the-badge&logo=typescript&logoColor=white)](https://www.typescriptlang.org/)\n[![NativeWind](https://custom-icon-badges.demolab.com/badge/Native_Wind-0CA6E9?style=for-the-badge&logo=tailwind&logoColor=white)](https://www.nativewind.dev/)\n[![React-Navigation](https://custom-icon-badges.demolab.com/badge/React_Navigation-6838d9?style=for-the-badge&logo=menu&logoColor=white)](https://reactnavigation.org/)\n[![Expo-Modules](https://custom-icon-badges.demolab.com/badge/Expo_Modules-black?style=for-the-badge&logo=expo&logoColor=white)](https://docs.expo.dev/modules/overview/)\n[![React-Native-Video](https://custom-icon-badges.demolab.com/badge/React_native_video-38d9c9?style=for-the-badge&logo=video&logoColor=white)](https://thewidlarzgroup.github.io/react-native-video/)\n[![MMKV-Storage](https://custom-icon-badges.demolab.com/badge/MMKV_Storage-yellow?style=for-the-badge&logo=zap&logoColor=white)](https://github.com/mrousavy/react-native-mmkv)\n\n\n\n</p>\n\n## Build and Dev\n0. Set-up React Native environment if you haven't already. [Guide](https://reactnative.dev/docs/set-up-your-environment)\n\n1. clone\n     ```bash\n     git clone https://github.com/Zenda-Cross/vega-app.git\n     ```\n     ```\n     cd vega-app\n     ```\n2. Install\n     ```\n     npm install\n     ```\n3. Prebuild\n   ```\n    npx expo prebuild -p android --clean\n   ```\n5. Open metro dev server\nDev\n     ```\n     npm run android\n     ```\nBuild apk/aab\nhttps://reactnative.dev/docs/signed-apk-android\n\n---\n> [!IMPORTANT]\n> Vega App does not store any media files on our servers and is not directly linked to the media. Third-party services host all media, and Vega App merely provides a search and web scraping tool that indexes publicly available data. We are not responsible for the content or availability of the media, as we do not host or control any of it.\n\n\n## Stars\n <picture>\n   <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://api.star-history.com/svg?repos=Zenda-Cross/vega-app&type=Date&theme=dark\" />\n   <source media=\"(prefers-color-scheme: light)\" srcset=\"https://api.star-history.com/svg?repos=Zenda-Cross/vega-app&type=Date\" />\n   <img alt=\"Star History Chart\" src=\"https://api.star-history.com/svg?repos=Zenda-Cross/vega-app&type=Date\" />\n </picture>\n</a>\n","size_bytes":3662},"app.config.js":{"content":"// Dynamic Expo config to make Firebase optional for public clones\r\n// If google-services.json / GoogleService-Info.plist are absent, we skip RNFirebase plugins\r\n// and android/ios google services config so the app still builds and runs without Firebase.\r\n\r\nconst fs = require('fs');\r\n\r\nconst hasAndroidGoogleServices = fs.existsSync('./google-services.json');\r\nconst hasIosGooglePlist = fs.existsSync('./GoogleService-Info.plist');\r\n\r\nmodule.exports = () => {\r\n  const plugins = [\r\n    './plugins/android-native-config.js',\r\n    './plugins/with-android-notification-icons.js',\r\n    './plugins/with-android-release-gradle.js',\r\n    './plugins/with-android-signing.js',\r\n    './plugins/with-android-okhttp.js',\r\n    // Only include RNFirebase plugins when a services file is present\r\n    ...(hasAndroidGoogleServices || hasIosGooglePlist\r\n      ? ['@react-native-firebase/app']\r\n      : []),\r\n    // Keep Crashlytics plugin optional; do not include analytics plugin to avoid ESM import issue\r\n    ...(hasAndroidGoogleServices || hasIosGooglePlist\r\n      ? ['@react-native-firebase/crashlytics']\r\n      : []),\r\n    [\r\n      'react-native-video',\r\n      {\r\n        enableNotificationControls: true,\r\n        enableAndroidPictureInPicture: true,\r\n        androidExtensions: {\r\n          useExoplayerRtsp: false,\r\n          useExoplayerSmoothStreaming: true,\r\n          useExoplayerHls: true,\r\n          useExoplayerDash: true,\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      'react-native-edge-to-edge',\r\n      {\r\n        android: {\r\n          parentTheme: 'Default',\r\n          enforceNavigationBarContrast: false,\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      'react-native-bootsplash',\r\n      {\r\n        assetsDir: 'assets/bootsplash',\r\n        android: {\r\n          parentTheme: 'EdgeToEdge',\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      'expo-build-properties',\r\n      {\r\n        android: {\r\n          extraMavenRepos: [\r\n            '../../node_modules/@notifee/react-native/android/libs',\r\n          ],\r\n          enableProguardInReleaseBuilds: true,\r\n          splits: {\r\n            abi: {enable: true, universalApk: true},\r\n          },\r\n          buildVariants: {\r\n            release: {\r\n              minifyEnabled: true,\r\n              shrinkResources: true,\r\n              splits: {\r\n                abi: {\r\n                  enable: true,\r\n                  reset: false,\r\n                  include: ['armeabi-v7a', 'arm64-v8a'],\r\n                },\r\n              },\r\n            },\r\n            debug: {minifyEnabled: false, debuggable: true},\r\n          },\r\n        },\r\n        ios: {},\r\n      },\r\n    ],\r\n  ];\r\n\r\n  return {\r\n    expo: {\r\n      name: 'Vega',\r\n      displayName: 'Vega',\r\n      newArchEnabled: true,\r\n      autolinking: {exclude: ['expo-splash-screen']},\r\n      plugins,\r\n      slug: 'vega',\r\n      version: '3.2.4',\r\n      sdkVersion: '52.0.0',\r\n      userInterfaceStyle: 'dark',\r\n      android: {\r\n        ...(hasAndroidGoogleServices\r\n          ? {googleServicesFile: './google-services.json'}\r\n          : {}),\r\n        minSdkVersion: 24,\r\n        edgeToEdgeEnabled: true,\r\n        package: 'com.vega',\r\n        versionCode: 152,\r\n        permissions: [\r\n          'FOREGROUND_SERVICE',\r\n          'FOREGROUND_SERVICE_MEDIA_PLAYBACK',\r\n          'INTERNET',\r\n          'MANAGE_EXTERNAL_STORAGE',\r\n          'READ_EXTERNAL_STORAGE',\r\n          'READ_MEDIA_VIDEO',\r\n          'WRITE_EXTERNAL_STORAGE',\r\n          'WRITE_SETTINGS',\r\n        ],\r\n        manifestPermissions: [\r\n          {name: 'READ_EXTERNAL_STORAGE', maxSdkVersion: 32},\r\n          {name: 'WRITE_EXTERNAL_STORAGE', maxSdkVersion: 32},\r\n        ],\r\n        intentFilters: [\r\n          {action: 'VIEW', category: 'BROWSABLE', data: {scheme: 'com.vega'}},\r\n        ],\r\n        queries: [\r\n          {action: 'VIEW', data: {scheme: 'http'}},\r\n          {action: 'VIEW', data: {scheme: 'https'}},\r\n          {action: 'VIEW', data: {scheme: 'vlc'}},\r\n        ],\r\n        config: {requestLegacyExternalStorage: true},\r\n        allowBackup: true,\r\n        icon: './assets/icon.png',\r\n        adaptiveIcon: {\r\n          foregroundImage: './assets/adaptive_icon.png',\r\n          backgroundColor: '#000000',\r\n        },\r\n        launchMode: 'singleTask',\r\n        supportsPictureInPicture: true,\r\n      },\r\n      ios: {\r\n        ...(hasIosGooglePlist\r\n          ? {googleServicesFile: './GoogleService-Info.plist'}\r\n          : {}),\r\n      },\r\n      platforms: ['ios', 'android'],\r\n      extra: {\r\n        hasFirebase: hasAndroidGoogleServices || hasIosGooglePlist,\r\n      },\r\n    },\r\n  };\r\n};\r\n","size_bytes":4577},"babel.config.js":{"content":"module.exports = {\n  presets: ['module:@react-native/babel-preset'],\n  plugins: [\n    [\n      'module-resolver',\n      {\n        root: ['./'],\n        alias: {\n          'moti/skeleton': 'moti/skeleton/react-native-linear-gradient',\n        },\n      },\n    ],\n    'nativewind/babel',\n    'react-native-reanimated/plugin',\n  ],\n};\n","size_bytes":330},"codemagic.yaml":{"content":"workflows:\n  android-preview:\n    name: Expo Android Preview (APK)\n    instance_type: mac_mini_m2\n    max_build_duration: 60\n    environment:\n      vars:\n        EAS_PROFILE: \"preview\"\n        # EXPO_TOKEN को Codemagic UI के Environment variables में जोड़ें (secure)\n    scripts:\n      - name: Install deps\n        script: npm ci\n      - name: Verify Expo auth\n        script: npx eas-cli whoami\n      - name: Build APK\n        script: npx eas-cli build -p android --profile \"$EAS_PROFILE\" --non-interactive\n    artifacts:\n      - dist/**/*.apk\n      - build/**/outputs/**/*.apk\n\n  android-production:\n    name: Expo Android Production (AAB)\n    instance_type: mac_mini_m2\n    max_build_duration: 60\n    environment:\n      vars:\n        EAS_PROFILE: \"production\"\n    scripts:\n      - name: Install deps\n        script: npm ci\n      - name: Verify Expo auth\n        script: npx eas-cli whoami\n      - name: Build AAB\n        script: npx eas-cli build -p android --profile \"$EAS_PROFILE\" --non-interactive\n    artifacts:\n      - dist/**/*.aab\n      - build/**/outputs/**/*.aab\n      \n","size_bytes":1108},"index.js":{"content":"/**\n * @format\n */\n\nimport {AppRegistry} from 'react-native';\nimport App from './src/App';\nimport notifee from '@notifee/react-native';\nimport notificationService from './src/lib/services/Notification';\n\n// Enable react-native-firebase debug mode for Analytics DebugView in dev\nif (__DEV__) {\n  // eslint-disable-next-line no-undef\n  globalThis.RNFBDebug = true;\n}\n\nnotifee.onBackgroundEvent(async ({type, detail}) => {\n  notificationService.actionHandler({type, detail});\n});\n\nAppRegistry.registerComponent('main', () => App);\n","size_bytes":528},"jest.config.js":{"content":"module.exports = {\n  preset: 'react-native',\n};\n","size_bytes":48},"metro.config.js":{"content":"const {getDefaultConfig} = require('expo/metro-config');\nconst {mergeConfig} = require('@react-native/metro-config');\n/**\n * Metro configuration\n * https://reactnative.dev/docs/metro\n *\n * @type {import('metro-config').MetroConfig}\n */\n\nconst config = getDefaultConfig(__dirname);\n\nconfig.transformer.minifierConfig = {\n  compress: {\n    drop_console: true,\n    // Enable all unsafe optimizations.\n    unsafe: true,\n    unsafe_arrows: true,\n    unsafe_comps: true,\n    unsafe_Function: true,\n    unsafe_math: true,\n    unsafe_symbols: true,\n    unsafe_methods: true,\n    unsafe_proto: true,\n    unsafe_regexp: true,\n    unsafe_undefined: true,\n    unused: true,\n  },\n};\n\nmodule.exports = config;\n","size_bytes":696},"nativewind-env.d.ts":{"content":"/// <reference types=\"nativewind/types\" />\r\n","size_bytes":44},"tailwind.config.js":{"content":"/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: ['./src/**/*.{html,js,jsx,ts,tsx}'],\n  theme: {\n    extend: {\n      colors: {\n        primary: '#FF6347',\n        secondary: '#000000',\n        tertiary: '#171717',\n        quaternary: '#1a1a1a',\n      },\n    },\n  },\n  plugins: [],\n};\n","size_bytes":309},"__tests__/App.test.tsx":{"content":"/**\n * @format\n */\n\nimport 'react-native';\nimport React from 'react';\nimport App from '../src/App';\n\n// Note: import explicitly to use the types shipped with jest.\nimport {it} from '@jest/globals';\n\n// Note: test renderer must be required after react-native.\nimport renderer from 'react-test-renderer';\n\nit('renders correctly', () => {\n  renderer.create(<App />);\n});\n","size_bytes":368},"plugins/android-native-config.js":{"content":"const {withAndroidStyles} = require('@expo/config-plugins');\r\n\r\nconst withAndroidNativeConfig = config => {\r\n  return withAndroidStyles(config, config => {\r\n    // Safely access the styles\r\n    const styles = config.modResults;\r\n\r\n    // Ensure we have the basic structure\r\n    if (!styles || !styles.resources) {\r\n      return config;\r\n    }\r\n\r\n    // Ensure styles.resources.style exists and is an array\r\n    if (!styles.resources.style || !Array.isArray(styles.resources.style)) {\r\n      styles.resources.style = [];\r\n    }\r\n\r\n    // Helper function to safely add text color to a style\r\n    const addTextColorToStyle = styleName => {\r\n      // Find the style element\r\n      const styleElement = styles.resources.style.find(\r\n        style => style && style.$ && style.$.name === styleName,\r\n      );\r\n\r\n      if (!styleElement) {\r\n        return; // Style not found, skip\r\n      }\r\n\r\n      // Ensure item array exists\r\n      if (!styleElement.item || !Array.isArray(styleElement.item)) {\r\n        styleElement.item = [];\r\n      }\r\n\r\n      // Check if text color already exists\r\n      const existingTextColor = styleElement.item.find(\r\n        item => item && item.$ && item.$.name === 'android:textColor',\r\n      );\r\n\r\n      if (existingTextColor) {\r\n        // Update existing\r\n        existingTextColor._ = '@android:color/white';\r\n      } else {\r\n        // Add new text color item\r\n        styleElement.item.push({\r\n          $: {name: 'android:textColor'},\r\n          _: '@android:color/white',\r\n        });\r\n      }\r\n    };\r\n\r\n    // Apply text color to styles\r\n    addTextColorToStyle('AppTheme');\r\n    addTextColorToStyle('ResetEditText');\r\n\r\n    return config;\r\n  });\r\n};\r\n\r\nmodule.exports = withAndroidNativeConfig;\r\n","size_bytes":1730},"plugins/with-android-notification-icons.js":{"content":"const fs = require('fs');\r\nconst path = require('path');\r\nconst {withDangerousMod} = require('@expo/config-plugins');\r\n\r\n/**\r\n * Ensures ic_notification resources exist after prebuild by copying from assets/android/notification/** into\r\n * android/app/src/main/res/**. Ships a vector fallback if present.\r\n */\r\nmodule.exports = function withAndroidNotificationIcons(config) {\r\n  return withDangerousMod(config, [\r\n    'android',\r\n    async cfg => {\r\n      const projectRoot = cfg.modRequest.projectRoot;\r\n      const srcRoot = path.join(\r\n        projectRoot,\r\n        'assets',\r\n        'android',\r\n        'notification',\r\n      );\r\n      const destRes = path.join(\r\n        projectRoot,\r\n        'android',\r\n        'app',\r\n        'src',\r\n        'main',\r\n        'res',\r\n      );\r\n\r\n      if (!fs.existsSync(srcRoot)) {\r\n        // Nothing to copy; keep config intact\r\n        return cfg;\r\n      }\r\n\r\n      const copyDir = subdir => {\r\n        const fromDir = path.join(srcRoot, subdir);\r\n        const toDir = path.join(destRes, subdir);\r\n        if (!fs.existsSync(fromDir)) return;\r\n        fs.mkdirSync(toDir, {recursive: true});\r\n        for (const f of fs.readdirSync(fromDir)) {\r\n          const from = path.join(fromDir, f);\r\n          const to = path.join(toDir, f);\r\n          if (fs.statSync(from).isFile()) {\r\n            fs.copyFileSync(from, to);\r\n            // If the asset was misspelled as ic_notificarion.*, also copy a corrected duplicate ic_notification.*\r\n            if (/ic_notificarion(\\.[a-z0-9]+)$/i.test(f)) {\r\n              const ext = path.extname(f);\r\n              const corrected = path.join(toDir, `ic_notification${ext}`);\r\n              if (!fs.existsSync(corrected)) {\r\n                fs.copyFileSync(from, corrected);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      // Common resource buckets to copy if present\r\n      const buckets = [\r\n        'drawable-anydpi-v24',\r\n        'drawable',\r\n        'drawable-mdpi',\r\n        'drawable-hdpi',\r\n        'drawable-xhdpi',\r\n        'drawable-xxhdpi',\r\n        'drawable-xxxhdpi',\r\n      ];\r\n      buckets.forEach(copyDir);\r\n\r\n      return cfg;\r\n    },\r\n  ]);\r\n};\r\n","size_bytes":2181},"plugins/with-android-okhttp.js":{"content":"const fs = require('fs');\r\nconst path = require('path');\r\nconst {withDangerousMod} = require('@expo/config-plugins');\r\n\r\n/**\r\n * Adds OkHttp dependencies and force resolution strategy after prebuild.\r\n * Generates a Gradle file that applies OkHttp dependencies and resolution strategy.\r\n */\r\nmodule.exports = function withAndroidOkHttp(config) {\r\n  return withDangerousMod(config, [\r\n    'android',\r\n    async cfg => {\r\n      const projectRoot = cfg.modRequest.projectRoot;\r\n      const appDir = path.join(projectRoot, 'android', 'app');\r\n      const buildGradle = path.join(appDir, 'build.gradle');\r\n      const okHttpGradle = path.join(appDir, 'with-okhttp.gradle');\r\n\r\n      // Create OkHttp gradle that adds dependencies and force resolution\r\n      const okHttpContent = `// Auto-applied by with-android-okhttp config plugin\r\ndependencies {\r\n    implementation \"com.squareup.okhttp3:okhttp:4.12.0\"\r\n    implementation \"com.squareup.okhttp3:logging-interceptor:4.12.0\"\r\n    implementation \"com.squareup.okhttp3:okhttp-urlconnection:4.12.0\"\r\n}\r\n\r\n// Force resolution in case React Native or other libs pull old versions\r\nconfigurations.all {\r\n    resolutionStrategy {\r\n        force \"com.squareup.okhttp3:okhttp:4.12.0\"\r\n        force \"com.squareup.okhttp3:logging-interceptor:4.12.0\"\r\n        force \"com.squareup.okhttp3:okhttp-urlconnection:4.12.0\"\r\n    }\r\n}\r\n`;\r\n      fs.writeFileSync(okHttpGradle, okHttpContent, 'utf8');\r\n\r\n      // Idempotently add apply from with-okhttp.gradle after existing apply lines\r\n      let gradleText = fs.readFileSync(buildGradle, 'utf8');\r\n      if (!gradleText.includes(\"apply from: 'with-okhttp.gradle'\")) {\r\n        // Find the last apply from line and add our line after it\r\n        const applyFromLines = gradleText.match(/apply from: '[^']+'/g);\r\n        if (applyFromLines && applyFromLines.length > 0) {\r\n          const lastApplyFrom = applyFromLines[applyFromLines.length - 1];\r\n          gradleText = gradleText.replace(\r\n            lastApplyFrom,\r\n            `${lastApplyFrom}\\napply from: 'with-okhttp.gradle'`,\r\n          );\r\n        } else {\r\n          // If no apply from lines found, add after React plugin\r\n          gradleText = gradleText.replace(\r\n            /apply plugin: \"com\\.facebook\\.react\"/,\r\n            `apply plugin: \"com.facebook.react\"\\napply from: 'with-okhttp.gradle'`,\r\n          );\r\n        }\r\n        fs.writeFileSync(buildGradle, gradleText, 'utf8');\r\n      }\r\n\r\n      return cfg;\r\n    },\r\n  ]);\r\n};\r\n","size_bytes":2481},"plugins/with-android-release-gradle.js":{"content":"const fs = require('fs');\r\nconst path = require('path');\r\nconst {withDangerousMod} = require('@expo/config-plugins');\r\n\r\n/**\r\n * Ensures custom release build logic (APK renaming and buildTypes settings) is re-applied after prebuild.\r\n * Adds or updates a Gradle script at android/app/with-release-config.gradle and applies it.\r\n */\r\nmodule.exports = function withAndroidReleaseGradle(config) {\r\n  return withDangerousMod(config, [\r\n    'android',\r\n    async cfg => {\r\n      const projectRoot = cfg.modRequest.projectRoot;\r\n      const appDir = path.join(projectRoot, 'android', 'app');\r\n      const buildGradle = path.join(appDir, 'build.gradle');\r\n      const helperGradle = path.join(appDir, 'with-release-config.gradle');\r\n      const abiSplitsGradle = path.join(appDir, 'with-abi-splits.gradle');\r\n\r\n      // Write helper gradle to add the APK rename logic if not present\r\n      const helperContent = `// Auto-applied by with-android-release-gradle config plugin\r\nif (project.android) {\r\n  project.android.applicationVariants.all { variant ->\r\n    variant.outputs.each { output ->\r\n      project.ext { appName = 'Vega' }\r\n      def version = variant.versionName\r\n      def newName = output.outputFile.name\r\n            // Keep project.ext.appName as a Gradle variable (escaped from Node template evaluation)\r\n      newName = newName.replace(\"app-\", \"${'${'}project.ext.appName${'}'}-\")\r\n      newName = newName.replace(\"-release\", \"-v\" + version)\r\n      output.outputFileName = newName\r\n    }\r\n  }\r\n}\r\n`;\r\n      fs.writeFileSync(helperGradle, helperContent, 'utf8');\r\n\r\n      // Write ABI splits gradle which enforces the desired splits\r\n      const abiSplitsContent = `// Auto-applied by with-android-release-gradle config plugin\r\nif (project.android) {\r\n  project.android {\r\n    splits {\r\n      abi {\r\n        enable true\r\n        reset()\r\n        include 'armeabi-v7a', 'arm64-v8a'\r\n        universalApk true\r\n      }\r\n    }\r\n  }\r\n}\r\n`;\r\n      fs.writeFileSync(abiSplitsGradle, abiSplitsContent, 'utf8');\r\n\r\n      // Intentionally avoid modifying signing configs here to prevent AGP DSL timing issues.\r\n\r\n      // Idempotently ensure the helper is applied in build.gradle\r\n      let gradleText = fs.readFileSync(buildGradle, 'utf8');\r\n      if (!gradleText.includes(\"apply from: 'with-release-config.gradle'\")) {\r\n        // Apply near top of file after existing plugins\r\n        gradleText = gradleText.replace(\r\n          /(apply plugin:[\\s\\S]*?\\n)(?=\\n|def|android\\s*\\{)/,\r\n          `$1apply from: 'with-release-config.gradle'\\n`,\r\n        );\r\n      }\r\n\r\n      if (!gradleText.includes(\"apply from: 'with-abi-splits.gradle'\")) {\r\n        gradleText = gradleText.replace(\r\n          /(apply plugin:[\\s\\S]*?\\n)(?=\\n|def|android\\s*\\{)/,\r\n          `$1apply from: 'with-abi-splits.gradle'\\n`,\r\n        );\r\n      }\r\n\r\n      // Remove any stale apply of with-signing-config.gradle (from earlier versions)\r\n      gradleText = gradleText.replace(\r\n        /^apply from: 'with-signing-config.gradle'\\s*\\n/m,\r\n        '',\r\n      );\r\n\r\n      fs.writeFileSync(buildGradle, gradleText, 'utf8');\r\n\r\n      return cfg;\r\n    },\r\n  ]);\r\n};\r\n","size_bytes":3134},"plugins/with-android-signing-config.js":{"content":"","size_bytes":0},"plugins/with-android-signing.js":{"content":"const fs = require('fs');\r\nconst path = require('path');\r\nconst {withDangerousMod} = require('@expo/config-plugins');\r\n\r\n/**\r\n * Adds release signing configuration that reads from env vars after prebuild.\r\n * Uses a Gradle file that applies signing config during the android block evaluation.\r\n */\r\nmodule.exports = function withAndroidSigning(config) {\r\n  return withDangerousMod(config, [\r\n    'android',\r\n    async cfg => {\r\n      const projectRoot = cfg.modRequest.projectRoot;\r\n      const appDir = path.join(projectRoot, 'android', 'app');\r\n      const buildGradle = path.join(appDir, 'build.gradle');\r\n      const signingGradle = path.join(appDir, 'with-signing.gradle');\r\n\r\n      // Create signing gradle that extends signingConfigs during android block\r\n      const signingContent = `// Auto-applied by with-android-signing config plugin\r\nandroid {\r\n    signingConfigs {\r\n        release {\r\n            def envStoreFile = System.getenv('MYAPP_UPLOAD_STORE_FILE')\r\n            def envStorePassword = System.getenv('MYAPP_UPLOAD_STORE_PASSWORD')\r\n            def envKeyAlias = System.getenv('MYAPP_UPLOAD_KEY_ALIAS')\r\n            def envKeyPassword = System.getenv('MYAPP_UPLOAD_KEY_PASSWORD')\r\n            \r\n            if (envStoreFile && envStorePassword && envKeyAlias && envKeyPassword) {\r\n                def keystoreFile = file(envStoreFile)\r\n                println \"Keystore file path: \\${envStoreFile}\"\r\n                println \"Keystore file exists: \\${keystoreFile.exists()}\"\r\n                \r\n                if (keystoreFile.exists()) {\r\n                    storeFile keystoreFile\r\n                    storePassword envStorePassword\r\n                    keyAlias envKeyAlias\r\n                    keyPassword envKeyPassword\r\n                    println \"Release signing config configured successfully\"\r\n                } else {\r\n                    println \"Keystore file not found: \\${envStoreFile}\"\r\n                }\r\n            } else {\r\n                println \"Missing signing environment variables:\"\r\n                println \"  MYAPP_UPLOAD_STORE_FILE: \\${envStoreFile}\"\r\n                println \"  MYAPP_UPLOAD_STORE_PASSWORD: \\${envStorePassword ? '***' : 'null'}\"\r\n                println \"  MYAPP_UPLOAD_KEY_ALIAS: \\${envKeyAlias}\"\r\n                println \"  MYAPP_UPLOAD_KEY_PASSWORD: \\${envKeyPassword ? '***' : 'null'}\"\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Use afterEvaluate to forcefully override the release signing config\r\nafterEvaluate {\r\n    def releaseSigningConfig = android.signingConfigs.release\r\n    println \"🔧 Final signing config check:\"\r\n    println \"  Release signingConfig storeFile: \\${releaseSigningConfig.storeFile}\"\r\n    println \"  Current release buildType signingConfig: \\${android.buildTypes.release.signingConfig?.name}\"\r\n    \r\n    if (releaseSigningConfig.storeFile && releaseSigningConfig.storeFile.exists()) {\r\n        // Force override the signing config\r\n        android.buildTypes.release.signingConfig = releaseSigningConfig\r\n        println \"✅ Applied release signing config: \\${releaseSigningConfig.storeFile.absolutePath}\"\r\n        println \"  Final release buildType signingConfig: \\${android.buildTypes.release.signingConfig?.name}\"\r\n    } else {\r\n        println \"❌ Release signing config not applied, using debug keystore\"\r\n        if (releaseSigningConfig.storeFile) {\r\n            println \"   Keystore file does not exist: \\${releaseSigningConfig.storeFile.absolutePath}\"\r\n        } else {\r\n            println \"   No keystore file configured\"\r\n        }\r\n    }\r\n}\r\n`;\r\n      fs.writeFileSync(signingGradle, signingContent, 'utf8');\r\n\r\n      // Idempotently add apply from with-signing.gradle\r\n      let gradleText = fs.readFileSync(buildGradle, 'utf8');\r\n      if (!gradleText.includes(\"apply from: 'with-signing.gradle'\")) {\r\n        // Find the last apply from line and add our line after it\r\n        const applyFromLines = gradleText.match(/apply from: '[^']+'/g);\r\n        if (applyFromLines && applyFromLines.length > 0) {\r\n          const lastApplyFrom = applyFromLines[applyFromLines.length - 1];\r\n          gradleText = gradleText.replace(\r\n            lastApplyFrom,\r\n            `${lastApplyFrom}\\napply from: 'with-signing.gradle'`,\r\n          );\r\n        } else {\r\n          // If no apply from lines found, add after React plugin\r\n          gradleText = gradleText.replace(\r\n            /apply plugin: \"com\\.facebook\\.react\"/,\r\n            `apply plugin: \"com.facebook.react\"\\napply from: 'with-signing.gradle'`,\r\n          );\r\n        }\r\n        fs.writeFileSync(buildGradle, gradleText, 'utf8');\r\n      }\r\n\r\n      return cfg;\r\n    },\r\n  ]);\r\n};\r\n","size_bytes":4649},"src/App.tsx":{"content":"import React, {useEffect} from 'react';\nimport Home from './screens/home/Home';\nimport Info from './screens/home/Info';\nimport Player from './screens/home/Player';\nimport Settings from './screens/settings/Settings';\nimport WatchList from './screens/WatchList';\nimport Search from './screens/Search';\nimport ScrollList from './screens/ScrollList';\nimport {\n  NavigationContainer,\n  createNavigationContainerRef,\n} from '@react-navigation/native';\nimport {createBottomTabNavigator} from '@react-navigation/bottom-tabs';\nimport {createNativeStackNavigator} from '@react-navigation/native-stack';\nimport Ionicons from '@expo/vector-icons/Ionicons';\nimport Entypo from '@expo/vector-icons/Entypo';\nimport 'react-native-reanimated';\nimport 'react-native-gesture-handler';\nimport WebView from './screens/WebView';\nimport SearchResults from './screens/SearchResults';\nimport * as SystemUI from 'expo-system-ui';\n// import DisableProviders from './screens/settings/DisableProviders';\nimport About, {checkForUpdate} from './screens/settings/About';\nimport BootSplash from 'react-native-bootsplash';\nimport {enableFreeze, enableScreens} from 'react-native-screens';\nimport Preferences from './screens/settings/Preference';\nimport useThemeStore from './lib/zustand/themeStore';\nimport {Dimensions, LogBox, ViewStyle} from 'react-native';\nimport {EpisodeLink} from './lib/providers/types';\nimport RNReactNativeHapticFeedback from 'react-native-haptic-feedback';\nimport TabBarBackgound from './components/TabBarBackgound';\nimport {TouchableOpacity} from 'react-native';\nimport {SafeAreaProvider, SafeAreaView} from 'react-native-safe-area-context';\nimport {StyleProp} from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport Downloads from './screens/settings/Downloads';\nimport SeriesEpisodes from './screens/settings/SeriesEpisodes';\nimport WatchHistory from './screens/WatchHistory';\nimport SubtitlePreference from './screens/settings/SubtitleSettings';\nimport Extensions from './screens/settings/Extensions';\nimport Constants from 'expo-constants';\nimport {settingsStorage} from './lib/storage';\nimport {updateProvidersService} from './lib/services/UpdateProviders';\nimport {QueryClientProvider} from '@tanstack/react-query';\nimport {queryClient} from './lib/client';\nimport GlobalErrorBoundary from './components/GlobalErrorBoundary';\nimport notifee from '@notifee/react-native';\nimport notificationService from './lib/services/Notification';\n// Lazy-load Firebase modules so app runs without google-services files\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst getAnalytics = (): any | null => {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return require('@react-native-firebase/analytics').default;\n  } catch {\n    return null;\n  }\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst getCrashlytics = (): any | null => {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return require('@react-native-firebase/crashlytics').default;\n  } catch {\n    return null;\n  }\n};\n\nenableScreens(true);\nenableFreeze(true);\n\nconst isLargeScreen = Dimensions.get('window').width > 768;\n\nexport type HomeStackParamList = {\n  Home: undefined;\n  Info: {link: string; provider?: string; poster?: string};\n  ScrollList: {\n    filter: string;\n    title?: string;\n    providerValue?: string;\n    isSearch: boolean;\n  };\n  Webview: {link: string};\n};\n\nexport type RootStackParamList = {\n  TabStack:\n    | {\n        screen?: keyof TabStackParamList;\n        params?: {\n          screen?: string;\n          params?: {\n            screen?: string;\n            params?: any;\n          };\n        };\n      }\n    | undefined;\n  Player: {\n    linkIndex: number;\n    episodeList: EpisodeLink[];\n    directUrl?: string;\n    type: string;\n    primaryTitle?: string;\n    secondaryTitle?: string;\n    poster: {\n      logo?: string;\n      poster?: string;\n      background?: string;\n    };\n    file?: string;\n    providerValue?: string;\n    infoUrl?: string;\n  };\n};\n\nexport type SearchStackParamList = {\n  Search: undefined;\n  ScrollList: {\n    filter: string;\n    title?: string;\n    providerValue?: string;\n    isSearch: boolean;\n  };\n  Info: {link: string; provider?: string; poster?: string};\n  SearchResults: {filter: string; availableProviders?: string[]};\n};\n\nexport type WatchListStackParamList = {\n  WatchList: undefined;\n  Info: {link: string; provider?: string; poster?: string};\n};\n\nexport type WatchHistoryStackParamList = {\n  WatchHistory: undefined;\n  Info: {link: string; provider?: string; poster?: string};\n  SeriesEpisodes: {\n    series: string;\n    episodes: Array<{uri: string; size: number}>;\n    thumbnails: Record<string, string>;\n  };\n};\n\nexport type SettingsStackParamList = {\n  Settings: undefined;\n  DisableProviders: undefined;\n  About: undefined;\n  Preferences: undefined;\n  Downloads: undefined;\n  WatchHistoryStack: undefined;\n  SubTitlesPreferences: undefined;\n  Extensions: undefined;\n};\n\nexport type TabStackParamList = {\n  HomeStack: undefined;\n  SearchStack: undefined;\n  WatchListStack: undefined;\n  SettingsStack: undefined;\n};\nconst Tab = createBottomTabNavigator<TabStackParamList>();\nexport const navigationRef = createNavigationContainerRef<RootStackParamList>();\nconst App = () => {\n  LogBox.ignoreLogs([\n    'You have passed a style to FlashList',\n    'new NativeEventEmitter()',\n  ]);\n  const HomeStack = createNativeStackNavigator<HomeStackParamList>();\n  const Stack = createNativeStackNavigator<RootStackParamList>();\n  const SearchStack = createNativeStackNavigator<SearchStackParamList>();\n  const WatchListStack = createNativeStackNavigator<WatchListStackParamList>();\n  const SettingsStack = createNativeStackNavigator<SettingsStackParamList>();\n  const WatchHistoryStack =\n    createNativeStackNavigator<WatchHistoryStackParamList>();\n  const {primary} = useThemeStore(state => state);\n  const hasFirebase = Boolean(Constants?.expoConfig?.extra?.hasFirebase);\n\n  const showTabBarLables = settingsStorage.showTabBarLabels();\n\n  SystemUI.setBackgroundColorAsync('black');\n\n  useEffect(() => {\n    // Apply telemetry preference before using analytics\n    const optIn = settingsStorage.isTelemetryOptIn();\n    if (hasFirebase) {\n      try {\n        const crashlytics = getCrashlytics();\n        crashlytics && crashlytics().setCrashlyticsCollectionEnabled(optIn);\n      } catch {}\n      try {\n        const analytics = getAnalytics();\n        analytics && analytics().setAnalyticsCollectionEnabled(optIn);\n      } catch {}\n      try {\n        const analytics = getAnalytics();\n        analytics &&\n          analytics().setConsent({\n            analytics_storage: optIn,\n            ad_storage: optIn,\n            ad_user_data: optIn,\n            ad_personalization: optIn,\n          });\n      } catch {}\n\n      // Mark app open\n      try {\n        const analytics = getAnalytics();\n        analytics && analytics().logAppOpen();\n      } catch {}\n      // Example user property: theme\n      try {\n        const analytics = getAnalytics();\n        analytics &&\n          analytics().setUserProperty(\n            'theme_preference',\n            primary ? 'custom' : 'default',\n          );\n      } catch {}\n\n      // Initial Crashlytics log\n      try {\n        const crashlytics = getCrashlytics();\n        crashlytics && crashlytics().log('App mounted');\n      } catch {}\n    }\n\n    const unsubscribe = notifee.onForegroundEvent(({type, detail}) => {\n      notificationService.actionHandler({type, detail});\n    });\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  // Initialize update service\n  useEffect(() => {\n    // Start automatic update checking at app startup\n    updateProvidersService.startAutomaticUpdateCheck();\n\n    // Cleanup on unmount\n    return () => {\n      updateProvidersService.stopAutomaticUpdateCheck();\n    };\n  }, []);\n\n  function HomeStackScreen() {\n    return (\n      <HomeStack.Navigator\n        screenOptions={{\n          headerShown: false,\n          animation: 'ios_from_right',\n          animationDuration: 200,\n          freezeOnBlur: true,\n        }}>\n        <HomeStack.Screen name=\"Home\" component={Home} />\n        <HomeStack.Screen name=\"Info\" component={Info} />\n        <HomeStack.Screen name=\"ScrollList\" component={ScrollList} />\n        <HomeStack.Screen name=\"Webview\" component={WebView} />\n      </HomeStack.Navigator>\n    );\n  }\n\n  function SearchStackScreen() {\n    return (\n      <SearchStack.Navigator\n        screenOptions={{\n          headerShown: false,\n          animation: 'ios_from_right',\n          animationDuration: 200,\n          freezeOnBlur: true,\n        }}>\n        <SearchStack.Screen name=\"Search\" component={Search} />\n        <SearchStack.Screen name=\"ScrollList\" component={ScrollList} />\n        <SearchStack.Screen name=\"Info\" component={Info} />\n        <SearchStack.Screen name=\"SearchResults\" component={SearchResults} />\n        <HomeStack.Screen name=\"Webview\" component={WebView} />\n      </SearchStack.Navigator>\n    );\n  }\n\n  function WatchListStackScreen() {\n    return (\n      <WatchListStack.Navigator\n        screenOptions={{\n          headerShown: false,\n          animation: 'ios_from_right',\n          animationDuration: 200,\n          freezeOnBlur: true,\n        }}>\n        <WatchListStack.Screen name=\"WatchList\" component={WatchList} />\n        <WatchListStack.Screen name=\"Info\" component={Info} />\n      </WatchListStack.Navigator>\n    );\n  }\n\n  function WatchHistoryStackScreen() {\n    return (\n      <WatchHistoryStack.Navigator\n        screenOptions={{\n          headerShown: false,\n          animation: 'ios_from_right',\n          animationDuration: 200,\n          freezeOnBlur: true,\n        }}>\n        <WatchHistoryStack.Screen\n          name=\"WatchHistory\"\n          component={WatchHistory}\n        />\n        <WatchHistoryStack.Screen name=\"Info\" component={Info} />\n        <WatchHistoryStack.Screen\n          name=\"SeriesEpisodes\"\n          component={SeriesEpisodes}\n        />\n      </WatchHistoryStack.Navigator>\n    );\n  }\n\n  function SettingsStackScreen() {\n    return (\n      <SettingsStack.Navigator\n        screenOptions={{\n          headerShown: false,\n          animation: 'ios_from_right',\n          animationDuration: 200,\n          freezeOnBlur: true,\n        }}>\n        <SettingsStack.Screen name=\"Settings\" component={Settings} />\n        {/* <SettingsStack.Screen\n          name=\"DisableProviders\"\n          component={DisableProviders}\n        /> */}\n        <SettingsStack.Screen name=\"About\" component={About} />\n        <SettingsStack.Screen name=\"Preferences\" component={Preferences} />\n        <SettingsStack.Screen name=\"Downloads\" component={Downloads} />\n        <SettingsStack.Screen name=\"Extensions\" component={Extensions} />\n        <SettingsStack.Screen\n          name=\"WatchHistoryStack\"\n          component={WatchHistoryStackScreen}\n        />\n        <SettingsStack.Screen\n          name=\"SubTitlesPreferences\"\n          component={SubtitlePreference}\n        />\n      </SettingsStack.Navigator>\n    );\n  }\n  function TabStack() {\n    return (\n      <Tab.Navigator\n        detachInactiveScreens={true}\n        screenOptions={{\n          animation: 'shift',\n          tabBarLabelPosition: 'below-icon',\n          tabBarVariant: isLargeScreen ? 'material' : 'uikit',\n          popToTopOnBlur: false,\n          tabBarPosition: isLargeScreen ? 'left' : 'bottom',\n          headerShown: false,\n          freezeOnBlur: true,\n          tabBarActiveTintColor: primary,\n          tabBarInactiveTintColor: '#dadde3',\n          tabBarShowLabel: showTabBarLables,\n          tabBarStyle: !isLargeScreen\n            ? {\n                position: 'absolute',\n                bottom: 0,\n                height: 55,\n                borderRadius: 0,\n                // backgroundColor: 'rgba(0, 0, 0, 0.8)',\n                overflow: 'hidden',\n                elevation: 0,\n                borderTopWidth: 0,\n                paddingHorizontal: 0,\n                paddingTop: 5,\n              }\n            : {},\n          tabBarBackground: () => <TabBarBackgound />,\n          tabBarHideOnKeyboard: true,\n          tabBarButton: props => {\n            return (\n              <TouchableOpacity\n                accessibilityRole=\"button\"\n                accessibilityState={props.accessibilityState}\n                style={props.style as StyleProp<ViewStyle>}\n                onPress={e => {\n                  props.onPress && props.onPress(e);\n                  if (\n                    !props?.accessibilityState?.selected &&\n                    settingsStorage.isHapticFeedbackEnabled()\n                  ) {\n                    RNReactNativeHapticFeedback.trigger('effectTick', {\n                      enableVibrateFallback: true,\n                      ignoreAndroidSystemSettings: false,\n                    });\n                  }\n                }}>\n                {props.children}\n              </TouchableOpacity>\n            );\n          },\n        }}>\n        <Tab.Screen\n          name=\"HomeStack\"\n          component={HomeStackScreen}\n          options={{\n            title: 'Home',\n            tabBarIcon: ({focused, color, size}) => (\n              <Animated.View\n                style={{\n                  transform: [{scale: focused ? 1.1 : 1}],\n                }}>\n                {focused ? (\n                  <Ionicons name=\"home\" color={color} size={size} />\n                ) : (\n                  <Ionicons name=\"home-outline\" color={color} size={size} />\n                )}\n              </Animated.View>\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"SearchStack\"\n          component={SearchStackScreen}\n          options={{\n            title: 'Search',\n            tabBarIcon: ({focused, color, size}) => (\n              <Animated.View\n                style={{\n                  transform: [{scale: focused ? 1.1 : 1}],\n                }}>\n                {focused ? (\n                  <Ionicons name=\"search\" color={color} size={size} />\n                ) : (\n                  <Ionicons name=\"search-outline\" color={color} size={size} />\n                )}\n              </Animated.View>\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"WatchListStack\"\n          component={WatchListStackScreen}\n          options={{\n            title: 'Watch List',\n            tabBarIcon: ({focused, color, size}) => (\n              <Animated.View\n                style={{\n                  transform: [{scale: focused ? 1.1 : 1}],\n                }}>\n                {focused ? (\n                  <Entypo name=\"folder-video\" color={color} size={size} />\n                ) : (\n                  <Entypo name=\"folder-video\" color={color} size={size} />\n                )}\n              </Animated.View>\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"SettingsStack\"\n          component={SettingsStackScreen}\n          options={{\n            title: 'Settings',\n            tabBarIcon: ({focused, color, size}) => (\n              <Animated.View\n                style={{\n                  transform: [{scale: focused ? 1.1 : 1}],\n                }}>\n                {focused ? (\n                  <Ionicons name=\"settings\" color={color} size={size} />\n                ) : (\n                  <Ionicons name=\"settings-outline\" color={color} size={size} />\n                )}\n              </Animated.View>\n            ),\n          }}\n        />\n      </Tab.Navigator>\n    );\n  }\n\n  useEffect(() => {\n    if (settingsStorage.isAutoCheckUpdateEnabled()) {\n      checkForUpdate(() => {}, settingsStorage.isAutoDownloadEnabled(), false);\n    }\n  }, []);\n\n  return (\n    <GlobalErrorBoundary>\n      <SafeAreaProvider>\n        <QueryClientProvider client={queryClient}>\n          <SafeAreaView\n            edges={{\n              right: 'off',\n              top: 'off',\n              left: 'off',\n              bottom: 'additive',\n            }}\n            className=\"flex-1\"\n            style={{backgroundColor: 'black'}}>\n            <NavigationContainer\n              ref={navigationRef}\n              onReady={async () => {\n                // Hide bootsplash\n                await BootSplash.hide({fade: true});\n                // Track initial screen\n                if (hasFirebase) {\n                  try {\n                    const route = navigationRef.getCurrentRoute();\n                    if (route?.name) {\n                      const analytics = getAnalytics();\n                      analytics &&\n                        (await analytics().logScreenView({\n                          screen_name: route.name,\n                          screen_class: 'Navigation',\n                        }));\n                    }\n                  } catch {}\n                }\n              }}\n              onStateChange={async () => {\n                if (hasFirebase) {\n                  try {\n                    const route = navigationRef.getCurrentRoute();\n                    if (route?.name) {\n                      const analytics = getAnalytics();\n                      analytics &&\n                        (await analytics().logScreenView({\n                          screen_name: route.name,\n                          screen_class: 'Navigation',\n                        }));\n                    }\n                  } catch {}\n                }\n              }}\n              theme={{\n                fonts: {\n                  regular: {\n                    fontFamily: 'Inter_400Regular',\n                    fontWeight: '400',\n                  },\n                  medium: {\n                    fontFamily: 'Inter_500Medium',\n                    fontWeight: '500',\n                  },\n                  bold: {\n                    fontFamily: 'Inter_700Bold',\n                    fontWeight: '700',\n                  },\n                  heavy: {\n                    fontFamily: 'Inter_800ExtraBold',\n                    fontWeight: '800',\n                  },\n                },\n                dark: true,\n                colors: {\n                  background: 'transparent',\n                  card: 'black',\n                  primary: primary,\n                  text: 'white',\n                  border: 'black',\n                  notification: primary,\n                },\n              }}>\n              <Stack.Navigator\n                screenOptions={{\n                  headerShown: false,\n                  animation: 'ios_from_right',\n                  animationDuration: 200,\n                  freezeOnBlur: true,\n                  contentStyle: {backgroundColor: 'transparent'},\n                }}>\n                <Stack.Screen name=\"TabStack\" component={TabStack} />\n                <Stack.Screen\n                  name=\"Player\"\n                  component={Player}\n                  options={{orientation: 'landscape'}}\n                />\n              </Stack.Navigator>\n            </NavigationContainer>\n          </SafeAreaView>\n        </QueryClientProvider>\n      </SafeAreaProvider>\n    </GlobalErrorBoundary>\n  );\n};\n\nexport default App;\n","size_bytes":19120},"ios/VegaMovies/main.m":{"content":"#import <UIKit/UIKit.h>\n\n#import \"AppDelegate.h\"\n\nint main(int argc, char *argv[])\n{\n  @autoreleasepool {\n    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n  }\n}\n","size_bytes":199},"ios/VegaMoviesTests/VegaMoviesTests.m":{"content":"#import <UIKit/UIKit.h>\n#import <XCTest/XCTest.h>\n\n#import <React/RCTLog.h>\n#import <React/RCTRootView.h>\n\n#define TIMEOUT_SECONDS 600\n#define TEXT_TO_LOOK_FOR @\"Welcome to React\"\n\n@interface VegaMoviesTests : XCTestCase\n\n@end\n\n@implementation VegaMoviesTests\n\n- (BOOL)findSubviewInView:(UIView *)view matching:(BOOL (^)(UIView *view))test\n{\n  if (test(view)) {\n    return YES;\n  }\n  for (UIView *subview in [view subviews]) {\n    if ([self findSubviewInView:subview matching:test]) {\n      return YES;\n    }\n  }\n  return NO;\n}\n\n- (void)testRendersWelcomeScreen\n{\n  UIViewController *vc = [[[RCTSharedApplication() delegate] window] rootViewController];\n  NSDate *date = [NSDate dateWithTimeIntervalSinceNow:TIMEOUT_SECONDS];\n  BOOL foundElement = NO;\n\n  __block NSString *redboxError = nil;\n#ifdef DEBUG\n  RCTSetLogFunction(\n      ^(RCTLogLevel level, RCTLogSource source, NSString *fileName, NSNumber *lineNumber, NSString *message) {\n        if (level >= RCTLogLevelError) {\n          redboxError = message;\n        }\n      });\n#endif\n\n  while ([date timeIntervalSinceNow] > 0 && !foundElement && !redboxError) {\n    [[NSRunLoop mainRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];\n    [[NSRunLoop mainRunLoop] runMode:NSRunLoopCommonModes beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];\n\n    foundElement = [self findSubviewInView:vc.view\n                                  matching:^BOOL(UIView *view) {\n                                    if ([view.accessibilityLabel isEqualToString:TEXT_TO_LOOK_FOR]) {\n                                      return YES;\n                                    }\n                                    return NO;\n                                  }];\n  }\n\n#ifdef DEBUG\n  RCTSetLogFunction(RCTDefaultLogFunction);\n#endif\n\n  XCTAssertNil(redboxError, @\"RedBox error: %@\", redboxError);\n  XCTAssertTrue(foundElement, @\"Couldn't find element with text '%@' in %d seconds\", TEXT_TO_LOOK_FOR, TIMEOUT_SECONDS);\n}\n\n@end\n","size_bytes":1996},"src/components/ContinueWatching.tsx":{"content":"import React, {useEffect, useState} from 'react';\r\nimport {\r\n  View,\r\n  Text,\r\n  Image,\r\n  TouchableOpacity,\r\n  FlatList,\r\n  Pressable,\r\n} from 'react-native';\r\nimport useWatchHistoryStore from '../lib/zustand/watchHistrory';\r\nimport {mainStorage as MMKV} from '../lib/storage/StorageService';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport {NativeStackNavigationProp} from '@react-navigation/native-stack';\r\nimport {TabStackParamList} from '../App';\r\nimport AntDesign from '@expo/vector-icons/AntDesign';\r\nimport ReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport {MaterialCommunityIcons} from '@expo/vector-icons';\r\n\r\nconst ContinueWatching = () => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const navigation =\r\n    useNavigation<NativeStackNavigationProp<TabStackParamList>>();\r\n  const {history, removeItem} = useWatchHistoryStore(state => state);\r\n  const [progressData, setProgressData] = useState<Record<string, number>>({});\r\n  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());\r\n  const [selectionMode, setSelectionMode] = useState<boolean>(false);\r\n\r\n  // Filter out duplicates and get the most recent items\r\n  const recentItems = React.useMemo(() => {\r\n    const seen = new Set();\r\n    const items = history\r\n      .filter(item => {\r\n        if (seen.has(item.link)) {\r\n          return false;\r\n        }\r\n        seen.add(item.link);\r\n        return true;\r\n      })\r\n      .slice(0, 10); // Limit to 10 items\r\n\r\n    return items;\r\n  }, [history]);\r\n\r\n  // Load progress data\r\n  useEffect(() => {\r\n    const loadProgressData = () => {\r\n      const progressMap: Record<string, number> = {};\r\n\r\n      recentItems.forEach(item => {\r\n        try {\r\n          // Try to get dedicated watch history progress\r\n          const historyKey = item.link;\r\n          const historyProgressKey = `watch_history_progress_${historyKey}`;\r\n          const storedProgress = MMKV.getString(historyProgressKey);\r\n\r\n          if (storedProgress) {\r\n            const parsed = JSON.parse(storedProgress);\r\n            if (parsed.percentage) {\r\n              progressMap[item.link] = Math.min(\r\n                Math.max(parsed.percentage, 0),\r\n                100,\r\n              );\r\n            } else if (parsed.currentTime && parsed.duration) {\r\n              const percentage = (parsed.currentTime / parsed.duration) * 100;\r\n              progressMap[item.link] = Math.min(Math.max(percentage, 0), 100);\r\n            }\r\n          } else if (item.currentTime && item.duration) {\r\n            const percentage = (item.currentTime / item.duration) * 100;\r\n            progressMap[item.link] = Math.min(Math.max(percentage, 0), 100);\r\n          }\r\n        } catch (e) {\r\n          console.error('Error processing progress for item:', item.title, e);\r\n        }\r\n      });\r\n\r\n      setProgressData(progressMap);\r\n    };\r\n\r\n    loadProgressData();\r\n  }, [recentItems]);\r\n\r\n  const handleNavigateToInfo = (item: any) => {\r\n    try {\r\n      // Parse the link if it's a JSON string\r\n      let linkData = item.link;\r\n      if (typeof item.link === 'string' && item.link.startsWith('{')) {\r\n        try {\r\n          linkData = JSON.parse(item.link);\r\n        } catch (e) {\r\n          console.error('Failed to parse link:', e);\r\n        }\r\n      }\r\n      console.log('linkData', item.poster);\r\n      // Navigate to Info screen\r\n      navigation.navigate('HomeStack', {\r\n        screen: 'Info',\r\n        params: {\r\n          link: linkData,\r\n          provider: item.provider,\r\n          poster: item.poster,\r\n        },\r\n      } as any);\r\n    } catch (error) {\r\n      console.error('Navigation error:', error);\r\n    }\r\n  };\r\n\r\n  const toggleItemSelection = (link: string) => {\r\n    setSelectedItems(prev => {\r\n      const newSelected = new Set(prev);\r\n      if (newSelected.has(link)) {\r\n        newSelected.delete(link);\r\n      } else {\r\n        newSelected.add(link);\r\n      }\r\n\r\n      // Exit selection mode if no items are selected\r\n      if (newSelected.size === 0) {\r\n        setSelectionMode(false);\r\n      }\r\n\r\n      return newSelected;\r\n    });\r\n  };\r\n\r\n  const handleLongPress = (link: string) => {\r\n    ReactNativeHapticFeedback.trigger('effectClick', {\r\n      enableVibrateFallback: true,\r\n      ignoreAndroidSystemSettings: false,\r\n    });\r\n\r\n    // Enter selection mode if not already in it\r\n    if (!selectionMode) {\r\n      setSelectionMode(true);\r\n    }\r\n\r\n    toggleItemSelection(link);\r\n  };\r\n\r\n  const handlePress = (item: any) => {\r\n    if (selectionMode) {\r\n      toggleItemSelection(item.link);\r\n    } else {\r\n      handleNavigateToInfo(item);\r\n    }\r\n  };\r\n\r\n  const deleteSelectedItems = () => {\r\n    recentItems.forEach(item => {\r\n      if (selectedItems.has(item.link)) {\r\n        removeItem(item);\r\n      }\r\n    });\r\n    setSelectedItems(new Set());\r\n    setSelectionMode(false);\r\n  };\r\n\r\n  const exitSelectionMode = () => {\r\n    setSelectedItems(new Set());\r\n    setSelectionMode(false);\r\n  };\r\n\r\n  // Only render if we have items (MOVED AFTER ALL HOOKS)\r\n  if (recentItems.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <Pressable\r\n      onPress={() => selectionMode && exitSelectionMode()}\r\n      className=\"mt-3 mb-8\">\r\n      <View className=\"flex flex-row justify-between items-center px-2 mb-3\">\r\n        <Text className=\"text-2xl font-semibold\" style={{color: primary}}>\r\n          Continue Watching\r\n        </Text>\r\n\r\n        {selectionMode && selectedItems.size > 0 && (\r\n          <View className=\"flex flex-row items-center\">\r\n            <Text className=\"text-white mr-1\">\r\n              {selectedItems.size} selected\r\n            </Text>\r\n            <TouchableOpacity\r\n              onPress={deleteSelectedItems}\r\n              className=\" rounded-full mr-2\">\r\n              <MaterialCommunityIcons\r\n                name=\"delete-outline\"\r\n                size={25}\r\n                color={primary}\r\n              />\r\n            </TouchableOpacity>\r\n          </View>\r\n        )}\r\n      </View>\r\n\r\n      <FlatList\r\n        data={recentItems}\r\n        horizontal\r\n        showsHorizontalScrollIndicator={false}\r\n        keyExtractor={item => item.link}\r\n        contentContainerStyle={{paddingHorizontal: 12}}\r\n        renderItem={({item}) => {\r\n          const progress = progressData[item.link] || 0;\r\n          const isSelected = selectedItems.has(item.link);\r\n\r\n          return (\r\n            <TouchableOpacity\r\n              activeOpacity={0.8}\r\n              className=\"max-w-[100px] mx-2\"\r\n              onLongPress={e => {\r\n                e.stopPropagation();\r\n                handleLongPress(item.link);\r\n              }}\r\n              onPress={e => {\r\n                e.stopPropagation();\r\n                handlePress(item);\r\n              }}>\r\n              <View className=\"relative\">\r\n                {/* Poster Image */}\r\n                <Image\r\n                  source={{uri: item?.poster}}\r\n                  className=\"rounded-md\"\r\n                  style={{width: 100, height: 150}}\r\n                />\r\n\r\n                {/* Selection Indicator */}\r\n                {selectionMode && (\r\n                  <View className=\"absolute top-2 right-2 z-50\">\r\n                    <View\r\n                      className={`w-5 h-5 rounded-full flex items-center justify-center ${\r\n                        isSelected ? '' : 'bg-white/30'\r\n                      }`}\r\n                      style={{\r\n                        borderWidth: 1,\r\n                        borderColor: 'white',\r\n                        backgroundColor: isSelected ? primary : undefined,\r\n                      }}>\r\n                      {isSelected && (\r\n                        <AntDesign name=\"check\" size={12} color=\"white\" />\r\n                      )}\r\n                    </View>\r\n                  </View>\r\n                )}\r\n\r\n                {/* Selection Overlay */}\r\n                {isSelected && (\r\n                  <View className=\"absolute top-0 left-0 right-0 bottom-0 bg-black/30 rounded-lg\" />\r\n                )}\r\n\r\n                {/* Progress Bar */}\r\n                <View\r\n                  className=\"absolute bottom-0 left-0 right-0 h-1\"\r\n                  style={{backgroundColor: 'rgba(0,0,0,0.5)'}}>\r\n                  <View\r\n                    style={{\r\n                      position: 'absolute',\r\n                      left: 0,\r\n                      top: 0,\r\n                      height: '100%',\r\n                      width: `${progress}%`,\r\n                      backgroundColor: primary,\r\n                    }}\r\n                  />\r\n                </View>\r\n              </View>\r\n              <Text\r\n                className=\"text-white text-center truncate w-24 text-xs\"\r\n                numberOfLines={2}>\r\n                {item.title}\r\n              </Text>\r\n            </TouchableOpacity>\r\n          );\r\n        }}\r\n      />\r\n    </Pressable>\r\n  );\r\n};\r\n\r\nexport default ContinueWatching;\r\n","size_bytes":8989},"src/components/DownloadBottomSheet.tsx":{"content":"import {\r\n  Text,\r\n  Modal,\r\n  Pressable,\r\n  TouchableOpacity,\r\n  Dimensions,\r\n  ToastAndroid,\r\n  View,\r\n} from 'react-native';\r\nimport React, {useEffect, useRef} from 'react';\r\nimport {Stream} from '../lib/providers/types';\r\nimport BottomSheet, {BottomSheetScrollView} from '@gorhom/bottom-sheet';\r\nimport {GestureHandlerRootView} from 'react-native-gesture-handler';\r\nimport SkeletonLoader from './Skeleton';\r\nimport RNReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport {Clipboard} from 'react-native';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport {TextTrackType} from 'react-native-video';\r\nimport {settingsStorage} from '../lib/storage';\r\n\r\ntype Props = {\r\n  data: Stream[];\r\n  loading: boolean;\r\n  title: string;\r\n  showModal: boolean;\r\n  setModal: (value: boolean) => void;\r\n  onPressVideo: (item: any) => void;\r\n  onPressSubs: (item: any) => void;\r\n};\r\nconst DownloadBottomSheet = ({\r\n  data,\r\n  loading,\r\n  showModal,\r\n  setModal,\r\n  title,\r\n  onPressSubs,\r\n  onPressVideo,\r\n}: Props) => {\r\n  const bottomSheetRef = useRef<BottomSheet>(null);\r\n  const {primary} = useThemeStore(state => state);\r\n  const [activeTab, setActiveTab] = React.useState<1 | 2>(1);\r\n\r\n  const subtitle = data?.map(server => {\r\n    if (server.subtitles && server.subtitles.length > 0) {\r\n      return server.subtitles;\r\n    }\r\n  });\r\n  useEffect(() => {\r\n    if (showModal) {\r\n      bottomSheetRef.current?.expand();\r\n    } else {\r\n      bottomSheetRef.current?.close();\r\n    }\r\n  }, [showModal]);\r\n  return (\r\n    <Modal\r\n      onRequestClose={() => {\r\n        bottomSheetRef.current?.close();\r\n      }}\r\n      visible={showModal}\r\n      transparent={true}>\r\n      <GestureHandlerRootView>\r\n        <Pressable\r\n          onPress={() => bottomSheetRef.current?.close()}\r\n          className=\"flex-1\">\r\n          <BottomSheet\r\n            // detached={true}\r\n            enablePanDownToClose={true}\r\n            snapPoints={['30%', 450]}\r\n            containerStyle={{marginHorizontal: 5}}\r\n            ref={bottomSheetRef}\r\n            backgroundStyle={{backgroundColor: '#1a1a1a'}}\r\n            handleIndicatorStyle={{backgroundColor: '#333'}}\r\n            onClose={() => setModal(false)}>\r\n            <Pressable className=\"flex-1\" onPress={e => e.stopPropagation()}>\r\n              <Text className=\"text-white text-xl p-1 font-semibold text-center\">\r\n                {title}\r\n              </Text>\r\n              <BottomSheetScrollView\r\n                style={{padding: 5, marginBottom: 5}}\r\n                showsVerticalScrollIndicator={false}>\r\n                {subtitle.length > 0 && subtitle[0] !== undefined && (\r\n                  <View className=\"flex-row items-center justify-center gap-x-3 w-full my-5\">\r\n                    <Text\r\n                      className={'text-lg p-1 font-semibold text-center'}\r\n                      style={{\r\n                        color: activeTab === 1 ? primary : 'white',\r\n                        borderBottomWidth: activeTab === 1 ? 2 : 0,\r\n                        borderBottomColor:\r\n                          activeTab === 1 ? 'white' : 'transparent',\r\n                      }}\r\n                      onPress={() => setActiveTab(1)}>\r\n                      Video\r\n                    </Text>\r\n                    <Text\r\n                      className={'text-lg p-1 font-semibold text-center'}\r\n                      style={{\r\n                        color: activeTab === 2 ? primary : 'white',\r\n                        borderBottomWidth: activeTab === 2 ? 2 : 0,\r\n                        borderBottomColor:\r\n                          activeTab === 2 ? 'white' : 'transparent',\r\n                      }}\r\n                      onPress={() => setActiveTab(2)}>\r\n                      Subtitle\r\n                    </Text>\r\n                  </View>\r\n                )}\r\n                {loading\r\n                  ? Array.from({length: 4}).map((_, index) => (\r\n                      <SkeletonLoader\r\n                        key={index}\r\n                        width={Dimensions.get('window').width - 30}\r\n                        height={35}\r\n                        marginVertical={5}\r\n                      />\r\n                    ))\r\n                  : activeTab === 1\r\n                  ? data.map(item => (\r\n                      <TouchableOpacity\r\n                        className=\"p-2 bg-white/30 rounded-md my-1\"\r\n                        key={item.link}\r\n                        onLongPress={() => {\r\n                          if (settingsStorage.isHapticFeedbackEnabled()) {\r\n                            RNReactNativeHapticFeedback.trigger('effectTick', {\r\n                              enableVibrateFallback: true,\r\n                              ignoreAndroidSystemSettings: false,\r\n                            });\r\n                          }\r\n                          Clipboard.setString(item.link);\r\n                          ToastAndroid.show('Link copied', ToastAndroid.SHORT);\r\n                        }}\r\n                        onPress={() => {\r\n                          onPressVideo(item);\r\n                          bottomSheetRef.current?.close();\r\n                        }}>\r\n                        <Text style={{color: 'white'}}>{item.server}</Text>\r\n                      </TouchableOpacity>\r\n                    ))\r\n                  : subtitle.length > 0\r\n                  ? subtitle.map(\r\n                      subs =>\r\n                        subs?.map(item => (\r\n                          <TouchableOpacity\r\n                            className=\"p-2 bg-white/30 rounded-md my-1\"\r\n                            key={item.uri}\r\n                            onLongPress={() => {\r\n                              if (settingsStorage.isHapticFeedbackEnabled()) {\r\n                                RNReactNativeHapticFeedback.trigger(\r\n                                  'effectTick',\r\n                                  {\r\n                                    enableVibrateFallback: true,\r\n                                    ignoreAndroidSystemSettings: false,\r\n                                  },\r\n                                );\r\n                              }\r\n                              Clipboard.setString(item.uri);\r\n                              ToastAndroid.show(\r\n                                'Link copied',\r\n                                ToastAndroid.SHORT,\r\n                              );\r\n                            }}\r\n                            onPress={() => {\r\n                              onPressSubs({\r\n                                server: 'Subtitles',\r\n                                link: item.uri,\r\n                                type:\r\n                                  item.type === TextTrackType.VTT\r\n                                    ? 'vtt'\r\n                                    : 'srt',\r\n                                title: item.title,\r\n                              });\r\n                              bottomSheetRef.current?.close();\r\n                            }}>\r\n                            <Text style={{color: 'white'}}>\r\n                              {item.language}\r\n                              {' - '} {item.title}\r\n                            </Text>\r\n                          </TouchableOpacity>\r\n                        )),\r\n                    )\r\n                  : null}\r\n                {data.length === 0 && !loading && (\r\n                  <Text className=\"text-red-500 text-lg text-center\">\r\n                    No server found\r\n                  </Text>\r\n                )}\r\n              </BottomSheetScrollView>\r\n            </Pressable>\r\n          </BottomSheet>\r\n        </Pressable>\r\n      </GestureHandlerRootView>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nexport default DownloadBottomSheet;\r\n","size_bytes":7759},"src/components/Downloader.tsx":{"content":"import React, {useEffect, useLayoutEffect, useState} from 'react';\r\nimport {View, Text, TouchableOpacity, Modal, Pressable} from 'react-native';\r\nimport {ifExists} from '../lib/file/ifExists';\r\nimport MaterialIcons from '@expo/vector-icons/MaterialIcons';\r\nimport Octicons from '@expo/vector-icons/Octicons';\r\nimport {Stream} from '../lib/providers/types';\r\nimport {MotiView} from 'moti';\r\nimport ReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport useContentStore from '../lib/zustand/contentStore';\r\nimport * as IntentLauncher from 'expo-intent-launcher';\r\nimport {downloadManager} from '../lib/downloader';\r\nimport {cancelHlsDownload} from '../lib/hlsDownloader2';\r\n// import {FFmpegKit} from 'ffmpeg-kit-react-native';\r\nimport * as RNFS from '@dr.pogodin/react-native-fs';\r\nimport {downloadFolder} from '../lib/constants';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport DownloadBottomSheet from './DownloadBottomSheet';\r\nimport {settingsStorage} from '../lib/storage';\r\nimport {providerManager} from '../lib/services/ProviderManager';\r\n\r\nconst DownloadComponent = ({\r\n  link,\r\n  fileName,\r\n  type,\r\n  providerValue,\r\n  title,\r\n}: {\r\n  link: string;\r\n  fileName: string;\r\n  type: string;\r\n  providerValue: string;\r\n  title: string;\r\n}) => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const {provider} = useContentStore(state => state);\r\n  const [alreadyDownloaded, setAlreadyDownloaded] = useState<string | boolean>(\r\n    false,\r\n  );\r\n  const [deleteModal, setDeleteModal] = useState(false);\r\n  const [downloadModal, setDownloadModal] = useState(false);\r\n  const [longPressModal, setLongPressModal] = useState(false);\r\n  const [cancelModal, setCancelModal] = useState(false);\r\n  const [downloadId, setDownloadId] = useState<number | null>(null);\r\n  const [servers, setServers] = useState<Stream[]>([]);\r\n  const [serverLoading, setServerLoading] = useState(false);\r\n  const [downloadActive, setDownloadActive] = useState(false);\r\n\r\n  // check if file already exists\r\n  useLayoutEffect(() => {\r\n    const checkIfDownloaded = async () => {\r\n      const exists = await ifExists(fileName);\r\n      setAlreadyDownloaded(exists);\r\n    };\r\n    checkIfDownloaded();\r\n  }, [fileName]);\r\n\r\n  // handle download deletion\r\n  const deleteDownload = async () => {\r\n    try {\r\n      const fileList = await RNFS.readDir(downloadFolder);\r\n      // Find a file with the given name (without extension)\r\n      const foundFile = fileList.find(fileItem => {\r\n        const nameWithoutExtension = fileItem.name\r\n          .split('.')\r\n          .slice(0, -1)\r\n          .join('.');\r\n        return nameWithoutExtension === fileName;\r\n      });\r\n      if (foundFile) {\r\n        await RNFS.unlink(foundFile.path);\r\n        setAlreadyDownloaded(false);\r\n        setDeleteModal(false);\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  };\r\n\r\n  // choose server\r\n  useEffect(() => {\r\n    const controller = new AbortController();\r\n    if (!downloadModal && !longPressModal) {\r\n      return;\r\n    }\r\n    const getServer = async () => {\r\n      setServerLoading(true);\r\n      const servers = await providerManager.getStream({\r\n        link,\r\n        type,\r\n        signal: controller.signal,\r\n        providerValue: providerValue || provider.value,\r\n      });\r\n      const filteredServers = servers;\r\n      // .filter(\r\n      //   server =>\r\n      //     !manifest[\r\n      //       providerValue || provider.value\r\n      //     ].nonDownloadableServer?.includes(server.server),\r\n      // );\r\n      setServerLoading(false);\r\n      setServers(filteredServers);\r\n    };\r\n    getServer();\r\n\r\n    return () => {\r\n      controller.abort();\r\n    };\r\n  }, [downloadModal, longPressModal]);\r\n\r\n  // on holdPress external downloader\r\n  const longPressDownload = async (link: string, type?: string) => {\r\n    try {\r\n      await IntentLauncher.startActivityAsync('android.intent.action.VIEW', {\r\n        data: link,\r\n        type: type || 'video/*',\r\n      });\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <View className=\"flex-row items-center mt-1 justify-between rounded-full bg-white/30 p-1\">\r\n        {downloadActive ? (\r\n          <MotiView\r\n            style={{\r\n              marginHorizontal: 4,\r\n            }}\r\n            // animate opacity to opacity while downloding\r\n            from={{opacity: 1}}\r\n            animate={{opacity: 0.5}}\r\n            //@ts-ignore\r\n            transition={{type: 'timing', duration: 500, loop: true}}>\r\n            <TouchableOpacity\r\n              onPress={() => {\r\n                setCancelModal(prev => !prev);\r\n                console.log('pressed');\r\n              }}>\r\n              <MaterialIcons name=\"downloading\" size={27} color={primary} />\r\n            </TouchableOpacity>\r\n          </MotiView>\r\n        ) : alreadyDownloaded ? (\r\n          <TouchableOpacity\r\n            onPress={() => setDeleteModal(true)}\r\n            className=\"mx-1\">\r\n            <MaterialIcons name=\"delete-outline\" size={27} color=\"#c1c4c9\" />\r\n          </TouchableOpacity>\r\n        ) : (\r\n          <TouchableOpacity\r\n            onPress={() => {\r\n              if (\r\n                settingsStorage.getBool('alwaysExternalDownloader') === true\r\n              ) {\r\n                setLongPressModal(true);\r\n              } else {\r\n                setDownloadModal(true);\r\n              }\r\n            }}\r\n            onLongPress={() => {\r\n              if (settingsStorage.getBool('hapticFeedback') !== false) {\r\n                ReactNativeHapticFeedback.trigger('effectHeavyClick', {\r\n                  enableVibrateFallback: true,\r\n                  ignoreAndroidSystemSettings: false,\r\n                });\r\n              }\r\n              setLongPressModal(true);\r\n            }}\r\n            className=\"mx-2\">\r\n            <Octicons name=\"download\" size={25} color=\"#c1c4c9\" />\r\n          </TouchableOpacity>\r\n        )}\r\n        {/* delete modal */}\r\n        {\r\n          <Modal animationType=\"fade\" visible={deleteModal} transparent={true}>\r\n            <View className=\"flex-1 bg-black/10 justify-center items-center p-4\">\r\n              <View className=\"bg-tertiary p-3 w-80 rounded-md justify-center items-center\">\r\n                <Text className=\"text-2xl font-semibold my-3 text-white\">\r\n                  Confirm to delete\r\n                </Text>\r\n                <View className=\"flex-row items-center justify-evenly w-full my-5\">\r\n                  <TouchableOpacity\r\n                    onPress={deleteDownload}\r\n                    className=\"p-2 rounded-md m-1 px-3\"\r\n                    style={{backgroundColor: primary}}>\r\n                    <Text className=\"text-white font-semibold text-base rounded-md capitalize px-1\">\r\n                      Yes\r\n                    </Text>\r\n                  </TouchableOpacity>\r\n                  <TouchableOpacity\r\n                    onPress={() => setDeleteModal(false)}\r\n                    className=\"p-2 px-4 rounded-md m-1\"\r\n                    style={{backgroundColor: primary}}>\r\n                    <Text className=\"text-white font-semibold text-base rounded-md capitalize px-1\">\r\n                      No\r\n                    </Text>\r\n                  </TouchableOpacity>\r\n                </View>\r\n              </View>\r\n            </View>\r\n          </Modal>\r\n        }\r\n        {/* download modal */}\r\n        <DownloadBottomSheet\r\n          setModal={setDownloadModal}\r\n          showModal={downloadModal}\r\n          data={servers}\r\n          loading={serverLoading}\r\n          title=\"Select Server To Download\"\r\n          onPressVideo={(server: Stream) => {\r\n            downloadManager({\r\n              title: title,\r\n              url: server.link,\r\n              fileName: fileName,\r\n              fileType: server.type,\r\n              setDownloadActive: setDownloadActive,\r\n              setAlreadyDownloaded: setAlreadyDownloaded,\r\n              setDownloadId: setDownloadId,\r\n              headers: server?.headers,\r\n              deleteDownload: deleteDownload,\r\n            });\r\n          }}\r\n          onPressSubs={(sub: {link: string; type: string; title: string}) => {\r\n            downloadManager({\r\n              title: title + ' ' + sub.title + ' Subtitle ',\r\n              url: sub.link,\r\n              fileName: fileName + '-' + sub.title,\r\n              fileType: sub.type,\r\n              setDownloadActive: setDownloadActive,\r\n              setAlreadyDownloaded: () => {},\r\n              setDownloadId: setDownloadId,\r\n              deleteDownload: () => {},\r\n            });\r\n          }}\r\n        />\r\n        {/* long press modal */}\r\n        <DownloadBottomSheet\r\n          setModal={setLongPressModal}\r\n          showModal={longPressModal}\r\n          data={servers}\r\n          loading={serverLoading}\r\n          title=\"Select Server To Open\"\r\n          onPressVideo={(server: Stream) => {\r\n            longPressDownload(server.link);\r\n          }}\r\n          onPressSubs={(sub: {link: string; type: string; title: string}) => {\r\n            longPressDownload(sub.link, 'text/vtt');\r\n          }}\r\n        />\r\n      </View>\r\n      {cancelModal && downloadId && (\r\n        <Pressable\r\n          onPress={async () => {\r\n            setCancelModal(false);\r\n            try {\r\n              // Check if this is an HLS download (ID >= 1000) or regular download\r\n              if (typeof downloadId === 'number' && downloadId >= 1000) {\r\n                // HLS download cancellation\r\n                cancelHlsDownload(downloadId);\r\n              } else {\r\n                // Regular download cancellation\r\n                RNFS.stopDownload(downloadId);\r\n                //FFMPEGKIT CANCEL\r\n                // FFmpegKit.cancel(downloadId);\r\n              }\r\n              setDownloadActive(false);\r\n\r\n              const files = await RNFS.readDir(downloadFolder);\r\n              // Find a file with the given name (without extension)\r\n              const foundFile = files.find(fileItem => {\r\n                const nameWithoutExtension = fileItem.name\r\n                  .split('.')\r\n                  .slice(0, -1)\r\n                  .join('.');\r\n                return nameWithoutExtension === fileName;\r\n              });\r\n              if (foundFile) {\r\n                await RNFS.unlink(foundFile.path);\r\n              }\r\n            } catch (error) {\r\n              console.log('Error cancelling download', error);\r\n            }\r\n          }}\r\n          className=\"absolute right-12 bg-quaternary/80 bottom-3 rounded-md px-2\">\r\n          <Text className=\"text-lg text-white\">Cancel</Text>\r\n        </Pressable>\r\n      )}\r\n    </>\r\n  );\r\n};\r\n\r\nexport default DownloadComponent;\r\n","size_bytes":10690},"src/components/ErrorBoundary.tsx":{"content":"import React from 'react';\r\nimport {View, Text, TouchableOpacity} from 'react-native';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\n\r\ninterface ErrorFallbackProps {\r\n  error: Error;\r\n  resetError: () => void;\r\n}\r\n\r\nexport const ErrorFallback: React.FC<ErrorFallbackProps> = ({\r\n  error,\r\n  resetError,\r\n}) => {\r\n  const {primary} = useThemeStore();\r\n  return (\r\n    <View className=\"flex-1 justify-center items-center p-4 bg-black\">\r\n      <Text className=\"text-red-400 text-lg font-bold mb-4 text-center\">\r\n        Something went wrong\r\n      </Text>\r\n      <Text className=\"text-gray-400 text-sm mb-6 text-center\">\r\n        {error.message || 'An unexpected error occurred'}\r\n      </Text>\r\n      <TouchableOpacity\r\n        onPress={resetError}\r\n        className=\"px-6 py-3 rounded-lg\"\r\n        style={{backgroundColor: primary}}>\r\n        <Text className=\"text-white font-semibold\">Try Again</Text>\r\n      </TouchableOpacity>\r\n    </View>\r\n  );\r\n};\r\n\r\ninterface QueryErrorBoundaryProps {\r\n  children: React.ReactNode;\r\n  fallback?: React.ComponentType<ErrorFallbackProps>;\r\n}\r\n\r\ninterface QueryErrorBoundaryState {\r\n  hasError: boolean;\r\n  error: Error | null;\r\n}\r\n\r\nexport class QueryErrorBoundary extends React.Component<\r\n  QueryErrorBoundaryProps,\r\n  QueryErrorBoundaryState\r\n> {\r\n  constructor(props: QueryErrorBoundaryProps) {\r\n    super(props);\r\n    this.state = {hasError: false, error: null};\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error): QueryErrorBoundaryState {\r\n    return {hasError: true, error};\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\r\n    console.error('QueryErrorBoundary caught an error:', error, errorInfo);\r\n  }\r\n\r\n  resetError = () => {\r\n    this.setState({hasError: false, error: null});\r\n  };\r\n\r\n  render() {\r\n    if (this.state.hasError && this.state.error) {\r\n      const FallbackComponent = this.props.fallback || ErrorFallback;\r\n      return (\r\n        <FallbackComponent\r\n          error={this.state.error}\r\n          resetError={this.resetError}\r\n        />\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n","size_bytes":2107},"src/components/GlobalErrorBoundary.tsx":{"content":"import React from 'react';\r\nimport {\r\n  View,\r\n  Text,\r\n  TouchableOpacity,\r\n  ScrollView,\r\n  Alert,\r\n  Dimensions,\r\n  Clipboard,\r\n} from 'react-native';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport Ionicons from '@expo/vector-icons/Ionicons';\r\nimport * as Application from 'expo-application';\r\nimport * as Updates from 'expo-updates';\r\nimport Constants from 'expo-constants';\r\n// Lazy-load Crashlytics to avoid requiring Firebase when not configured\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst getCrashlytics = (): any | null => {\r\n  try {\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    return require('@react-native-firebase/crashlytics').default;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\ninterface GlobalErrorBoundaryProps {\r\n  children: React.ReactNode;\r\n}\r\n\r\ninterface GlobalErrorBoundaryState {\r\n  hasError: boolean;\r\n  error: Error | null;\r\n  errorInfo: React.ErrorInfo | null;\r\n  showDetails: boolean;\r\n}\r\n\r\nexport default class GlobalErrorBoundary extends React.Component<\r\n  GlobalErrorBoundaryProps,\r\n  GlobalErrorBoundaryState\r\n> {\r\n  constructor(props: GlobalErrorBoundaryProps) {\r\n    super(props);\r\n    this.state = {\r\n      hasError: false,\r\n      error: null,\r\n      errorInfo: null,\r\n      showDetails: false,\r\n    };\r\n  }\r\n\r\n  static getDerivedStateFromError(\r\n    error: Error,\r\n  ): Partial<GlobalErrorBoundaryState> {\r\n    return {\r\n      hasError: true,\r\n      error,\r\n    };\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\r\n    console.error(' Global Error Boundary caught an error:', error);\r\n    console.error('Error Info:', errorInfo);\r\n\r\n    this.setState({\r\n      errorInfo,\r\n    });\r\n\r\n    // Log error details for debugging\r\n    this.logErrorDetails(error, errorInfo);\r\n\r\n    // Report to Crashlytics\r\n    try {\r\n      const hasFirebase = Boolean(Constants?.expoConfig?.extra?.hasFirebase);\r\n      if (hasFirebase) {\r\n        const crashlytics = getCrashlytics();\r\n        crashlytics &&\r\n          crashlytics().setAttributes({\r\n            app_version: String(Application.nativeApplicationVersion || ''),\r\n            build_version: String(Application.nativeBuildVersion || ''),\r\n          });\r\n        crashlytics && crashlytics().recordError(error);\r\n      }\r\n    } catch {}\r\n  }\r\n\r\n  logErrorDetails = (error: Error, errorInfo: React.ErrorInfo) => {\r\n    const errorDetails = {\r\n      message: error.message,\r\n      stack: error.stack,\r\n      componentStack: errorInfo.componentStack,\r\n      timestamp: new Date().toISOString(),\r\n      appVersion: Application.nativeApplicationVersion,\r\n      buildVersion: Application.nativeBuildVersion,\r\n    };\r\n\r\n    console.log('📝 Error Details:', JSON.stringify(errorDetails, null, 2));\r\n  };\r\n\r\n  handleRestart = async () => {\r\n    try {\r\n      // Try to reload the app using Expo Updates\r\n      if (Updates.isEnabled) {\r\n        await Updates.reloadAsync();\r\n      } else {\r\n        // Fallback: reset the error boundary state\r\n        this.resetError();\r\n      }\r\n    } catch (reloadError) {\r\n      console.error('Failed to reload app:', reloadError);\r\n      this.resetError();\r\n    }\r\n  };\r\n\r\n  resetError = () => {\r\n    this.setState({\r\n      hasError: false,\r\n      error: null,\r\n      errorInfo: null,\r\n      showDetails: false,\r\n    });\r\n  };\r\n\r\n  showErrorReport = () => {\r\n    const {error, errorInfo} = this.state;\r\n    if (!error) {\r\n      return;\r\n    }\r\n\r\n    const errorReport = `\r\nApp Version: ${Application.nativeApplicationVersion}\r\nBuild: ${Application.nativeBuildVersion}\r\nTime: ${new Date().toLocaleString()}\r\n\r\nError: ${error.message}\r\n\r\nStack Trace:\r\n${error.stack}\r\n\r\nComponent Stack:\r\n${errorInfo?.componentStack || 'Not available'}\r\n    `;\r\n\r\n    Alert.alert(\r\n      'Error Report',\r\n      'Error details have been logged to console. You can copy this information for support.',\r\n      [\r\n        {\r\n          text: 'Copy to Clipboard',\r\n          onPress: () => Clipboard.setString(errorReport),\r\n        },\r\n        {text: 'OK'},\r\n      ],\r\n    );\r\n  };\r\n\r\n  toggleDetails = () => {\r\n    this.setState(prevState => ({\r\n      showDetails: !prevState.showDetails,\r\n    }));\r\n  };\r\n\r\n  render() {\r\n    if (this.state.hasError && this.state.error) {\r\n      return (\r\n        <ErrorFallbackUI\r\n          error={this.state.error}\r\n          errorInfo={this.state.errorInfo}\r\n          showDetails={this.state.showDetails}\r\n          onRestart={this.handleRestart}\r\n          onReset={this.resetError}\r\n          onToggleDetails={this.toggleDetails}\r\n          onShowReport={this.showErrorReport}\r\n        />\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\ninterface ErrorFallbackUIProps {\r\n  error: Error;\r\n  errorInfo: React.ErrorInfo | null;\r\n  showDetails: boolean;\r\n  onRestart: () => void;\r\n  onReset: () => void;\r\n  onToggleDetails: () => void;\r\n  onShowReport: () => void;\r\n}\r\n\r\nconst ErrorFallbackUI: React.FC<ErrorFallbackUIProps> = ({\r\n  error,\r\n  errorInfo,\r\n  showDetails,\r\n  onRestart,\r\n  onReset,\r\n  onToggleDetails,\r\n  onShowReport,\r\n}) => {\r\n  const {primary} = useThemeStore();\r\n  const {width} = Dimensions.get('window');\r\n  const isTablet = width > 768;\r\n\r\n  return (\r\n    <View className=\"flex-1 bg-black\">\r\n      <ScrollView\r\n        className=\"flex-1\"\r\n        contentContainerStyle={{\r\n          padding: isTablet ? 32 : 16,\r\n          minHeight: '100%',\r\n          justifyContent: 'center',\r\n        }}>\r\n        <View className=\"items-center mb-8\">\r\n          <View\r\n            className=\"w-20 h-20 rounded-full items-center justify-center mb-4\"\r\n            style={{backgroundColor: `${primary}20`}}>\r\n            <Ionicons name=\"warning\" size={40} color=\"#ef4444\" />\r\n          </View>\r\n\r\n          <Text className=\"text-white text-2xl font-bold text-center mb-2\">\r\n            Oops! Something went wrong\r\n          </Text>\r\n\r\n          <Text className=\"text-gray-400 text-base text-center leading-6\">\r\n            The app encountered an unexpected error and needs to restart.\r\n          </Text>\r\n        </View>\r\n\r\n        <View className=\"bg-gray-900 rounded-lg p-4 mb-6\">\r\n          <Text className=\"text-red-400 text-sm font-medium mb-2\">\r\n            Error Details:\r\n          </Text>\r\n          <Text className=\"text-gray-300 text-sm\">\r\n            {error.message || 'Unknown error occurred'}\r\n          </Text>\r\n        </View>\r\n\r\n        {showDetails && (\r\n          <View className=\"bg-gray-900 rounded-lg p-4 mb-6\">\r\n            <Text className=\"text-orange-400 text-sm font-medium mb-2\">\r\n              Technical Details:\r\n            </Text>\r\n            <ScrollView className=\"max-h-32\">\r\n              <Text className=\"text-gray-400 text-xs font-mono\">\r\n                {error.stack}\r\n              </Text>\r\n              {errorInfo?.componentStack && (\r\n                <Text className=\"text-gray-500 text-xs font-mono mt-2\">\r\n                  Component Stack:{'\\n'}\r\n                  {errorInfo.componentStack}\r\n                </Text>\r\n              )}\r\n            </ScrollView>\r\n          </View>\r\n        )}\r\n\r\n        <View className=\"space-y-3\">\r\n          <TouchableOpacity\r\n            onPress={onRestart}\r\n            className=\"bg-red-600 rounded-lg py-4 px-6 items-center\"\r\n            activeOpacity={0.8}>\r\n            <View className=\"flex-row items-center\">\r\n              <Ionicons name=\"refresh\" size={20} color=\"white\" />\r\n              <Text className=\"text-white font-semibold text-base ml-2\">\r\n                Restart App\r\n              </Text>\r\n            </View>\r\n          </TouchableOpacity>\r\n\r\n          <TouchableOpacity\r\n            onPress={onReset}\r\n            className=\"rounded-lg py-4 px-6 items-center border border-gray-600\"\r\n            style={{backgroundColor: `${primary}20`}}\r\n            activeOpacity={0.8}>\r\n            <View className=\"flex-row items-center\">\r\n              <Ionicons name=\"arrow-back\" size={20} color={primary} />\r\n              <Text\r\n                className=\"font-semibold text-base ml-2\"\r\n                style={{color: primary}}>\r\n                Try Again\r\n              </Text>\r\n            </View>\r\n          </TouchableOpacity>\r\n\r\n          <View className=\"flex-row space-x-3\">\r\n            <TouchableOpacity\r\n              onPress={onToggleDetails}\r\n              className=\"flex-1 bg-gray-800 rounded-lg py-3 px-4 items-center\"\r\n              activeOpacity={0.8}>\r\n              <View className=\"flex-row items-center\">\r\n                <Ionicons\r\n                  name={showDetails ? 'eye-off' : 'eye'}\r\n                  size={16}\r\n                  color=\"#9ca3af\"\r\n                />\r\n                <Text className=\"text-gray-400 text-sm ml-2\">\r\n                  {showDetails ? 'Hide' : 'Show'} Details\r\n                </Text>\r\n              </View>\r\n            </TouchableOpacity>\r\n\r\n            <TouchableOpacity\r\n              onPress={onShowReport}\r\n              className=\"flex-1 bg-gray-800 rounded-lg py-3 px-4 items-center\"\r\n              activeOpacity={0.8}>\r\n              <View className=\"flex-row items-center\">\r\n                <Ionicons name=\"bug\" size={16} color=\"#9ca3af\" />\r\n                <Text className=\"text-gray-400 text-sm ml-2\">Report</Text>\r\n              </View>\r\n            </TouchableOpacity>\r\n          </View>\r\n        </View>\r\n\r\n        <View className=\"mt-8 pt-6 border-t border-gray-800\">\r\n          <Text className=\"text-gray-500 text-xs text-center\">\r\n            App Version: {Application.nativeApplicationVersion} (\r\n            {Application.nativeBuildVersion})\r\n          </Text>\r\n          <Text className=\"text-gray-600 text-xs text-center mt-1\">\r\n            If this keeps happening, report on github or discord\r\n          </Text>\r\n        </View>\r\n      </ScrollView>\r\n    </View>\r\n  );\r\n};\r\n","size_bytes":9782},"src/components/Hero.tsx":{"content":"import {Image, MotiView, View} from 'moti';\r\nimport React, {memo, useState, useCallback} from 'react';\r\nimport {\r\n  Keyboard,\r\n  Pressable,\r\n  Text,\r\n  TextInput,\r\n  TouchableOpacity,\r\n} from 'react-native';\r\nimport LinearGradient from 'react-native-linear-gradient';\r\nimport FontAwesome6 from '@expo/vector-icons/FontAwesome';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport {NativeStackNavigationProp} from '@react-navigation/native-stack';\r\nimport {HomeStackParamList, SearchStackParamList} from '../App';\r\nimport useContentStore from '../lib/zustand/contentStore';\r\nimport useHeroStore from '../lib/zustand/herostore';\r\nimport {Skeleton} from 'moti/skeleton';\r\nimport {settingsStorage} from '../lib/storage';\r\nimport {Feather} from '@expo/vector-icons';\r\nimport Ionicons from '@expo/vector-icons/Ionicons';\r\nimport {DrawerLayout} from 'react-native-gesture-handler';\r\nimport {useHeroMetadata} from '../lib/hooks/useHomePageData';\r\n\r\ninterface HeroProps {\r\n  isDrawerOpen: boolean;\r\n  drawerRef: React.RefObject<DrawerLayout>;\r\n}\r\n\r\nconst Hero = memo(({isDrawerOpen, drawerRef}: HeroProps) => {\r\n  const [searchActive, setSearchActive] = useState(false);\r\n  const {provider} = useContentStore(state => state);\r\n  const {hero} = useHeroStore(state => state);\r\n\r\n  // Memoize settings to prevent re-renders\r\n  const [showHamburgerMenu] = useState(() =>\r\n    settingsStorage.showHamburgerMenu(),\r\n  );\r\n  const [isDrawerDisabled] = useState(\r\n    () => settingsStorage.getBool('disableDrawer') || false,\r\n  );\r\n\r\n  const navigation =\r\n    useNavigation<NativeStackNavigationProp<HomeStackParamList>>();\r\n  const searchNavigation =\r\n    useNavigation<NativeStackNavigationProp<SearchStackParamList>>();\r\n\r\n  // Use React Query for hero metadata\r\n  const {\r\n    data: heroData,\r\n    isLoading,\r\n    error,\r\n  } = useHeroMetadata(hero?.link || '', provider.value);\r\n\r\n  // Memoized keyboard handler\r\n  const handleKeyboardHide = useCallback(() => {\r\n    setSearchActive(false);\r\n  }, []);\r\n\r\n  // Set up keyboard listener once\r\n  React.useEffect(() => {\r\n    const subscription = Keyboard.addListener(\r\n      'keyboardDidHide',\r\n      handleKeyboardHide,\r\n    );\r\n    return () => subscription?.remove();\r\n  }, [handleKeyboardHide]);\r\n\r\n  // Memoized handlers\r\n  const handleSearchSubmit = useCallback(\r\n    (text: string) => {\r\n      if (text.startsWith('https://')) {\r\n        navigation.navigate('Info', {link: text});\r\n      } else {\r\n        searchNavigation.navigate('ScrollList', {\r\n          providerValue: provider.value,\r\n          filter: text,\r\n          title: provider.display_name,\r\n          isSearch: true,\r\n        });\r\n      }\r\n    },\r\n    [navigation, searchNavigation, provider.value, provider.display_name],\r\n  );\r\n\r\n  const handlePlayPress = useCallback(() => {\r\n    if (hero?.link) {\r\n      navigation.navigate('Info', {\r\n        link: hero.link,\r\n        provider: provider.value,\r\n        poster: heroData?.image || heroData?.poster || heroData?.background,\r\n      });\r\n    }\r\n  }, [navigation, hero?.link, provider.value, heroData]);\r\n\r\n  const handleImageError = useCallback(() => {\r\n    // Handle image error silently - React Query will manage retries\r\n    console.warn('Hero image failed to load');\r\n  }, []);\r\n\r\n  // Memoized image source\r\n  const imageSource = React.useMemo(() => {\r\n    const fallbackImage =\r\n      'https://placehold.jp/24/363636/ffffff/500x500.png?text=Vega';\r\n    if (!heroData) {\r\n      return {uri: fallbackImage};\r\n    }\r\n\r\n    return {\r\n      uri:\r\n        heroData.background ||\r\n        heroData.image ||\r\n        heroData.poster ||\r\n        fallbackImage,\r\n    };\r\n  }, [heroData]);\r\n\r\n  // Memoized genres\r\n  const displayGenres = React.useMemo(() => {\r\n    if (!heroData) {\r\n      return [];\r\n    }\r\n    return (heroData.genre || heroData.tags || []).slice(0, 3);\r\n  }, [heroData]);\r\n\r\n  if (error) {\r\n    console.error('Hero metadata error:', error);\r\n  }\r\n\r\n  return (\r\n    <View className=\"relative h-[55vh]\">\r\n      {/* Header Controls */}\r\n      <View className=\"absolute pt-3 w-full top-6 px-3 mt-2 z-30 flex-row justify-between items-center\">\r\n        {!searchActive && (\r\n          <View\r\n            className={`${\r\n              showHamburgerMenu && !isDrawerDisabled\r\n                ? 'opacity-100'\r\n                : 'opacity-0'\r\n            }`}>\r\n            <Pressable\r\n              className={`${isDrawerOpen ? 'opacity-0' : 'opacity-100'}`}\r\n              onPress={() => drawerRef.current?.openDrawer()}>\r\n              <Ionicons name=\"menu-sharp\" size={27} color=\"white\" />\r\n            </Pressable>\r\n          </View>\r\n        )}\r\n\r\n        {searchActive && (\r\n          <MotiView\r\n            from={{opacity: 0, scale: 0.5}}\r\n            animate={{opacity: 1, scale: 1}}\r\n            //@ts-ignore\r\n            transition={{type: 'timing', duration: 300}}\r\n            className=\"w-full items-center justify-center\">\r\n            <TextInput\r\n              onBlur={() => setSearchActive(false)}\r\n              autoFocus={true}\r\n              onSubmitEditing={e => handleSearchSubmit(e.nativeEvent.text)}\r\n              placeholder={`Search in ${provider.display_name}`}\r\n              className=\"w-[95%] px-4 h-10 rounded-full border-white border\"\r\n              placeholderTextColor=\"#999\"\r\n            />\r\n          </MotiView>\r\n        )}\r\n\r\n        {!searchActive && (\r\n          <Pressable onPress={() => setSearchActive(true)}>\r\n            <Feather name=\"search\" size={24} color=\"white\" />\r\n          </Pressable>\r\n        )}\r\n      </View>\r\n\r\n      {/* Hero Image */}\r\n      <Skeleton show={isLoading} colorMode=\"dark\">\r\n        <Image\r\n          source={imageSource}\r\n          onError={handleImageError}\r\n          className=\"h-full w-full\"\r\n          style={{resizeMode: 'cover'}}\r\n        />\r\n      </Skeleton>\r\n\r\n      {/* Hero Content */}\r\n      <View className=\"absolute bottom-12 w-full z-20 px-6\">\r\n        {!isLoading && heroData && (\r\n          <View className=\"gap-4 items-center\">\r\n            {/* Title/Logo */}\r\n            {heroData.logo ? (\r\n              <Image\r\n                source={{uri: heroData.logo}}\r\n                style={{\r\n                  width: 200,\r\n                  height: 100,\r\n                  resizeMode: 'contain',\r\n                }}\r\n                onError={() => console.warn('Logo failed to load')}\r\n              />\r\n            ) : (\r\n              <Text className=\"text-white text-center text-2xl font-bold\">\r\n                {heroData.name || heroData.title}\r\n              </Text>\r\n            )}\r\n\r\n            {/* Genres */}\r\n            {displayGenres.length > 0 && (\r\n              <View className=\"flex-row items-center justify-center space-x-2\">\r\n                {displayGenres.map((genre: string, index: number) => (\r\n                  <Text\r\n                    key={index}\r\n                    className=\"text-white text-sm font-semibold\">\r\n                    • {genre}\r\n                  </Text>\r\n                ))}\r\n              </View>\r\n            )}\r\n\r\n            {/* Play Button */}\r\n            <View className=\"flex-1 items-center justify-center\">\r\n              {hero?.link && (\r\n                <TouchableOpacity\r\n                  className=\"bg-white px-10 py-2 rounded-lg flex-row items-center space-x-2\"\r\n                  onPress={handlePlayPress}\r\n                  activeOpacity={0.8}>\r\n                  <FontAwesome6 name=\"play\" size={20} color=\"black\" />\r\n                  <Text className=\"text-black font-bold text-lg\">Play</Text>\r\n                </TouchableOpacity>\r\n              )}\r\n            </View>\r\n          </View>\r\n        )}\r\n\r\n        {/* Loading state */}\r\n        {isLoading && (\r\n          <View className=\"items-center\">\r\n            <Skeleton show={true} height={45} width={140} colorMode=\"dark\" />\r\n          </View>\r\n        )}\r\n\r\n        {/* Error state */}\r\n        {error && !isLoading && (\r\n          <View className=\"items-center\">\r\n            <Text className=\"text-white text-center text-xl font-bold\">\r\n              {hero?.title || 'Content Unavailable'}\r\n            </Text>\r\n            <Text className=\"text-gray-400 text-sm mt-2\">\r\n              Unable to load details\r\n            </Text>\r\n          </View>\r\n        )}\r\n      </View>\r\n\r\n      {/* Gradients */}\r\n      <LinearGradient\r\n        colors={['transparent', 'rgba(0,0,0,0.8)', 'black']}\r\n        locations={[0, 0.7, 1]}\r\n        className=\"absolute h-full w-full\"\r\n      />\r\n\r\n      {searchActive && (\r\n        <LinearGradient\r\n          colors={['black', 'transparent']}\r\n          locations={[0, 0.3]}\r\n          className=\"absolute h-[30%] w-full\"\r\n        />\r\n      )}\r\n    </View>\r\n  );\r\n});\r\n\r\nHero.displayName = 'Hero';\r\n\r\nexport default Hero;\r\n","size_bytes":8739},"src/components/ProviderDrawer.tsx":{"content":"import {View, Text} from 'react-native';\r\nimport React from 'react';\r\nimport useContentStore from '../lib/zustand/contentStore';\r\nimport {ScrollView} from 'moti';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport {TouchableOpacity} from 'react-native';\r\nimport {DrawerLayout} from 'react-native-gesture-handler';\r\nimport {BlurView} from 'expo-blur';\r\nimport {MaterialIcons} from '@expo/vector-icons';\r\n\r\nconst ProviderDrawer = ({\r\n  drawerRef,\r\n}: {\r\n  drawerRef: React.RefObject<DrawerLayout>;\r\n}) => {\r\n  const {provider, setProvider, installedProviders} = useContentStore(\r\n    state => state,\r\n  );\r\n  const {primary} = useThemeStore(state => state);\r\n\r\n  return (\r\n    <BlurView\r\n      intensity={90}\r\n      experimentalBlurMethod=\"dimezisBlurView\"\r\n      blurReductionFactor={5}\r\n      tint=\"dark\"\r\n      className=\"flex-1\">\r\n      <View className=\"mt-8 px-4 pb-4 border-b border-white/10\">\r\n        <Text className=\"text-white text-2xl font-bold\">Select Provider</Text>\r\n        <Text className=\"text-gray-400 mt-1 text-sm\">Content source</Text>\r\n      </View>\r\n\r\n      <ScrollView showsVerticalScrollIndicator={false} className=\"flex-1 px-2\">\r\n        {installedProviders.map(item => (\r\n          <TouchableOpacity\r\n            key={item.value}\r\n            onPress={() => {\r\n              setProvider(item);\r\n              drawerRef.current?.closeDrawer();\r\n            }}\r\n            className={`flex-row items-center justify-between p-4 my-1 rounded-lg ${\r\n              provider.value === item.value ? 'bg-white/10' : 'bg-transparent'\r\n            }`}>\r\n            <View className=\"flex-row items-center\">\r\n              <MaterialIcons\r\n                name=\"movie\"\r\n                size={20}\r\n                color={provider.value === item.value ? primary : '#888'}\r\n              />\r\n              <Text\r\n                className={`ml-3 text-base ${\r\n                  provider.value === item.value\r\n                    ? 'text-white font-medium'\r\n                    : 'text-gray-400'\r\n                }`}>\r\n                {item.display_name}\r\n              </Text>\r\n            </View>\r\n            {provider.value === item.value && (\r\n              <MaterialIcons name=\"check\" size={20} color={primary} />\r\n            )}\r\n          </TouchableOpacity>\r\n        ))}\r\n        <View className=\"h-16\" />\r\n      </ScrollView>\r\n    </BlurView>\r\n  );\r\n};\r\n\r\nexport default ProviderDrawer;\r\n","size_bytes":2419},"src/components/RenderProviderFLagIcon.tsx":{"content":"import {Text} from 'react-native';\r\nimport {SvgUri} from 'react-native-svg';\r\nimport {FLAGS} from '../lib/constants';\r\nimport React from 'react';\r\n\r\nconst RenderProviderFlagIcon = ({type}: {type: string}) => {\r\n  const uri = FLAGS[type.toLocaleUpperCase() as keyof typeof FLAGS] || '';\r\n  return (\r\n    <Text>\r\n      <SvgUri width={28} height={28} uri={uri} />\r\n    </Text>\r\n  );\r\n};\r\n\r\nexport default RenderProviderFlagIcon;\r\n","size_bytes":427},"src/components/SearchSubtitles.tsx":{"content":"import {\r\n  View,\r\n  Text,\r\n  TouchableOpacity,\r\n  Modal,\r\n  TextInput,\r\n  ActivityIndicator,\r\n  ToastAndroid,\r\n} from 'react-native';\r\nimport {SafeAreaView} from 'react-native-safe-area-context';\r\nimport MaterialIcons from '@expo/vector-icons/MaterialIcons';\r\nimport React, {useState} from 'react';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport {ScrollView} from 'react-native';\r\nimport {Dropdown} from 'react-native-element-dropdown';\r\nimport {TextTracks, TextTrackType} from 'react-native-video';\r\n\r\nconst SearchSubtitles = ({\r\n  searchQuery,\r\n  setSearchQuery,\r\n  setExternalSubs,\r\n}: {\r\n  searchQuery: string;\r\n  setSearchQuery: (text: string) => void;\r\n  setExternalSubs: React.Dispatch<React.SetStateAction<TextTracks>>;\r\n}) => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const [searchModalVisible, setSearchModalVisible] = useState(false);\r\n  const [season, setSeason] = useState('');\r\n  const [episode, setEpisode] = useState('');\r\n  const [searchResults, setSearchResults] = useState([]);\r\n  const [error, setError] = useState('');\r\n  const [loading, setLoading] = useState(false);\r\n  const [subId, setSubId] = useState('eng');\r\n\r\n  const subLanguageIds = [\r\n    {name: 'English', id: 'eng'},\r\n    {name: 'Spanish', id: 'spa'},\r\n    {name: 'French', id: 'fre'},\r\n    {name: 'German', id: 'ger'},\r\n    {name: 'Italian', id: 'ita'},\r\n    {name: 'Portuguese', id: 'por'},\r\n    {name: 'Russian', id: 'rus'},\r\n    {name: 'Chinese', id: 'chi'},\r\n    {name: 'Japanese', id: 'jpn'},\r\n    {name: 'Korean', id: 'kor'},\r\n    {name: 'Arabic', id: 'ara'},\r\n    {name: 'Hindi', id: 'hin'},\r\n    {name: 'Dutch', id: 'dut'},\r\n    {name: 'Swedish', id: 'swe'},\r\n    {name: 'Polish', id: 'pol'},\r\n    {name: 'Turkish', id: 'tur'},\r\n    {name: 'Danish', id: 'dan'},\r\n    {name: 'Norwegian', id: 'nor'},\r\n    {name: 'Finnish', id: 'fin'},\r\n    {name: 'Vietnamese', id: 'vie'},\r\n    {name: 'Indonesian', id: 'ind'},\r\n  ];\r\n\r\n  const searchSubtitles = async () => {\r\n    try {\r\n      setLoading(true);\r\n      console.log(\r\n        'openSubtitles',\r\n        `https://rest.opensubtitles.org/search${\r\n          episode ? '/episode-' + episode : ''\r\n        }${\r\n          (searchQuery?.startsWith('tt') ? '/imdbid-' : '/query-') +\r\n          encodeURIComponent(searchQuery.toLocaleLowerCase())\r\n        }${season ? '/season-' + season : ''}${\r\n          subId ? '/sublanguageid-' + subId : ''\r\n        }`,\r\n      );\r\n      const response = await fetch(\r\n        `https://rest.opensubtitles.org/search${\r\n          episode ? '/episode-' + episode : ''\r\n        }${\r\n          (searchQuery?.startsWith('tt') ? '/imdbid-' : '/query-') +\r\n          encodeURIComponent(searchQuery.toLocaleLowerCase())\r\n        }${season ? '/season-' + season : ''}${\r\n          subId ? '/sublanguageid-' + subId : ''\r\n        }`,\r\n        {\r\n          method: 'GET',\r\n          headers: {\r\n            'x-user-agent': 'VLSub 0.10.2',\r\n          },\r\n        },\r\n      );\r\n      console.log('openSubtitles⭐', response);\r\n      const data = await response.json();\r\n      setLoading(false);\r\n      if (data?.length === 0) {\r\n        setError('No Results Found');\r\n        setSearchResults([]);\r\n        return;\r\n      }\r\n      setSearchResults(data);\r\n    } catch (e: any) {\r\n      console.log('openSubtitles err', e);\r\n      setLoading(false);\r\n      setError(e?.message);\r\n      ToastAndroid.show('Error fetching subtitles', ToastAndroid.SHORT);\r\n    }\r\n  };\r\n  return (\r\n    <View>\r\n      <TouchableOpacity\r\n        className=\"flex-row gap-3 items-center rounded-md my-1 overflow-hidden ml-2\"\r\n        onPress={() => setSearchModalVisible(true)}>\r\n        <MaterialIcons name=\"add\" size={20} color=\"white\" />\r\n        <Text className=\"text-base font-semibold text-white\">\r\n          search subtitles online\r\n        </Text>\r\n      </TouchableOpacity>\r\n      <Modal\r\n        animationType=\"slide\"\r\n        transparent={false}\r\n        statusBarTranslucent={true}\r\n        visible={searchModalVisible}\r\n        onRequestClose={() => {\r\n          setSearchModalVisible(!searchModalVisible);\r\n        }}>\r\n        <SafeAreaView className=\"h-full w-full bg-black bg-opacity-80\">\r\n          <View className=\"flex-row justify-start items-center gap-x-4 px-4 py-2\">\r\n            <MaterialIcons\r\n              name=\"arrow-back-ios-new\"\r\n              size={24}\r\n              color=\"white\"\r\n              onPress={() => setSearchModalVisible(false)}\r\n            />\r\n            <Text className=\"text-white text-xl font-semibold\">\r\n              Search Subtitles\r\n            </Text>\r\n          </View>\r\n          <View className=\"flex-row justify-between items-center px-4 py-2\">\r\n            <TextInput\r\n              placeholder=\"Name or IMDB ID\"\r\n              className=\"bg-quaternary w-[60%] rounded-md p-2 text-white\"\r\n              onChangeText={text => setSearchQuery(text)}\r\n              value={searchQuery}\r\n            />\r\n            <View className=\"bg-quaternary w-[10%] h-11 rounded-md p-2\">\r\n              <Dropdown\r\n                selectedTextStyle={{\r\n                  color: 'white',\r\n                  overflow: 'hidden',\r\n                  fontWeight: 'bold',\r\n                }}\r\n                containerStyle={{\r\n                  borderColor: '#363636',\r\n                  width: 115,\r\n                  paddingLeft: 5,\r\n                  borderRadius: 5,\r\n                  overflow: 'hidden',\r\n                  padding: 2,\r\n                  backgroundColor: 'black',\r\n                  maxHeight: 450,\r\n                }}\r\n                labelField={'id'}\r\n                valueField={'id'}\r\n                placeholder=\"Select\"\r\n                value={subId}\r\n                data={subLanguageIds}\r\n                onChange={async item => {\r\n                  setSubId(item.id);\r\n                }}\r\n                renderItem={({name}) => (\r\n                  <Text className={'text-lg p-1 text-white/60 bg-black'}>\r\n                    {name}\r\n                  </Text>\r\n                )}\r\n              />\r\n            </View>\r\n            <TextInput\r\n              placeholder=\"Season\"\r\n              keyboardType=\"numeric\"\r\n              className=\"bg-quaternary text-white w-[10%] rounded-md p-2\"\r\n              onChangeText={text => setSeason(text)}\r\n              value={season}\r\n            />\r\n            <TextInput\r\n              placeholder=\"Episode\"\r\n              keyboardType=\"numeric\"\r\n              className=\"bg-quaternary text-white w-[10%] rounded-md p-2\"\r\n              onChangeText={text => setEpisode(text)}\r\n              value={episode}\r\n            />\r\n            <TouchableOpacity>\r\n              <MaterialIcons\r\n                name=\"search\"\r\n                size={34}\r\n                color={primary}\r\n                onPress={() => searchSubtitles()}\r\n              />\r\n            </TouchableOpacity>\r\n          </View>\r\n          <ScrollView\r\n            className=\" px-7 py-2\"\r\n            contentContainerStyle={{flexGrow: 1}}>\r\n            {loading ? (\r\n              <View className=\"w-full h-full justify-center items-center\">\r\n                <ActivityIndicator size=\"large\" color={primary} />\r\n              </View>\r\n            ) : (\r\n              searchResults.map((result: any) => (\r\n                <TouchableOpacity\r\n                  key={result?.IDSubtitleFile}\r\n                  className=\"flex-row justify- items-center gap-x-4 p-2 my-1 border border-b border-white/10 rounded-md\"\r\n                  onPress={() => {\r\n                    setSearchModalVisible(false);\r\n                    setExternalSubs(prev => [\r\n                      {\r\n                        type: TextTrackType.SUBRIP,\r\n                        language: result?.ISO639,\r\n                        title:\r\n                          result?.InfoReleaseGroup + ' ' + result?.UserNickName,\r\n                        uri: result?.SubDownloadLink?.replace('.gz', ''),\r\n                      },\r\n                      ...prev,\r\n                    ]);\r\n                  }}>\r\n                  <Text className=\"text-white text-lg font-semibold capitalize\">\r\n                    {result?.SubLanguageID}\r\n                  </Text>\r\n                  <Text className=\"text-white text-base\">\r\n                    {result?.MovieName?.trim()}\r\n                  </Text>\r\n                  <Text className=\"text-white text-lg\">\r\n                    {Number(result?.SeriesSeason) > 0\r\n                      ? `S${result?.SeriesSeason}`\r\n                      : ''}\r\n                  </Text>\r\n                  <Text className=\"text-white text-lg\">\r\n                    {Number(result?.SeriesEpisode) > 0\r\n                      ? `E${result?.SeriesEpisode}`\r\n                      : ''}\r\n                  </Text>\r\n                  <Text className=\"text-white text-xs italic\">\r\n                    {result?.InfoReleaseGroup + ' '}\r\n                    {result?.UserNickName}\r\n                  </Text>\r\n                </TouchableOpacity>\r\n              ))\r\n            )}\r\n            {searchResults.length === 0 && !loading && (\r\n              <View className=\"w-full h-full justify-center items-center\">\r\n                <Text className=\"text-red-700 text-lg font-semibold\">\r\n                  {error}\r\n                </Text>\r\n              </View>\r\n            )}\r\n          </ScrollView>\r\n        </SafeAreaView>\r\n      </Modal>\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default SearchSubtitles;\r\n","size_bytes":9427},"src/components/SeasonList.tsx":{"content":"import React, {useState, useMemo, useCallback} from 'react';\r\nimport {\r\n  View,\r\n  Text,\r\n  TouchableOpacity,\r\n  ToastAndroid,\r\n  Modal,\r\n  FlatList,\r\n  ActivityIndicator,\r\n  Pressable,\r\n  ScrollView,\r\n  TextInput,\r\n} from 'react-native';\r\nimport {NativeStackNavigationProp} from '@react-navigation/native-stack';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport Ionicons from '@expo/vector-icons/Ionicons';\r\nimport MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';\r\nimport Feather from '@expo/vector-icons/Feather';\r\nimport {Dropdown} from 'react-native-element-dropdown';\r\nimport {MotiView} from 'moti';\r\nimport {Skeleton} from 'moti/skeleton';\r\nimport * as IntentLauncher from 'expo-intent-launcher';\r\nimport RNReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport {EpisodeLink, Link} from '../lib/providers/types';\r\nimport {RootStackParamList} from '../App';\r\nimport Downloader from './Downloader';\r\nimport {cacheStorage, mainStorage, settingsStorage} from '../lib/storage';\r\nimport {ifExists} from '../lib/file/ifExists';\r\nimport {useEpisodes, useStreamData} from '../lib/hooks/useEpisodes';\r\nimport useWatchHistoryStore from '../lib/zustand/watchHistrory';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\n\r\ninterface SeasonListProps {\r\n  LinkList: Link[];\r\n  poster: {\r\n    logo?: string;\r\n    poster?: string;\r\n    background?: string;\r\n  };\r\n  type: string;\r\n  metaTitle: string;\r\n  providerValue: string;\r\n  refreshing?: boolean;\r\n  routeParams: Readonly<{\r\n    link: string;\r\n    provider?: string;\r\n    poster?: string;\r\n  }>;\r\n}\r\n\r\ninterface PlayHandlerProps {\r\n  linkIndex: number;\r\n  type: string;\r\n  primaryTitle: string;\r\n  secondaryTitle?: string;\r\n  seasonTitle: string;\r\n  episodeData: EpisodeLink[] | Link['directLinks'];\r\n}\r\n\r\ninterface StickyMenuState {\r\n  active: boolean;\r\n  link?: string;\r\n  type?: string;\r\n}\r\n\r\nconst SeasonList: React.FC<SeasonListProps> = ({\r\n  LinkList,\r\n  poster,\r\n  type,\r\n  metaTitle,\r\n  providerValue,\r\n  refreshing: _refreshing,\r\n  routeParams,\r\n}) => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const navigation =\r\n    useNavigation<NativeStackNavigationProp<RootStackParamList>>();\r\n  const {addItem} = useWatchHistoryStore(state => state);\r\n  const {fetchStreams} = useStreamData();\r\n\r\n  // Early return if no LinkList provided\r\n  if (!LinkList || LinkList.length === 0) {\r\n    return (\r\n      <View className=\"p-4\">\r\n        <Text className=\"text-white text-center\">No Streams Available</Text>\r\n      </View>\r\n    );\r\n  }\r\n\r\n  // Memoized initial active season\r\n  const [activeSeason, setActiveSeason] = useState<Link>(() => {\r\n    if (!LinkList || LinkList.length === 0) {\r\n      return {} as Link;\r\n    }\r\n\r\n    const cached = cacheStorage.getString(\r\n      `ActiveSeason${metaTitle + providerValue}`,\r\n    );\r\n\r\n    if (cached) {\r\n      try {\r\n        const parsedSeason = JSON.parse(cached);\r\n        // Verify the cached season still exists in LinkList\r\n        const seasonExists = LinkList.find(\r\n          link => link.title === parsedSeason.title,\r\n        );\r\n        if (seasonExists) {\r\n          return parsedSeason;\r\n        }\r\n      } catch (error) {\r\n        console.warn('Failed to parse cached season:', error);\r\n      }\r\n    }\r\n\r\n    return LinkList[0];\r\n  });\r\n\r\n  // React Query for episodes\r\n  const {\r\n    data: episodeList = [],\r\n    isLoading: episodeLoading,\r\n    error: episodeError,\r\n    refetch: refetchEpisodes,\r\n  } = useEpisodes(\r\n    activeSeason?.episodesLink,\r\n    providerValue,\r\n    activeSeason?.episodesLink ? true : false,\r\n  );\r\n\r\n  // UI state\r\n  const [vlcLoading, setVlcLoading] = useState<boolean>(false);\r\n  const [stickyMenu, setStickyMenu] = useState<StickyMenuState>({\r\n    active: false,\r\n  });\r\n\r\n  // Search and sorting state - memoized initial values\r\n  const [searchText, setSearchText] = useState<string>('');\r\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>(() =>\r\n    mainStorage.getString('episodeSortOrder') === 'desc' ? 'desc' : 'asc',\r\n  );\r\n\r\n  // External player state\r\n  const [showServerModal, setShowServerModal] = useState<boolean>(false);\r\n  const [externalPlayerStreams, setExternalPlayerStreams] = useState<any[]>([]);\r\n  const [isLoadingStreams, setIsLoadingStreams] = useState<boolean>(false);\r\n\r\n  // Memoized filtering and sorting logic for episodes\r\n  const filteredAndSortedEpisodes = useMemo(() => {\r\n    if (!episodeList || !Array.isArray(episodeList)) {\r\n      return [];\r\n    }\r\n\r\n    let episodes = episodeList.filter(\r\n      episode => episode && episode.title && episode.link,\r\n    );\r\n\r\n    // Apply search filter\r\n    if (searchText.trim()) {\r\n      episodes = episodes.filter(\r\n        episode =>\r\n          episode?.title?.toLowerCase().includes(searchText.toLowerCase()),\r\n      );\r\n    }\r\n\r\n    // Apply sorting\r\n    if (sortOrder === 'desc') {\r\n      episodes = [...episodes].reverse();\r\n    }\r\n\r\n    return episodes;\r\n  }, [episodeList, searchText, sortOrder]);\r\n\r\n  // Memoized direct links processing\r\n  const filteredAndSortedDirectLinks = useMemo(() => {\r\n    if (\r\n      !activeSeason?.directLinks ||\r\n      !Array.isArray(activeSeason.directLinks)\r\n    ) {\r\n      return [];\r\n    }\r\n\r\n    let links = activeSeason.directLinks.filter(\r\n      link => link && link.title && link.link,\r\n    );\r\n\r\n    // Apply search filter\r\n    if (searchText.trim()) {\r\n      links = links.filter(\r\n        link => link?.title?.toLowerCase().includes(searchText.toLowerCase()),\r\n      );\r\n    }\r\n\r\n    // Apply sorting\r\n    if (sortOrder === 'desc') {\r\n      links = [...links].reverse();\r\n    }\r\n\r\n    return links;\r\n  }, [activeSeason?.directLinks, searchText, sortOrder]);\r\n\r\n  // Memoized title alignment\r\n  const titleAlignment = useMemo(() => {\r\n    const hasLongTitles =\r\n      filteredAndSortedEpisodes.some(ep => ep?.title && ep.title.length > 27) ||\r\n      filteredAndSortedDirectLinks.some(\r\n        link => link?.title && link.title.length > 27,\r\n      );\r\n\r\n    return hasLongTitles ? 'justify-start' : 'justify-center';\r\n  }, [filteredAndSortedEpisodes, filteredAndSortedDirectLinks]);\r\n\r\n  // Memoized completion checker\r\n  const isCompleted = useCallback((link: string) => {\r\n    const watchProgress = JSON.parse(cacheStorage.getString(link) || '{}');\r\n    const percentage =\r\n      (watchProgress?.position / watchProgress?.duration) * 100;\r\n    return percentage > 85;\r\n  }, []);\r\n\r\n  // Memoized toggle sort order\r\n  const toggleSortOrder = useCallback(() => {\r\n    const newOrder = sortOrder === 'asc' ? 'desc' : 'asc';\r\n    setSortOrder(newOrder);\r\n    mainStorage.setString('episodeSortOrder', newOrder);\r\n  }, [sortOrder]);\r\n\r\n  // Memoized season change handler\r\n  const handleSeasonChange = useCallback(\r\n    (item: Link) => {\r\n      setActiveSeason(item);\r\n      cacheStorage.setString(\r\n        `ActiveSeason${metaTitle + providerValue}`,\r\n        JSON.stringify(item),\r\n      );\r\n    },\r\n    [metaTitle, providerValue],\r\n  );\r\n\r\n  // Memoized external player handler\r\n  const handleExternalPlayer = useCallback(\r\n    async (link: string, type: string) => {\r\n      setVlcLoading(true);\r\n      setIsLoadingStreams(true);\r\n\r\n      try {\r\n        const streams = await fetchStreams(link, type, providerValue);\r\n\r\n        if (!streams || streams.length === 0) {\r\n          ToastAndroid.show('No stream available', ToastAndroid.SHORT);\r\n          return;\r\n        }\r\n\r\n        console.log('Available Streams Count:', streams.length);\r\n        setExternalPlayerStreams([...streams]);\r\n        setIsLoadingStreams(false);\r\n        setVlcLoading(false);\r\n        setShowServerModal(true);\r\n\r\n        ToastAndroid.show(\r\n          `Found ${streams.length} servers`,\r\n          ToastAndroid.SHORT,\r\n        );\r\n      } catch (error) {\r\n        console.error('Error fetching streams:', error);\r\n        ToastAndroid.show('Failed to load streams', ToastAndroid.SHORT);\r\n      } finally {\r\n        setVlcLoading(false);\r\n        setIsLoadingStreams(false);\r\n      }\r\n    },\r\n    [fetchStreams, providerValue],\r\n  );\r\n\r\n  // Memoized external player opener\r\n  const openExternalPlayer = useCallback(async (streamUrl: string) => {\r\n    setShowServerModal(false);\r\n    setVlcLoading(true);\r\n\r\n    try {\r\n      await IntentLauncher.startActivityAsync('android.intent.action.VIEW', {\r\n        data: streamUrl,\r\n        type: 'video/*',\r\n      });\r\n    } catch (error) {\r\n      console.error('Error opening external player:', error);\r\n      ToastAndroid.show('Failed to open external player', ToastAndroid.SHORT);\r\n    } finally {\r\n      setVlcLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // Memoized play handler\r\n  const playHandler = useCallback(\r\n    async ({\r\n      linkIndex,\r\n      type,\r\n      primaryTitle,\r\n      secondaryTitle,\r\n      seasonTitle,\r\n      episodeData,\r\n    }: PlayHandlerProps) => {\r\n      addItem({\r\n        id: routeParams.link,\r\n        link: routeParams.link,\r\n        title: primaryTitle,\r\n        poster: poster?.poster,\r\n        provider: providerValue,\r\n        lastPlayed: Date.now(),\r\n        episodeTitle: secondaryTitle,\r\n        playbackRate: 1,\r\n        currentTime: 0,\r\n        duration: 1,\r\n      });\r\n\r\n      if (!episodeData || episodeData.length === 0) {\r\n        return;\r\n      }\r\n\r\n      const link = episodeData[linkIndex].link;\r\n      const file = (\r\n        metaTitle +\r\n        seasonTitle +\r\n        episodeData[linkIndex]?.title\r\n      ).replaceAll(/[^a-zA-Z0-9]/g, '_');\r\n\r\n      const externalPlayer = settingsStorage.getBool('useExternalPlayer');\r\n      const dwFile = await ifExists(file);\r\n\r\n      if (externalPlayer) {\r\n        if (dwFile) {\r\n          await IntentLauncher.startActivityAsync(\r\n            'android.intent.action.VIEW',\r\n            {\r\n              data: dwFile,\r\n              type: 'video/*',\r\n            },\r\n          );\r\n          return;\r\n        }\r\n        handleExternalPlayer(link, type);\r\n        return;\r\n      }\r\n\r\n      navigation.navigate('Player', {\r\n        linkIndex,\r\n        episodeList: episodeData,\r\n        type: type,\r\n        primaryTitle: primaryTitle,\r\n        secondaryTitle: seasonTitle,\r\n        poster: poster,\r\n        providerValue: providerValue,\r\n        infoUrl: routeParams.link,\r\n      });\r\n    },\r\n    [\r\n      addItem,\r\n      routeParams.link,\r\n      poster,\r\n      providerValue,\r\n      metaTitle,\r\n      handleExternalPlayer,\r\n      navigation,\r\n    ],\r\n  );\r\n\r\n  // Memoized long press handler\r\n  const onLongPressHandler = useCallback(\r\n    (active: boolean, link: string, type?: string) => {\r\n      if (settingsStorage.isHapticFeedbackEnabled()) {\r\n        RNReactNativeHapticFeedback.trigger('effectTick', {\r\n          enableVibrateFallback: true,\r\n          ignoreAndroidSystemSettings: false,\r\n        });\r\n      }\r\n      setStickyMenu({active: active, link: link, type: type});\r\n    },\r\n    [],\r\n  );\r\n\r\n  // Memoized mark as watched handler\r\n  const markAsWatched = useCallback(() => {\r\n    if (stickyMenu.link) {\r\n      cacheStorage.setString(\r\n        stickyMenu.link,\r\n        JSON.stringify({\r\n          position: 10000,\r\n          duration: 1,\r\n        }),\r\n      );\r\n      setStickyMenu({active: false});\r\n    }\r\n  }, [stickyMenu.link]);\r\n\r\n  // Memoized mark as unwatched handler\r\n  const markAsUnwatched = useCallback(() => {\r\n    if (stickyMenu.link) {\r\n      cacheStorage.setString(\r\n        stickyMenu.link,\r\n        JSON.stringify({\r\n          position: 0,\r\n          duration: 1,\r\n        }),\r\n      );\r\n      setStickyMenu({active: false});\r\n    }\r\n  }, [stickyMenu.link]);\r\n\r\n  // Memoized sticky menu external player handler\r\n  const handleStickyMenuExternalPlayer = useCallback(() => {\r\n    setStickyMenu({active: false});\r\n    if (stickyMenu.link && stickyMenu.type) {\r\n      handleExternalPlayer(stickyMenu.link, stickyMenu.type);\r\n    }\r\n  }, [stickyMenu.link, stickyMenu.type, handleExternalPlayer]);\r\n\r\n  // Memoized episode render item\r\n  const renderEpisodeItem = useCallback(\r\n    ({item, index}: {item: EpisodeLink; index: number}) => {\r\n      if (!item || !item.link || !item.title) {\r\n        console.warn('Invalid episode item at index', index, item);\r\n        return null; // Skip rendering if item is invalid\r\n      }\r\n\r\n      return (\r\n        <View\r\n          key={item.link + index}\r\n          className={`w-full justify-center items-center gap-2 flex-row my-1\r\n          ${\r\n            isCompleted(item.link) || stickyMenu.link === item.link\r\n              ? 'opacity-60'\r\n              : ''\r\n          }\r\n        `}>\r\n          <View className=\"flex-row w-full justify-between gap-2 items-center\">\r\n            <TouchableOpacity\r\n              className={`rounded-md bg-white/30 w-[80%] h-12 items-center p-1 flex-row gap-x-2 relative ${titleAlignment}`}\r\n              onPress={() =>\r\n                playHandler({\r\n                  linkIndex: index,\r\n                  type: type,\r\n                  primaryTitle: metaTitle,\r\n                  secondaryTitle: item.title,\r\n                  seasonTitle: activeSeason?.title || '',\r\n                  episodeData: filteredAndSortedEpisodes,\r\n                })\r\n              }\r\n              onLongPress={() => onLongPressHandler(true, item.link, 'series')}>\r\n              <Ionicons name=\"play-circle\" size={28} color={primary} />\r\n              <Text className=\"text-white\">\r\n                {item.title.length > 30\r\n                  ? item.title.slice(0, 30) + '...'\r\n                  : item.title}\r\n              </Text>\r\n            </TouchableOpacity>\r\n            <Downloader\r\n              providerValue={providerValue}\r\n              link={item.link}\r\n              type={type}\r\n              title={\r\n                metaTitle.length > 30\r\n                  ? metaTitle.slice(0, 30) + '... ' + item.title\r\n                  : metaTitle + ' ' + item.title\r\n              }\r\n              fileName={(\r\n                metaTitle +\r\n                activeSeason.title +\r\n                item.title\r\n              ).replaceAll(/[^a-zA-Z0-9]/g, '_')}\r\n            />\r\n          </View>\r\n        </View>\r\n      );\r\n    },\r\n    [\r\n      isCompleted,\r\n      stickyMenu.link,\r\n      titleAlignment,\r\n      playHandler,\r\n      metaTitle,\r\n      activeSeason?.title,\r\n      filteredAndSortedEpisodes,\r\n      onLongPressHandler,\r\n      primary,\r\n      providerValue,\r\n    ],\r\n  );\r\n\r\n  // Memoized direct link render item\r\n  const renderDirectLinkItem = useCallback(\r\n    ({item, index}: {item: any; index: number}) => {\r\n      if (!item || !item.link || !item.title) {\r\n        console.warn('Invalid direct link item at index', index, item);\r\n        return null; // Skip rendering if item is invalid\r\n      }\r\n\r\n      return (\r\n        <View\r\n          key={item.link + index}\r\n          className={`w-full justify-center items-center my-2 gap-2 flex-row\r\n          ${\r\n            isCompleted(item.link) || stickyMenu.link === item.link\r\n              ? 'opacity-60'\r\n              : ''\r\n          }\r\n        `}>\r\n          <View className=\"flex-row w-full justify-between gap-2 items-center\">\r\n            <TouchableOpacity\r\n              className={`rounded-md bg-white/30 w-[80%] h-12 items-center p-2 flex-row gap-x-2 relative ${titleAlignment}`}\r\n              onPress={() =>\r\n                playHandler({\r\n                  linkIndex: index,\r\n                  type: type,\r\n                  primaryTitle: metaTitle,\r\n                  secondaryTitle: item.title,\r\n                  seasonTitle: activeSeason?.title || '',\r\n                  episodeData: filteredAndSortedDirectLinks,\r\n                })\r\n              }\r\n              onLongPress={() =>\r\n                onLongPressHandler(true, item.link, item?.type || 'series')\r\n              }>\r\n              <Ionicons name=\"play-circle\" size={28} color={primary} />\r\n              <Text className=\"text-white\">\r\n                {activeSeason?.directLinks?.length &&\r\n                activeSeason?.directLinks?.length > 1\r\n                  ? item.title?.length > 27\r\n                    ? item.title.slice(0, 27) + '...'\r\n                    : item.title\r\n                  : 'Play'}\r\n              </Text>\r\n            </TouchableOpacity>\r\n            <Downloader\r\n              providerValue={providerValue}\r\n              link={item.link}\r\n              type={type}\r\n              title={\r\n                metaTitle.length > 30\r\n                  ? metaTitle.slice(0, 30) + '... ' + item.title\r\n                  : metaTitle + ' ' + item.title\r\n              }\r\n              fileName={(\r\n                metaTitle +\r\n                activeSeason.title +\r\n                item.title\r\n              ).replaceAll(/[^a-zA-Z0-9]/g, '_')}\r\n            />\r\n          </View>\r\n        </View>\r\n      );\r\n    },\r\n    [\r\n      isCompleted,\r\n      stickyMenu.link,\r\n      titleAlignment,\r\n      playHandler,\r\n      metaTitle,\r\n      activeSeason?.title,\r\n      activeSeason?.directLinks,\r\n      filteredAndSortedDirectLinks,\r\n      onLongPressHandler,\r\n      primary,\r\n      providerValue,\r\n    ],\r\n  );\r\n\r\n  // Memoized server render item\r\n  const renderServerItem = useCallback(\r\n    (item: any, index: number) => (\r\n      <TouchableOpacity\r\n        key={`server-${index}-${item.server}`}\r\n        className=\"bg-black/30 p-3 rounded-lg mb-2 flex-row justify-between items-center\"\r\n        style={{borderColor: primary, borderWidth: 1}}\r\n        onPress={() => openExternalPlayer(item.link)}>\r\n        <View>\r\n          <Text className=\"text-white text-lg capitalize font-bold\">\r\n            {item.server || `Server ${index + 1}`}\r\n          </Text>\r\n          <Text className=\"text-white text-xs opacity-80\">\r\n            {item.type ? `Format: ${item.type.toUpperCase()}` : ''}\r\n          </Text>\r\n        </View>\r\n        <MaterialCommunityIcons name=\"vlc\" size={24} color={primary} />\r\n      </TouchableOpacity>\r\n    ),\r\n    [primary, openExternalPlayer],\r\n  );\r\n\r\n  // Show loading skeleton while episodes are loading\r\n  if (episodeLoading) {\r\n    return (\r\n      <View>\r\n        {LinkList.length > 1 && (\r\n          <Dropdown\r\n            selectedTextStyle={{\r\n              color: primary,\r\n              overflow: 'hidden',\r\n              height: 20,\r\n              fontWeight: 'bold',\r\n            }}\r\n            labelField={'title'}\r\n            valueField={\r\n              LinkList[0]?.episodesLink ? 'episodesLink' : 'directLinks'\r\n            }\r\n            onChange={handleSeasonChange}\r\n            value={activeSeason}\r\n            data={LinkList}\r\n            style={{\r\n              overflow: 'hidden',\r\n              borderWidth: 1,\r\n              borderColor: '#2f302f',\r\n              paddingHorizontal: 12,\r\n              borderRadius: 8,\r\n              backgroundColor: 'black',\r\n            }}\r\n            containerStyle={{\r\n              overflow: 'hidden',\r\n              borderWidth: 1,\r\n              borderColor: 'gray',\r\n              borderRadius: 8,\r\n              backgroundColor: 'black',\r\n            }}\r\n            renderItem={item => (\r\n              <View\r\n                className={`px-3 py-2 bg-black text-white flex-row justify-start items-center border-b border-gray-500 text-center ${\r\n                  activeSeason === item ? 'bg-quaternary' : ''\r\n                }`}>\r\n                <Text className=\"text-white\">{item?.title || 'Unknown'}</Text>\r\n              </View>\r\n            )}\r\n          />\r\n        )}\r\n\r\n        <MotiView\r\n          animate={{backgroundColor: '#0000'}}\r\n          delay={0}\r\n          //@ts-ignore\r\n          transition={{\r\n            type: 'timing',\r\n          }}\r\n          style={{\r\n            width: '100%',\r\n            padding: 10,\r\n            alignItems: 'flex-start',\r\n            gap: 20,\r\n          }}>\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n        </MotiView>\r\n      </View>\r\n    );\r\n  }\r\n\r\n  // Show error state\r\n  if (episodeError) {\r\n    return (\r\n      <View className=\"p-4\">\r\n        <Text className=\"text-red-500 text-center\">\r\n          Failed to load episodes. Please try again.\r\n        </Text>\r\n        <TouchableOpacity\r\n          className=\"mt-2 bg-red-600 p-2 rounded-md\"\r\n          onPress={() => refetchEpisodes()}>\r\n          <Text className=\"text-white text-center\">Retry</Text>\r\n        </TouchableOpacity>\r\n      </View>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <View>\r\n      {/* Season Selector */}\r\n      {LinkList.length > 1 ? (\r\n        <Dropdown\r\n          selectedTextStyle={{\r\n            color: primary,\r\n            overflow: 'hidden',\r\n            height: 20,\r\n            fontWeight: 'bold',\r\n          }}\r\n          labelField={'title'}\r\n          valueField={\r\n            LinkList[0]?.episodesLink ? 'episodesLink' : 'directLinks'\r\n          }\r\n          onChange={handleSeasonChange}\r\n          value={activeSeason}\r\n          data={LinkList}\r\n          style={{\r\n            overflow: 'hidden',\r\n            borderWidth: 1,\r\n            borderColor: '#2f302f',\r\n            paddingHorizontal: 12,\r\n            borderRadius: 8,\r\n            backgroundColor: 'black',\r\n          }}\r\n          containerStyle={{\r\n            overflow: 'hidden',\r\n            borderWidth: 1,\r\n            borderColor: 'gray',\r\n            borderRadius: 8,\r\n            backgroundColor: 'black',\r\n          }}\r\n          renderItem={item => (\r\n            <View\r\n              className={`px-3 py-2 bg-black text-white flex-row justify-start items-center border-b border-gray-500 text-center ${\r\n                activeSeason === item ? 'bg-quaternary' : ''\r\n              }`}>\r\n              <Text className=\"text-white\">{item?.title || 'Unknown'}</Text>\r\n            </View>\r\n          )}\r\n        />\r\n      ) : (\r\n        <Text className=\"text-red-600 text-lg font-semibold px-2\">\r\n          {LinkList[0]?.title || 'Unknown Season'}\r\n        </Text>\r\n      )}\r\n\r\n      {/* Search and Sort Controls */}\r\n      {(filteredAndSortedEpisodes.length > 8 ||\r\n        filteredAndSortedDirectLinks.length > 8) && (\r\n        <View className=\"flex-row justify-between items-center mt-2\">\r\n          <TextInput\r\n            placeholder=\"Search...\"\r\n            className=\"bg-black/30 text-white rounded-md p-2 h-10 w-[80%] border-collapse border border-white/10\"\r\n            value={searchText}\r\n            onChangeText={setSearchText}\r\n          />\r\n          <TouchableOpacity\r\n            className=\"bg-black/30 rounded-md p-2 h-10 w-[15%] flex-row justify-center items-center\"\r\n            onPress={toggleSortOrder}>\r\n            <MaterialCommunityIcons\r\n              name={sortOrder === 'asc' ? 'sort-ascending' : 'sort-descending'}\r\n              size={24}\r\n              color={primary}\r\n            />\r\n          </TouchableOpacity>\r\n        </View>\r\n      )}\r\n\r\n      {/* Episode/Direct Links List */}\r\n      <View className=\"flex-row flex-wrap justify-center gap-x-2 gap-y-2\">\r\n        {/* Episodes List */}\r\n        {filteredAndSortedEpisodes.length > 0 && (\r\n          <FlatList\r\n            data={filteredAndSortedEpisodes}\r\n            keyExtractor={(item, index) => `episode-${item.link}-${index}`}\r\n            renderItem={renderEpisodeItem}\r\n            maxToRenderPerBatch={10}\r\n            windowSize={10}\r\n            removeClippedSubviews={true}\r\n            getItemLayout={(data, index) => ({\r\n              length: 60,\r\n              offset: 60 * index,\r\n              index,\r\n            })}\r\n          />\r\n        )}\r\n\r\n        {/* Direct Links List */}\r\n        {filteredAndSortedDirectLinks.length > 0 && (\r\n          <View className=\"w-full justify-center items-center gap-y-2 mt-3 p-2\">\r\n            <FlatList\r\n              data={filteredAndSortedDirectLinks}\r\n              keyExtractor={(item, index) => `direct-${item.link}-${index}`}\r\n              renderItem={renderDirectLinkItem}\r\n              maxToRenderPerBatch={10}\r\n              windowSize={10}\r\n              removeClippedSubviews={true}\r\n              getItemLayout={(data, index) => ({\r\n                length: 68,\r\n                offset: 68 * index,\r\n                index,\r\n              })}\r\n            />\r\n          </View>\r\n        )}\r\n\r\n        {/* No Content Available */}\r\n        {filteredAndSortedEpisodes.length === 0 &&\r\n          filteredAndSortedDirectLinks.length === 0 &&\r\n          LinkList?.length === 0 && (\r\n            <Text className=\"text-white text-lg font-semibold min-h-20\">\r\n              No stream found\r\n            </Text>\r\n          )}\r\n      </View>\r\n\r\n      {/* VLC Loading Indicator */}\r\n      {vlcLoading && (\r\n        <View className=\"absolute top-0 left-0 w-full h-full bg-black/60 bg-opacity-50 justify-center items-center\">\r\n          <MotiView\r\n            from={{rotate: '0deg'}}\r\n            animate={{rotate: '360deg'}}\r\n            //@ts-ignore\r\n            transition={{\r\n              type: 'timing',\r\n              duration: 800,\r\n              loop: true,\r\n              repeatReverse: false,\r\n            }}>\r\n            <MaterialCommunityIcons name=\"vlc\" size={70} color={primary} />\r\n          </MotiView>\r\n          <Text className=\"text-white text-lg font-semibold mt-2\">\r\n            Loading available servers...\r\n          </Text>\r\n        </View>\r\n      )}\r\n\r\n      {/* Server Selection Modal */}\r\n      <Modal\r\n        animationType=\"slide\"\r\n        transparent={true}\r\n        visible={showServerModal}\r\n        onRequestClose={() => setShowServerModal(false)}>\r\n        <Pressable\r\n          onPress={() => setShowServerModal(false)}\r\n          className=\"flex-1 justify-center items-center bg-black/80\">\r\n          <View className=\"bg-tertiary rounded-xl p-4 w-[90%] max-w-[350px]\">\r\n            <Text className=\"text-white text-xl font-bold mb-2 text-center\">\r\n              Select External Player Server\r\n            </Text>\r\n            <Text className=\"text-white text-sm mb-4 text-center opacity-70\">\r\n              {externalPlayerStreams.length} servers available\r\n            </Text>\r\n\r\n            {isLoadingStreams ? (\r\n              <ActivityIndicator size=\"large\" color={primary} />\r\n            ) : (\r\n              <>\r\n                <ScrollView style={{maxHeight: 300}}>\r\n                  {externalPlayerStreams.map((item, index) =>\r\n                    renderServerItem(item, index),\r\n                  )}\r\n                  {externalPlayerStreams.length === 0 && (\r\n                    <Text className=\"text-white text-center p-4\">\r\n                      No servers available\r\n                    </Text>\r\n                  )}\r\n                </ScrollView>\r\n\r\n                <TouchableOpacity\r\n                  className=\"mt-4 bg-black/30 py-2 rounded-md\"\r\n                  onPress={() => setShowServerModal(false)}>\r\n                  <Text className=\"text-white text-center font-bold\">\r\n                    Cancel\r\n                  </Text>\r\n                </TouchableOpacity>\r\n              </>\r\n            )}\r\n          </View>\r\n        </Pressable>\r\n      </Modal>\r\n\r\n      {/* Sticky Menu Modal */}\r\n      <Modal\r\n        animationType=\"fade\"\r\n        visible={stickyMenu.active}\r\n        transparent={true}\r\n        onRequestClose={() => setStickyMenu({active: false})}>\r\n        <Pressable\r\n          className=\"flex-1 justify-end items-center\"\r\n          onPress={() => setStickyMenu({active: false})}>\r\n          <View className=\"w-full h-14 bg-quaternary flex-row justify-evenly items-center pt-2\">\r\n            {isCompleted(stickyMenu.link || '') ? (\r\n              <TouchableOpacity\r\n                className=\"flex-row justify-center items-center gap-2 p-2\"\r\n                onPress={markAsUnwatched}>\r\n                <Text className=\"text-white\">Marked as Unwatched</Text>\r\n                <Ionicons name=\"checkmark-done\" size={30} color={primary} />\r\n              </TouchableOpacity>\r\n            ) : (\r\n              <TouchableOpacity\r\n                className=\"flex-row justify-center items-center gap-2 pt-0 pb-2 px-2 bg-tertiary rounded-md\"\r\n                onPress={markAsWatched}>\r\n                <Text className=\"text-white\">Mark as Watched</Text>\r\n                <Ionicons name=\"checkmark\" size={25} color={primary} />\r\n              </TouchableOpacity>\r\n            )}\r\n            <TouchableOpacity\r\n              className=\"flex-row justify-center bg-tertiary rounded-md items-center pt-0 pb-2 px-2 gap-2\"\r\n              onPress={handleStickyMenuExternalPlayer}>\r\n              <Text className=\"text-white font-bold text-base\">\r\n                External Player\r\n              </Text>\r\n              <Feather name=\"external-link\" size={20} color={primary} />\r\n            </TouchableOpacity>\r\n          </View>\r\n        </Pressable>\r\n      </Modal>\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default SeasonList;\r\n","size_bytes":28986},"src/components/SeasonListNew.tsx":{"content":"import React, {useState, useMemo, useCallback} from 'react';\r\nimport {\r\n  View,\r\n  Text,\r\n  TouchableOpacity,\r\n  ToastAndroid,\r\n  Modal,\r\n  FlatList,\r\n  ActivityIndicator,\r\n  Pressable,\r\n  ScrollView,\r\n  TextInput,\r\n} from 'react-native';\r\nimport {NativeStackNavigationProp} from '@react-navigation/native-stack';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport Ionicons from '@expo/vector-icons/Ionicons';\r\nimport MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';\r\nimport Feather from '@expo/vector-icons/Feather';\r\nimport {Dropdown} from 'react-native-element-dropdown';\r\nimport {MotiView} from 'moti';\r\nimport {Skeleton} from 'moti/skeleton';\r\nimport * as IntentLauncher from 'expo-intent-launcher';\r\nimport RNReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\n\r\nimport {EpisodeLink, Link} from '../lib/providers/types';\r\nimport {RootStackParamList} from '../App';\r\nimport Downloader from './Downloader';\r\nimport {cacheStorage, mainStorage, settingsStorage} from '../lib/storage';\r\nimport {ifExists} from '../lib/file/ifExists';\r\nimport {useEpisodes, useStreamData} from '../lib/hooks/useEpisodes';\r\nimport useWatchHistoryStore from '../lib/zustand/watchHistrory';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\n\r\ninterface SeasonListProps {\r\n  LinkList: Link[];\r\n  poster: {\r\n    logo?: string;\r\n    poster?: string;\r\n    background?: string;\r\n  };\r\n  metaTitle: string;\r\n  providerValue: string;\r\n  refreshing?: boolean;\r\n  routeParams: Readonly<{\r\n    link: string;\r\n    provider?: string;\r\n    poster?: string;\r\n  }>;\r\n}\r\n\r\ninterface PlayHandlerProps {\r\n  linkIndex: number;\r\n  type: string;\r\n  primaryTitle: string;\r\n  secondaryTitle?: string;\r\n  seasonTitle: string;\r\n  episodeData: EpisodeLink[] | Link['directLinks'];\r\n}\r\n\r\ninterface StickyMenuState {\r\n  active: boolean;\r\n  link?: string;\r\n  type?: string;\r\n}\r\n\r\nconst SeasonList: React.FC<SeasonListProps> = ({\r\n  LinkList,\r\n  poster,\r\n  metaTitle,\r\n  providerValue,\r\n  refreshing: _refreshing,\r\n  routeParams,\r\n}) => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const navigation =\r\n    useNavigation<NativeStackNavigationProp<RootStackParamList>>();\r\n  const {addItem} = useWatchHistoryStore(state => state);\r\n  const {fetchStreams} = useStreamData();\r\n\r\n  // Memoized initial active season\r\n  const [activeSeason, setActiveSeason] = useState<Link>(() => {\r\n    const cached = cacheStorage.getString(\r\n      `ActiveSeason${metaTitle + providerValue}`,\r\n    );\r\n    return cached ? JSON.parse(cached) : LinkList[0];\r\n  });\r\n\r\n  // React Query for episodes\r\n  const {\r\n    data: episodeList = [],\r\n    isLoading: episodeLoading,\r\n    error: episodeError,\r\n    refetch: refetchEpisodes,\r\n  } = useEpisodes(\r\n    activeSeason?.episodesLink,\r\n    providerValue,\r\n    !!activeSeason?.episodesLink,\r\n  );\r\n\r\n  // UI state\r\n  const [vlcLoading, setVlcLoading] = useState<boolean>(false);\r\n  const [stickyMenu, setStickyMenu] = useState<StickyMenuState>({\r\n    active: false,\r\n  });\r\n\r\n  // Search and sorting state - memoized initial values\r\n  const [searchText, setSearchText] = useState<string>('');\r\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>(() =>\r\n    mainStorage.getString('episodeSortOrder') === 'desc' ? 'desc' : 'asc',\r\n  );\r\n\r\n  // External player state\r\n  const [showServerModal, setShowServerModal] = useState<boolean>(false);\r\n  const [externalPlayerStreams, setExternalPlayerStreams] = useState<any[]>([]);\r\n  const [isLoadingStreams, setIsLoadingStreams] = useState<boolean>(false);\r\n\r\n  // Memoized filtering and sorting logic for episodes\r\n  const filteredAndSortedEpisodes = useMemo(() => {\r\n    let episodes = episodeList;\r\n\r\n    // Apply search filter\r\n    if (searchText.trim()) {\r\n      episodes = episodes.filter(episode =>\r\n        episode.title.toLowerCase().includes(searchText.toLowerCase()),\r\n      );\r\n    }\r\n\r\n    // Apply sorting\r\n    if (sortOrder === 'desc') {\r\n      episodes = [...episodes].reverse();\r\n    }\r\n\r\n    return episodes;\r\n  }, [episodeList, searchText, sortOrder]);\r\n\r\n  // Memoized direct links processing\r\n  const filteredAndSortedDirectLinks = useMemo(() => {\r\n    if (!activeSeason?.directLinks) {\r\n      return [];\r\n    }\r\n\r\n    let links = activeSeason.directLinks;\r\n\r\n    // Apply search filter\r\n    if (searchText.trim()) {\r\n      links = links.filter(link =>\r\n        link.title.toLowerCase().includes(searchText.toLowerCase()),\r\n      );\r\n    }\r\n\r\n    // Apply sorting\r\n    if (sortOrder === 'desc') {\r\n      links = [...links].reverse();\r\n    }\r\n\r\n    return links;\r\n  }, [activeSeason?.directLinks, searchText, sortOrder]);\r\n\r\n  // Memoized title alignment\r\n  const titleAlignment = useMemo(() => {\r\n    const hasLongTitles =\r\n      filteredAndSortedEpisodes.some(ep => ep.title.length > 27) ||\r\n      filteredAndSortedDirectLinks.some(link => link.title.length > 27);\r\n\r\n    return hasLongTitles ? 'justify-start' : 'justify-center';\r\n  }, [filteredAndSortedEpisodes, filteredAndSortedDirectLinks]);\r\n\r\n  // Memoized completion checker\r\n  const isCompleted = useCallback((link: string) => {\r\n    const watchProgress = JSON.parse(cacheStorage.getString(link) || '{}');\r\n    const percentage =\r\n      (watchProgress?.position / watchProgress?.duration) * 100;\r\n    return percentage > 85;\r\n  }, []);\r\n\r\n  // Memoized toggle sort order\r\n  const toggleSortOrder = useCallback(() => {\r\n    const newOrder = sortOrder === 'asc' ? 'desc' : 'asc';\r\n    setSortOrder(newOrder);\r\n    mainStorage.setString('episodeSortOrder', newOrder);\r\n  }, [sortOrder]);\r\n\r\n  // Memoized season change handler\r\n  const handleSeasonChange = useCallback(\r\n    (item: Link) => {\r\n      setActiveSeason(item);\r\n      cacheStorage.setString(\r\n        `ActiveSeason${metaTitle + providerValue}`,\r\n        JSON.stringify(item),\r\n      );\r\n    },\r\n    [metaTitle, providerValue],\r\n  );\r\n\r\n  // Memoized external player handler\r\n  const handleExternalPlayer = useCallback(\r\n    async (link: string, type: string) => {\r\n      setVlcLoading(true);\r\n      setIsLoadingStreams(true);\r\n\r\n      try {\r\n        const streams = await fetchStreams(link, type, providerValue);\r\n\r\n        if (!streams || streams.length === 0) {\r\n          ToastAndroid.show('No stream available', ToastAndroid.SHORT);\r\n          return;\r\n        }\r\n\r\n        console.log('Available Streams Count:', streams.length);\r\n        setExternalPlayerStreams([...streams]);\r\n        setIsLoadingStreams(false);\r\n        setVlcLoading(false);\r\n        setShowServerModal(true);\r\n\r\n        ToastAndroid.show(\r\n          `Found ${streams.length} servers`,\r\n          ToastAndroid.SHORT,\r\n        );\r\n      } catch (error) {\r\n        console.error('Error fetching streams:', error);\r\n        ToastAndroid.show('Failed to load streams', ToastAndroid.SHORT);\r\n      } finally {\r\n        setVlcLoading(false);\r\n        setIsLoadingStreams(false);\r\n      }\r\n    },\r\n    [fetchStreams, providerValue],\r\n  );\r\n\r\n  // Memoized external player opener\r\n  const openExternalPlayer = useCallback(async (streamUrl: string) => {\r\n    setShowServerModal(false);\r\n    setVlcLoading(true);\r\n\r\n    try {\r\n      await IntentLauncher.startActivityAsync('android.intent.action.VIEW', {\r\n        data: streamUrl,\r\n        type: 'video/*',\r\n      });\r\n    } catch (error) {\r\n      console.error('Error opening external player:', error);\r\n      ToastAndroid.show('Failed to open external player', ToastAndroid.SHORT);\r\n    } finally {\r\n      setVlcLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // Memoized play handler\r\n  const playHandler = useCallback(\r\n    async ({\r\n      linkIndex,\r\n      type,\r\n      primaryTitle,\r\n      secondaryTitle,\r\n      seasonTitle,\r\n      episodeData,\r\n    }: PlayHandlerProps) => {\r\n      addItem({\r\n        id: routeParams.link,\r\n        link: routeParams.link,\r\n        title: primaryTitle,\r\n        poster: poster?.poster,\r\n        provider: providerValue,\r\n        lastPlayed: Date.now(),\r\n        episodeTitle: secondaryTitle,\r\n        playbackRate: 1,\r\n        currentTime: 0,\r\n        duration: 1,\r\n      });\r\n\r\n      if (!episodeData || episodeData.length === 0) {\r\n        return;\r\n      }\r\n\r\n      const link = episodeData[linkIndex].link;\r\n      const file = (\r\n        metaTitle +\r\n        seasonTitle +\r\n        episodeData[linkIndex].title\r\n      ).replaceAll(/[^a-zA-Z0-9]/g, '_');\r\n\r\n      const externalPlayer = settingsStorage.getBool('useExternalPlayer');\r\n      const dwFile = await ifExists(file);\r\n\r\n      if (externalPlayer) {\r\n        if (dwFile) {\r\n          await IntentLauncher.startActivityAsync(\r\n            'android.intent.action.VIEW',\r\n            {\r\n              data: dwFile,\r\n              type: 'video/*',\r\n            },\r\n          );\r\n          return;\r\n        }\r\n        handleExternalPlayer(link, type);\r\n        return;\r\n      }\r\n\r\n      navigation.navigate('Player', {\r\n        linkIndex,\r\n        episodeList: episodeData,\r\n        type: type,\r\n        primaryTitle: primaryTitle,\r\n        secondaryTitle: seasonTitle,\r\n        poster: poster,\r\n        providerValue: providerValue,\r\n        infoUrl: routeParams.link,\r\n      });\r\n    },\r\n    [\r\n      addItem,\r\n      routeParams.link,\r\n      poster,\r\n      providerValue,\r\n      metaTitle,\r\n      handleExternalPlayer,\r\n      navigation,\r\n    ],\r\n  );\r\n\r\n  // Memoized long press handler\r\n  const onLongPressHandler = useCallback(\r\n    (active: boolean, link: string, type?: string) => {\r\n      if (settingsStorage.isHapticFeedbackEnabled()) {\r\n        RNReactNativeHapticFeedback.trigger('effectTick', {\r\n          enableVibrateFallback: true,\r\n          ignoreAndroidSystemSettings: false,\r\n        });\r\n      }\r\n      setStickyMenu({active: active, link: link, type: type});\r\n    },\r\n    [],\r\n  );\r\n\r\n  // Memoized mark as watched handler\r\n  const markAsWatched = useCallback(() => {\r\n    if (stickyMenu.link) {\r\n      cacheStorage.setString(\r\n        stickyMenu.link,\r\n        JSON.stringify({\r\n          position: 10000,\r\n          duration: 1,\r\n        }),\r\n      );\r\n      setStickyMenu({active: false});\r\n    }\r\n  }, [stickyMenu.link]);\r\n\r\n  // Memoized mark as unwatched handler\r\n  const markAsUnwatched = useCallback(() => {\r\n    if (stickyMenu.link) {\r\n      cacheStorage.setString(\r\n        stickyMenu.link,\r\n        JSON.stringify({\r\n          position: 0,\r\n          duration: 1,\r\n        }),\r\n      );\r\n      setStickyMenu({active: false});\r\n    }\r\n  }, [stickyMenu.link]);\r\n\r\n  // Memoized sticky menu external player handler\r\n  const handleStickyMenuExternalPlayer = useCallback(() => {\r\n    setStickyMenu({active: false});\r\n    if (stickyMenu.link && stickyMenu.type) {\r\n      handleExternalPlayer(stickyMenu.link, stickyMenu.type);\r\n    }\r\n  }, [stickyMenu.link, stickyMenu.type, handleExternalPlayer]);\r\n\r\n  // Memoized episode render item\r\n  const renderEpisodeItem = useCallback(\r\n    ({item, index}: {item: EpisodeLink; index: number}) => {\r\n      return (\r\n        <View\r\n          key={item.link + index}\r\n          className={`w-full justify-center items-center gap-2 flex-row my-1\r\n          ${\r\n            isCompleted(item.link) || stickyMenu.link === item.link\r\n              ? 'opacity-60'\r\n              : ''\r\n          }\r\n        `}>\r\n          <View className=\"flex-row w-full justify-between gap-2 items-center\">\r\n            <TouchableOpacity\r\n              className={`rounded-md bg-white/30 w-[80%] h-12 items-center p-1 flex-row gap-x-2 relative ${titleAlignment}`}\r\n              onPress={() =>\r\n                playHandler({\r\n                  linkIndex: index,\r\n                  type: 'series',\r\n                  primaryTitle: metaTitle,\r\n                  secondaryTitle: item.title,\r\n                  seasonTitle: activeSeason.title,\r\n                  episodeData: filteredAndSortedEpisodes,\r\n                })\r\n              }\r\n              onLongPress={() => onLongPressHandler(true, item.link, 'series')}>\r\n              <Ionicons name=\"play-circle\" size={28} color={primary} />\r\n              <Text className=\"text-white\">\r\n                {item.title.length > 30\r\n                  ? item.title.slice(0, 30) + '...'\r\n                  : item.title}\r\n              </Text>\r\n            </TouchableOpacity>\r\n            <Downloader\r\n              providerValue={providerValue}\r\n              link={item.link}\r\n              type=\"series\"\r\n              title={\r\n                metaTitle.length > 30\r\n                  ? metaTitle.slice(0, 30) + '... ' + item.title\r\n                  : metaTitle + ' ' + item.title\r\n              }\r\n              fileName={(\r\n                metaTitle +\r\n                activeSeason.title +\r\n                item.title\r\n              ).replaceAll(/[^a-zA-Z0-9]/g, '_')}\r\n            />\r\n          </View>\r\n        </View>\r\n      );\r\n    },\r\n    [\r\n      isCompleted,\r\n      stickyMenu.link,\r\n      titleAlignment,\r\n      playHandler,\r\n      metaTitle,\r\n      activeSeason.title,\r\n      filteredAndSortedEpisodes,\r\n      onLongPressHandler,\r\n      primary,\r\n      providerValue,\r\n    ],\r\n  );\r\n\r\n  // Memoized direct link render item\r\n  const renderDirectLinkItem = useCallback(\r\n    ({item, index}: {item: any; index: number}) => {\r\n      return (\r\n        <View\r\n          key={item.link + index}\r\n          className={`w-full justify-center items-center my-2 gap-2 flex-row\r\n          ${\r\n            isCompleted(item.link) || stickyMenu.link === item.link\r\n              ? 'opacity-60'\r\n              : ''\r\n          }\r\n        `}>\r\n          <View className=\"flex-row w-full justify-between gap-2 items-center\">\r\n            <TouchableOpacity\r\n              className={`rounded-md bg-white/30 w-[80%] h-12 items-center p-2 flex-row gap-x-2 relative ${titleAlignment}`}\r\n              onPress={() =>\r\n                playHandler({\r\n                  linkIndex: index,\r\n                  type: item.type || 'series',\r\n                  primaryTitle: metaTitle,\r\n                  secondaryTitle: item.title,\r\n                  seasonTitle: activeSeason.title,\r\n                  episodeData: filteredAndSortedDirectLinks,\r\n                })\r\n              }\r\n              onLongPress={() => onLongPressHandler(true, item.link, 'series')}>\r\n              <Ionicons name=\"play-circle\" size={28} color={primary} />\r\n              <Text className=\"text-white\">\r\n                {activeSeason?.directLinks?.length &&\r\n                activeSeason?.directLinks?.length > 1\r\n                  ? item.title?.length > 27\r\n                    ? item.title.slice(0, 27) + '...'\r\n                    : item.title\r\n                  : 'Play'}\r\n              </Text>\r\n            </TouchableOpacity>\r\n            <Downloader\r\n              providerValue={providerValue}\r\n              link={item.link}\r\n              type={item.type || 'series'}\r\n              title={\r\n                metaTitle.length > 30\r\n                  ? metaTitle.slice(0, 30) + '... ' + item.title\r\n                  : metaTitle + ' ' + item.title\r\n              }\r\n              fileName={(\r\n                metaTitle +\r\n                activeSeason.title +\r\n                item.title\r\n              ).replaceAll(/[^a-zA-Z0-9]/g, '_')}\r\n            />\r\n          </View>\r\n        </View>\r\n      );\r\n    },\r\n    [\r\n      isCompleted,\r\n      stickyMenu.link,\r\n      titleAlignment,\r\n      playHandler,\r\n      metaTitle,\r\n      activeSeason.title,\r\n      activeSeason?.directLinks,\r\n      filteredAndSortedDirectLinks,\r\n      onLongPressHandler,\r\n      primary,\r\n      providerValue,\r\n    ],\r\n  );\r\n\r\n  // Memoized server render item\r\n  const renderServerItem = useCallback(\r\n    (item: any, index: number) => (\r\n      <TouchableOpacity\r\n        key={`server-${index}-${item.server}`}\r\n        className=\"bg-black/30 p-3 rounded-lg mb-2 flex-row justify-between items-center\"\r\n        style={{borderColor: primary, borderWidth: 1}}\r\n        onPress={() => openExternalPlayer(item.link)}>\r\n        <View>\r\n          <Text className=\"text-white text-lg capitalize font-bold\">\r\n            {item.server || `Server ${index + 1}`}\r\n          </Text>\r\n          <Text className=\"text-white text-xs opacity-80\">\r\n            {item.type ? `Format: ${item.type.toUpperCase()}` : ''}\r\n          </Text>\r\n        </View>\r\n        <MaterialCommunityIcons name=\"vlc\" size={24} color={primary} />\r\n      </TouchableOpacity>\r\n    ),\r\n    [primary, openExternalPlayer],\r\n  );\r\n\r\n  // Show loading skeleton while episodes are loading\r\n  if (episodeLoading) {\r\n    return (\r\n      <View>\r\n        {LinkList.length > 1 && (\r\n          <Dropdown\r\n            selectedTextStyle={{\r\n              color: primary,\r\n              overflow: 'hidden',\r\n              height: 20,\r\n              fontWeight: 'bold',\r\n            }}\r\n            labelField={'title'}\r\n            valueField={\r\n              LinkList[0]?.episodesLink ? 'episodesLink' : 'directLinks'\r\n            }\r\n            onChange={handleSeasonChange}\r\n            value={activeSeason}\r\n            data={LinkList}\r\n            style={{\r\n              overflow: 'hidden',\r\n              borderWidth: 1,\r\n              borderColor: '#2f302f',\r\n              paddingHorizontal: 12,\r\n              borderRadius: 8,\r\n              backgroundColor: 'black',\r\n            }}\r\n            containerStyle={{\r\n              overflow: 'hidden',\r\n              borderWidth: 1,\r\n              borderColor: 'gray',\r\n              borderRadius: 8,\r\n              backgroundColor: 'black',\r\n            }}\r\n            renderItem={item => (\r\n              <View\r\n                className={`px-3 py-2 bg-black text-white flex-row justify-start items-center border-b border-gray-500 text-center ${\r\n                  activeSeason === item ? 'bg-quaternary' : ''\r\n                }`}>\r\n                <Text className=\"text-white\">{item.title}</Text>\r\n              </View>\r\n            )}\r\n          />\r\n        )}\r\n\r\n        <MotiView\r\n          animate={{backgroundColor: '#0000'}}\r\n          delay={0}\r\n          //@ts-ignore\r\n          transition={{\r\n            type: 'timing',\r\n          }}\r\n          style={{\r\n            width: '100%',\r\n            padding: 10,\r\n            alignItems: 'flex-start',\r\n            gap: 20,\r\n          }}>\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n          <Skeleton colorMode={'dark'} width={'85%'} height={48} />\r\n        </MotiView>\r\n      </View>\r\n    );\r\n  }\r\n\r\n  // Show error state\r\n  if (episodeError) {\r\n    return (\r\n      <View className=\"p-4\">\r\n        <Text className=\"text-red-500 text-center\">\r\n          Failed to load episodes. Please try again.\r\n        </Text>\r\n        <TouchableOpacity\r\n          className=\"mt-2 bg-red-600 p-2 rounded-md\"\r\n          onPress={() => refetchEpisodes()}>\r\n          <Text className=\"text-white text-center\">Retry</Text>\r\n        </TouchableOpacity>\r\n      </View>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <View>\r\n      {/* Season Selector */}\r\n      {LinkList.length > 1 ? (\r\n        <Dropdown\r\n          selectedTextStyle={{\r\n            color: primary,\r\n            overflow: 'hidden',\r\n            height: 20,\r\n            fontWeight: 'bold',\r\n          }}\r\n          labelField={'title'}\r\n          valueField={\r\n            LinkList[0]?.episodesLink ? 'episodesLink' : 'directLinks'\r\n          }\r\n          onChange={handleSeasonChange}\r\n          value={activeSeason}\r\n          data={LinkList}\r\n          style={{\r\n            overflow: 'hidden',\r\n            borderWidth: 1,\r\n            borderColor: '#2f302f',\r\n            paddingHorizontal: 12,\r\n            borderRadius: 8,\r\n            backgroundColor: 'black',\r\n          }}\r\n          containerStyle={{\r\n            overflow: 'hidden',\r\n            borderWidth: 1,\r\n            borderColor: 'gray',\r\n            borderRadius: 8,\r\n            backgroundColor: 'black',\r\n          }}\r\n          renderItem={item => (\r\n            <View\r\n              className={`px-3 py-2 bg-black text-white flex-row justify-start items-center border-b border-gray-500 text-center ${\r\n                activeSeason === item ? 'bg-quaternary' : ''\r\n              }`}>\r\n              <Text className=\"text-white\">{item.title}</Text>\r\n            </View>\r\n          )}\r\n        />\r\n      ) : (\r\n        <Text className=\"text-red-600 text-lg font-semibold px-2\">\r\n          {LinkList[0]?.title}\r\n        </Text>\r\n      )}\r\n\r\n      {/* Search and Sort Controls */}\r\n      {(filteredAndSortedEpisodes.length > 8 ||\r\n        filteredAndSortedDirectLinks.length > 8) && (\r\n        <View className=\"flex-row justify-between items-center mt-2\">\r\n          <TextInput\r\n            placeholder=\"Search...\"\r\n            className=\"bg-black/30 text-white rounded-md p-2 h-10 w-[80%] border-collapse border border-white/10\"\r\n            value={searchText}\r\n            onChangeText={setSearchText}\r\n          />\r\n          <TouchableOpacity\r\n            className=\"bg-black/30 rounded-md p-2 h-10 w-[15%] flex-row justify-center items-center\"\r\n            onPress={toggleSortOrder}>\r\n            <MaterialCommunityIcons\r\n              name={sortOrder === 'asc' ? 'sort-ascending' : 'sort-descending'}\r\n              size={24}\r\n              color={primary}\r\n            />\r\n          </TouchableOpacity>\r\n        </View>\r\n      )}\r\n\r\n      {/* Episode/Direct Links List */}\r\n      <View className=\"flex-row flex-wrap justify-center gap-x-2 gap-y-2\">\r\n        {/* Episodes List */}\r\n        {filteredAndSortedEpisodes.length > 0 && (\r\n          <FlatList\r\n            data={filteredAndSortedEpisodes}\r\n            keyExtractor={(item, index) => `episode-${item.link}-${index}`}\r\n            renderItem={renderEpisodeItem}\r\n            maxToRenderPerBatch={10}\r\n            windowSize={10}\r\n            removeClippedSubviews={true}\r\n            getItemLayout={(data, index) => ({\r\n              length: 60,\r\n              offset: 60 * index,\r\n              index,\r\n            })}\r\n          />\r\n        )}\r\n\r\n        {/* Direct Links List */}\r\n        {filteredAndSortedDirectLinks.length > 0 && (\r\n          <View className=\"w-full justify-center items-center gap-y-2 mt-3 p-2\">\r\n            <FlatList\r\n              data={filteredAndSortedDirectLinks}\r\n              keyExtractor={(item, index) => `direct-${item.link}-${index}`}\r\n              renderItem={renderDirectLinkItem}\r\n              maxToRenderPerBatch={10}\r\n              windowSize={10}\r\n              removeClippedSubviews={true}\r\n              getItemLayout={(data, index) => ({\r\n                length: 68,\r\n                offset: 68 * index,\r\n                index,\r\n              })}\r\n            />\r\n          </View>\r\n        )}\r\n\r\n        {/* No Content Available */}\r\n        {filteredAndSortedEpisodes.length === 0 &&\r\n          filteredAndSortedDirectLinks.length === 0 &&\r\n          LinkList?.length === 0 && (\r\n            <Text className=\"text-white text-lg font-semibold min-h-20\">\r\n              No stream found\r\n            </Text>\r\n          )}\r\n      </View>\r\n\r\n      {/* VLC Loading Indicator */}\r\n      {vlcLoading && (\r\n        <View className=\"absolute top-0 left-0 w-full h-full bg-black/60 bg-opacity-50 justify-center items-center\">\r\n          <MotiView\r\n            from={{rotate: '0deg'}}\r\n            animate={{rotate: '360deg'}}\r\n            //@ts-ignore\r\n            transition={{\r\n              type: 'timing',\r\n              duration: 800,\r\n              loop: true,\r\n              repeatReverse: false,\r\n            }}>\r\n            <MaterialCommunityIcons name=\"vlc\" size={70} color={primary} />\r\n          </MotiView>\r\n          <Text className=\"text-white text-lg font-semibold mt-2\">\r\n            Loading available servers...\r\n          </Text>\r\n        </View>\r\n      )}\r\n\r\n      {/* Server Selection Modal */}\r\n      <Modal\r\n        animationType=\"slide\"\r\n        transparent={true}\r\n        visible={showServerModal}\r\n        onRequestClose={() => setShowServerModal(false)}>\r\n        <Pressable\r\n          onPress={() => setShowServerModal(false)}\r\n          className=\"flex-1 justify-center items-center bg-black/80\">\r\n          <View className=\"bg-tertiary rounded-xl p-4 w-[90%] max-w-[350px]\">\r\n            <Text className=\"text-white text-xl font-bold mb-2 text-center\">\r\n              Select External Player Server\r\n            </Text>\r\n            <Text className=\"text-white text-sm mb-4 text-center opacity-70\">\r\n              {externalPlayerStreams.length} servers available\r\n            </Text>\r\n\r\n            {isLoadingStreams ? (\r\n              <ActivityIndicator size=\"large\" color={primary} />\r\n            ) : (\r\n              <>\r\n                <ScrollView style={{maxHeight: 300}}>\r\n                  {externalPlayerStreams.map((item, index) =>\r\n                    renderServerItem(item, index),\r\n                  )}\r\n                  {externalPlayerStreams.length === 0 && (\r\n                    <Text className=\"text-white text-center p-4\">\r\n                      No servers available\r\n                    </Text>\r\n                  )}\r\n                </ScrollView>\r\n\r\n                <TouchableOpacity\r\n                  className=\"mt-4 bg-black/30 py-2 rounded-md\"\r\n                  onPress={() => setShowServerModal(false)}>\r\n                  <Text className=\"text-white text-center font-bold\">\r\n                    Cancel\r\n                  </Text>\r\n                </TouchableOpacity>\r\n              </>\r\n            )}\r\n          </View>\r\n        </Pressable>\r\n      </Modal>\r\n\r\n      {/* Sticky Menu Modal */}\r\n      <Modal\r\n        animationType=\"fade\"\r\n        visible={stickyMenu.active}\r\n        transparent={true}\r\n        onRequestClose={() => setStickyMenu({active: false})}>\r\n        <Pressable\r\n          className=\"flex-1 justify-end items-center\"\r\n          onPress={() => setStickyMenu({active: false})}>\r\n          <View className=\"w-full h-14 bg-quaternary flex-row justify-evenly items-center pt-2\">\r\n            {isCompleted(stickyMenu.link || '') ? (\r\n              <TouchableOpacity\r\n                className=\"flex-row justify-center items-center gap-2 p-2\"\r\n                onPress={markAsUnwatched}>\r\n                <Text className=\"text-white\">Marked as Unwatched</Text>\r\n                <Ionicons name=\"checkmark-done\" size={30} color={primary} />\r\n              </TouchableOpacity>\r\n            ) : (\r\n              <TouchableOpacity\r\n                className=\"flex-row justify-center items-center gap-2 pt-0 pb-2 px-2 bg-tertiary rounded-md\"\r\n                onPress={markAsWatched}>\r\n                <Text className=\"text-white\">Mark as Watched</Text>\r\n                <Ionicons name=\"checkmark\" size={25} color={primary} />\r\n              </TouchableOpacity>\r\n            )}\r\n            <TouchableOpacity\r\n              className=\"flex-row justify-center bg-tertiary rounded-md items-center pt-0 pb-2 px-2 gap-2\"\r\n              onPress={handleStickyMenuExternalPlayer}>\r\n              <Text className=\"text-white font-bold text-base\">\r\n                External Player\r\n              </Text>\r\n              <Feather name=\"external-link\" size={20} color={primary} />\r\n            </TouchableOpacity>\r\n          </View>\r\n        </Pressable>\r\n      </Modal>\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default SeasonList;\r\n","size_bytes":27419},"src/components/Skeleton.tsx":{"content":"import React, {useEffect, useRef} from 'react';\r\nimport {Animated, StyleSheet, View} from 'react-native';\r\nimport LinearGradient from 'react-native-linear-gradient';\r\nimport {Easing} from 'react-native-reanimated';\r\n\r\ntype SkeletonLoaderProps = {\r\n  width: number;\r\n  height: number;\r\n  style?: any;\r\n  darkMode?: boolean;\r\n  marginVertical?: number;\r\n};\r\nconst SkeletonLoader = ({\r\n  width,\r\n  height,\r\n  style,\r\n  darkMode = true,\r\n  marginVertical = 8,\r\n}: SkeletonLoaderProps) => {\r\n  const animatedValue = useRef(new Animated.Value(0)).current;\r\n\r\n  useEffect(() => {\r\n    const startShimmer = () => {\r\n      Animated.loop(\r\n        Animated.timing(animatedValue, {\r\n          toValue: 1,\r\n          duration: 1500,\r\n          easing: Easing.linear,\r\n          useNativeDriver: true,\r\n        }),\r\n      ).start();\r\n    };\r\n\r\n    startShimmer();\r\n  }, [animatedValue]);\r\n\r\n  const lightColors = ['#E0E0E0', '#F5F5F5', '#E0E0E0'];\r\n  const darkColors = ['#333333', '#444', '#333333'];\r\n  const colors = darkMode ? darkColors : lightColors;\r\n\r\n  const translateX = animatedValue.interpolate({\r\n    inputRange: [0, 1],\r\n    outputRange: [-width, width],\r\n  });\r\n\r\n  return (\r\n    <View style={[styles.skeleton, {width, height, marginVertical}, style]}>\r\n      <Animated.View\r\n        style={{\r\n          flex: 1,\r\n          transform: [{translateX}],\r\n        }}>\r\n        <LinearGradient\r\n          colors={colors}\r\n          start={{x: 0, y: 0.5}}\r\n          end={{x: 1, y: 0.5}}\r\n          style={[{width: '100%', height: '100%'}]}\r\n        />\r\n      </Animated.View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  skeleton: {\r\n    overflow: 'hidden',\r\n    borderRadius: 5,\r\n    // based on dark mode\r\n    backgroundColor: '#333',\r\n  },\r\n});\r\n\r\nexport default SkeletonLoader;\r\n","size_bytes":1799},"src/components/Slider.tsx":{"content":"import {Image, Pressable, Text, TouchableOpacity, View} from 'react-native';\r\nimport React from 'react';\r\nimport type {Post} from '../lib/providers/types';\r\nimport {NativeStackNavigationProp} from '@react-navigation/native-stack';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport {HomeStackParamList} from '../App';\r\nimport useContentStore from '../lib/zustand/contentStore';\r\nimport {FlashList} from '@shopify/flash-list';\r\nimport SkeletonLoader from './Skeleton';\r\n\r\n// import useWatchHistoryStore from '../lib/zustand/watchHistrory';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\n\r\nexport default function Slider({\r\n  isLoading,\r\n  title,\r\n  posts,\r\n  filter,\r\n  providerValue,\r\n  isSearch = false,\r\n}: {\r\n  isLoading: boolean;\r\n  title: string;\r\n  posts: Post[];\r\n  filter: string;\r\n  providerValue?: string;\r\n  isSearch?: boolean;\r\n}): JSX.Element {\r\n  const {provider} = useContentStore(state => state);\r\n  const {primary} = useThemeStore(state => state);\r\n  const navigation =\r\n    useNavigation<NativeStackNavigationProp<HomeStackParamList>>();\r\n  const [isSelected, setSelected] = React.useState('');\r\n  // const {removeItem} = useWatchHistoryStore(state => state);\r\n\r\n  return (\r\n    <Pressable onPress={() => setSelected('')} className=\"gap-3 mt-3 px-2\">\r\n      <View className=\"flex flex-row items-center justify-between\">\r\n        <Text className=\"text-2xl font-semibold\" style={{color: primary}}>\r\n          {title}\r\n        </Text>\r\n        {filter !== 'recent' && (\r\n          <TouchableOpacity\r\n            onPress={() =>\r\n              navigation.navigate('ScrollList', {\r\n                title: title,\r\n                filter: filter,\r\n                providerValue: providerValue,\r\n                isSearch: isSearch,\r\n              })\r\n            }>\r\n            <Text className=\"text-white text-sm\">more</Text>\r\n          </TouchableOpacity>\r\n        )}\r\n      </View>\r\n      {isLoading ? (\r\n        <View className=\"flex flex-row gap-2 overflow-hidden\">\r\n          {Array.from({length: 20}).map((_, index) => (\r\n            <View\r\n              className=\"mx-3 gap-0 flex mb-3 justify-center items-center\"\r\n              key={index}>\r\n              <SkeletonLoader height={150} width={100} />\r\n              <SkeletonLoader height={12} width={97} />\r\n            </View>\r\n          ))}\r\n        </View>\r\n      ) : (\r\n        <FlashList\r\n          estimatedItemSize={30}\r\n          showsHorizontalScrollIndicator={false}\r\n          data={posts}\r\n          extraData={isSelected}\r\n          horizontal\r\n          contentContainerStyle={{paddingHorizontal: 3, paddingTop: 7}}\r\n          renderItem={({item}) => (\r\n            <View className=\"flex flex-col mx-2\">\r\n              <TouchableOpacity\r\n                onLongPress={e => {\r\n                  e.stopPropagation();\r\n                  // if (filter === 'recent') {\r\n                  //   console.log('long press', filter);\r\n                  //   ReactNativeHapticFeedback.trigger('effectClick', {\r\n                  //     enableVibrateFallback: true,\r\n                  //     ignoreAndroidSystemSettings: false,\r\n                  //   });\r\n                  //   setSelected(item.link);\r\n                  // }\r\n                }}\r\n                onPress={e => {\r\n                  e.stopPropagation();\r\n                  setSelected('');\r\n                  navigation.navigate('Info', {\r\n                    link: item.link,\r\n                    provider: item.provider || providerValue || provider?.value,\r\n                    poster: item?.image,\r\n                  });\r\n                }}>\r\n                <Image\r\n                  className=\"rounded-md\"\r\n                  source={{\r\n                    uri:\r\n                      item?.image ||\r\n                      'https://placehold.jp/24/363636/ffffff/100x150.png?text=vega',\r\n                  }}\r\n                  style={{width: 100, height: 150}}\r\n                />\r\n                {/* {isSelected === item.link && (\r\n                  <View className=\"absolute top-0 left-0 w-full h-full bg-black/50 flex justify-center items-center z-50\">\r\n                    <AntDesign\r\n                      name=\"delete\"\r\n                      size={24}\r\n                      color=\"white\"\r\n                      onPress={() => {\r\n                        console.log('remove', item);\r\n                        setSelected('');\r\n                        removeItem(item);\r\n                      }}\r\n                    />\r\n                  </View>\r\n                )} */}\r\n              </TouchableOpacity>\r\n              <Text className=\"text-white text-center truncate w-24 text-xs\">\r\n                {item.title.length > 24\r\n                  ? `${item.title.slice(0, 24)}...`\r\n                  : item.title}\r\n              </Text>\r\n            </View>\r\n          )}\r\n          ListFooterComponent={\r\n            !isLoading && posts.length === 0 ? (\r\n              <View className=\"flex flex-row w-96 justify-center h-10 items-center\">\r\n                <Text className=\"text-whiter text-center text-white\">\r\n                  No content found\r\n                </Text>\r\n              </View>\r\n            ) : null\r\n          }\r\n          keyExtractor={item => item.link}\r\n        />\r\n      )}\r\n    </Pressable>\r\n  );\r\n}\r\n","size_bytes":5293},"src/components/StreamModal.tsx":{"content":"import {View, Text, ToastAndroid, Clipboard} from 'react-native';\r\nimport React from 'react';\r\nimport {Modal, TouchableOpacity} from 'react-native';\r\nimport MaterialIcons from '@expo/vector-icons/MaterialIcons';\r\nimport ReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport {Skeleton} from 'moti/skeleton';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport {settingsStorage} from '../lib/storage';\r\n\r\nconst StreamModal = ({\r\n  downloadModal,\r\n  setDownloadModal,\r\n  servers,\r\n  serverLoading,\r\n  downloadFile,\r\n}: {\r\n  downloadModal: boolean;\r\n  setDownloadModal: (value: boolean) => void;\r\n  servers: Array<{server: string; link: string}>;\r\n  serverLoading: boolean;\r\n  downloadFile: (link: string) => void;\r\n}) => {\r\n  const {primary} = useThemeStore(state => state);\r\n  return (\r\n    <Modal animationType=\"fade\" visible={downloadModal} transparent={true}>\r\n      <View className=\"flex-1 bg-black/10 justify-center items-center p-4\">\r\n        <View className=\"bg-tertiary p-3 w-full rounded-md justify-center items-center\">\r\n          <Text className=\"text-lg font-semibold my-3 text-white\">\r\n            Select a server to download\r\n          </Text>\r\n          <View className=\"flex-row items-center flex-wrap gap-1 justify-evenly w-full my-5\">\r\n            {!serverLoading\r\n              ? servers?.map((server, index) => (\r\n                  <TouchableOpacity\r\n                    key={server.server + index}\r\n                    onPress={() => {\r\n                      setDownloadModal(false);\r\n                      downloadFile(server.link);\r\n                    }}\r\n                    onLongPress={() => {\r\n                      if (settingsStorage.getBool('hapticFeedback') !== false) {\r\n                        ReactNativeHapticFeedback.trigger('effectHeavyClick', {\r\n                          enableVibrateFallback: true,\r\n                          ignoreAndroidSystemSettings: false,\r\n                        });\r\n                      }\r\n                      Clipboard.setString(server.link);\r\n                      ToastAndroid.show(\r\n                        'Link copied to clipboard',\r\n                        ToastAndroid.SHORT,\r\n                      );\r\n                    }}\r\n                    className=\"p-2 rounded-md m-1\"\r\n                    style={{backgroundColor: primary}}>\r\n                    <Text className=\"text-white text-xs rounded-md capitalize px-1\">\r\n                      {server.server}\r\n                    </Text>\r\n                  </TouchableOpacity>\r\n                ))\r\n              : Array.from({length: 3}).map((_, index) => (\r\n                  <Skeleton\r\n                    key={index}\r\n                    show={true}\r\n                    colorMode=\"dark\"\r\n                    height={30}\r\n                    width={90}\r\n                  />\r\n                ))}\r\n          </View>\r\n          <View className=\"flex-row items-center gap-2 w-full\">\r\n            <MaterialIcons\r\n              name=\"info-outline\"\r\n              size={14}\r\n              color=\"#c1c4c9\"\r\n              onPress={() => setDownloadModal(false)}\r\n            />\r\n            <Text className=\"text-[10px] text-center text-white\">\r\n              Long press to copy download link\r\n            </Text>\r\n          </View>\r\n          {/* close modal */}\r\n          <TouchableOpacity\r\n            onPress={() => setDownloadModal(false)}\r\n            className=\"absolute top-2 right-2\">\r\n            <MaterialIcons name=\"close\" size={20} color=\"#c1c4c9\" />\r\n          </TouchableOpacity>\r\n        </View>\r\n      </View>\r\n    </Modal>\r\n  );\r\n};\r\n\r\nexport default StreamModal;\r\n","size_bytes":3635},"src/components/TabBarBackgound.tsx":{"content":"import {StyleSheet} from 'react-native';\r\nimport React from 'react';\r\nimport {BlurView} from 'expo-blur';\r\nimport LinearGradient from 'react-native-linear-gradient';\r\n\r\nconst TabBarBackgound = () => {\r\n  return (\r\n    <>\r\n      <BlurView\r\n        style={StyleSheet.absoluteFill}\r\n        experimentalBlurMethod=\"dimezisBlurView\"\r\n        intensity={30}\r\n        blurReductionFactor={3}\r\n        tint=\"dark\"\r\n      />\r\n      <LinearGradient\r\n        colors={[\r\n          'rgba(0, 0, 0, 0.0)',\r\n          'rgba(0, 0, 0, 0.3)',\r\n          'rgba(0, 0, 0, 0.5)',\r\n          'rgba(0, 0, 0, 0.8)',\r\n          'rgba(0, 0, 0, 1)',\r\n        ]}\r\n        style={StyleSheet.absoluteFill}\r\n        start={{x: 0, y: 0}}\r\n        end={{x: 0, y: 1}}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\nexport default TabBarBackgound;\r\n","size_bytes":798},"src/components/Touturial.tsx":{"content":"import {View, Text, StatusBar, TouchableOpacity} from 'react-native';\r\nimport React from 'react';\r\nimport {useState} from 'react';\r\nimport useContentStore from '../lib/zustand/contentStore';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport Animated, {FadeInRight} from 'react-native-reanimated';\r\nimport {\r\n  NavigationProp,\r\n  useFocusEffect,\r\n  useNavigation,\r\n} from '@react-navigation/native';\r\nimport {MaterialCommunityIcons} from '@expo/vector-icons';\r\nimport {settingsStorage} from '../lib/storage';\r\nimport ReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport {RootStackParamList} from '../App';\r\n\r\nconst Tutorial = () => {\r\n  const navigation = useNavigation<NavigationProp<RootStackParamList>>();\r\n  const {primary} = useThemeStore(state => state);\r\n  const {provider: currentProvider, installedProviders} = useContentStore(\r\n    state => state,\r\n  );\r\n  const [showTutorial, setShowTutorial] = useState<boolean>(!currentProvider);\r\n\r\n  // Handle default provider setup\r\n  React.useEffect(() => {\r\n    if (\r\n      !currentProvider ||\r\n      !currentProvider.value ||\r\n      !installedProviders ||\r\n      installedProviders.length === 0\r\n    ) {\r\n      setShowTutorial(true);\r\n    } else {\r\n      setShowTutorial(false);\r\n    }\r\n  }, [installedProviders, currentProvider]);\r\n\r\n  // Handle status bar color\r\n  useFocusEffect(\r\n    React.useCallback(() => {\r\n      StatusBar.setBackgroundColor('#121212');\r\n      StatusBar.setBarStyle('light-content');\r\n\r\n      return () => {\r\n        StatusBar.setBackgroundColor('#121212');\r\n        StatusBar.setBarStyle('light-content');\r\n      };\r\n    }, []),\r\n  );\r\n\r\n  const handleGoToExtensions = () => {\r\n    // Add haptic feedback\r\n    if (settingsStorage.isHapticFeedbackEnabled()) {\r\n      ReactNativeHapticFeedback.trigger('effectClick', {\r\n        enableVibrateFallback: true,\r\n        ignoreAndroidSystemSettings: false,\r\n      });\r\n    }\r\n\r\n    navigation.navigate('TabStack', {\r\n      screen: 'SettingsStack',\r\n      params: {\r\n        screen: 'Extensions',\r\n      },\r\n    });\r\n  };\r\n\r\n  return showTutorial ? (\r\n    <View className=\"absolute inset-0 z-50 bg-black/90 justify-center items-center w-full h-full\">\r\n      <Animated.View\r\n        entering={FadeInRight.duration(500)}\r\n        className=\"rounded-2xl p-6 w-full max-w-sm items-center\">\r\n        <MaterialCommunityIcons\r\n          name=\"package-variant-closed\"\r\n          size={64}\r\n          color=\"#6B7280\"\r\n          style={{marginBottom: 16}}\r\n        />\r\n        <Text className=\"text-white text-2xl font-bold text-center mb-4\">\r\n          No Provider Installed\r\n        </Text>\r\n        <Text className=\"text-gray-400 text-base text-center mb-6 leading-6\">\r\n          You need to install at least one provider to start watching content.\r\n          Providers give you access to different streaming sources.\r\n        </Text>\r\n        <TouchableOpacity\r\n          onPress={handleGoToExtensions}\r\n          className=\"px-6 py-3 rounded-xl w-full flex-row items-center justify-center\"\r\n          style={{backgroundColor: primary}}>\r\n          <MaterialCommunityIcons name=\"download\" size={20} color=\"white\" />\r\n          <Text className=\"text-white font-semibold ml-2 text-base\">\r\n            Install Providers\r\n          </Text>\r\n        </TouchableOpacity>\r\n      </Animated.View>\r\n    </View>\r\n  ) : null;\r\n};\r\n\r\nexport default Tutorial;\r\n","size_bytes":3394},"src/lib/Mmkv.ts":{"content":"import {MMKVLoader} from 'react-native-mmkv-storage';\r\n\r\nexport const MMKV = new MMKVLoader().initialize();\r\nexport const MmmkvCache = new MMKVLoader().withInstanceID('cache').initialize();\r\n","size_bytes":191},"src/lib/client.ts":{"content":"import {QueryClient} from '@tanstack/react-query';\r\n\r\n// Enhanced query client with optimal configurations\r\nexport const queryClient = new QueryClient({\r\n  defaultOptions: {\r\n    queries: {\r\n      // Retry configuration\r\n      retry: (failureCount, error) => {\r\n        // Don't retry on abort errors or 4xx errors\r\n        if (error.name === 'AbortError') {\r\n          return false;\r\n        }\r\n        if (error.message?.includes('4')) {\r\n          return false; // 4xx errors\r\n        }\r\n\r\n        // Retry up to 3 times for other errors with exponential backoff\r\n        return failureCount < 3;\r\n      },\r\n      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\r\n\r\n      // Cache configuration\r\n      staleTime: 5 * 60 * 1000, // 5 minutes - data is fresh for 5 minutes\r\n      gcTime: 30 * 60 * 1000, // 30 minutes - keep in cache for 30 minutes\r\n\r\n      // Network configuration\r\n      refetchOnWindowFocus: false, // Don't refetch when app regains focus\r\n      refetchOnReconnect: 'always', // Always refetch when reconnected\r\n      refetchOnMount: true, // Refetch when component mounts\r\n\r\n      // Performance optimizations\r\n      refetchInterval: false, // Disable automatic polling by default\r\n      notifyOnChangeProps: 'all', // Only notify on tracked properties\r\n\r\n      // Error handling\r\n      throwOnError: false, // Don't throw errors, handle them in components\r\n\r\n      // Network mode - continue with cached data if offline\r\n      networkMode: 'online',\r\n    },\r\n    mutations: {\r\n      retry: 1, // Retry mutations once\r\n      retryDelay: 1000,\r\n      throwOnError: false,\r\n      networkMode: 'online',\r\n    },\r\n  },\r\n});\r\n\r\n// Enhanced query client for development with additional logging\r\nexport const createDevQueryClient = () => {\r\n  const client = new QueryClient({\r\n    defaultOptions: queryClient.getDefaultOptions(),\r\n  });\r\n\r\n  // Add development-only event listeners\r\n  if (__DEV__) {\r\n    client.getQueryCache().subscribe(event => {\r\n      console.log('Query cache event:', event.type, event.query.queryKey);\r\n    });\r\n\r\n    client.getMutationCache().subscribe(event => {\r\n      console.log(\r\n        'Mutation cache event:',\r\n        event.type,\r\n        event?.mutation?.options?.mutationKey,\r\n      );\r\n    });\r\n  }\r\n\r\n  return client;\r\n};\r\n\r\n// Performance monitoring utilities\r\nexport const queryClientUtils = {\r\n  // Get cache statistics\r\n  getCacheStats: () => {\r\n    const queryCache = queryClient.getQueryCache();\r\n    const queries = queryCache.getAll();\r\n\r\n    return {\r\n      totalQueries: queries.length,\r\n      freshQueries: queries.filter(q => q.isStale() === false).length,\r\n      staleQueries: queries.filter(q => q.isStale() === true).length,\r\n      loadingQueries: queries.filter(q => q.state.fetchStatus === 'fetching')\r\n        .length,\r\n      errorQueries: queries.filter(q => q.state.status === 'error').length,\r\n    };\r\n  },\r\n\r\n  // Clear specific cache patterns\r\n  clearCache: (patterns: string[]) => {\r\n    patterns.forEach(pattern => {\r\n      queryClient.removeQueries({queryKey: [pattern]});\r\n    });\r\n  },\r\n\r\n  // Prefetch common queries\r\n  prefetchCommonData: async (providerValue: string) => {\r\n    // Prefetch catalog data\r\n    await queryClient.prefetchQuery({\r\n      queryKey: ['catalog', providerValue],\r\n      queryFn: async () => {\r\n        const {providerManager} = await import('./services/ProviderManager');\r\n        return providerManager.getCatalog({providerValue});\r\n      },\r\n      staleTime: 10 * 60 * 1000, // 10 minutes\r\n    });\r\n  },\r\n\r\n  // Optimistic updates helper\r\n  setOptimisticData: <T>(\r\n    queryKey: unknown[],\r\n    updater: (old: T | undefined) => T,\r\n  ) => {\r\n    queryClient.setQueryData(queryKey, updater);\r\n  },\r\n};\r\n\r\n// Export the appropriate client based on environment\r\nexport const client = __DEV__ ? createDevQueryClient() : queryClient;\r\n","size_bytes":3862},"src/lib/constants.ts":{"content":"import * as RNFS from '@dr.pogodin/react-native-fs';\r\n\r\nexport const FLAGS = {\r\n  GLOBAL: 'https://utfs.io/f/ImOWJajUmXfyRKHTpylsELpB6QlYA4OdG9Jfr3hagoCN5Mzt',\r\n  INDIA: 'https://utfs.io/f/ImOWJajUmXfyYCEwdELCDZIMxNG5H27Bouwvb4fyVJrdqj3X',\r\n  ENGLISH: 'https://utfs.io/f/ImOWJajUmXfyN1E0dlnILrEMR3DJQX7OUvixCSHp6YWGNVPc',\r\n  ITALY: 'https://utfs.io/f/ImOWJajUmXfynpGlTaXrTMAELcs2W76PyY4IRJVBXCHOofa5',\r\n};\r\n\r\nexport const downloadFolder = RNFS.DownloadDirectoryPath + '/vega';\r\n\r\nexport const themes: {name: string; color: string}[] = [\r\n  {\r\n    name: 'Vega',\r\n    color: '#FF6347',\r\n  },\r\n  {\r\n    name: 'Hayasaka',\r\n    color: '#00e6e6',\r\n  },\r\n  {\r\n    name: 'Lavender',\r\n    color: '#B2A4D4',\r\n  },\r\n  {\r\n    name: 'Sky',\r\n    color: '#87CEEB',\r\n  },\r\n  {\r\n    name: 'Mint',\r\n    color: '#98FB98',\r\n  },\r\n  {\r\n    name: 'Sunset',\r\n    color: '#FFA07A',\r\n  },\r\n  {\r\n    name: 'Flix',\r\n    color: '#E50914',\r\n  },\r\n  {\r\n    name: 'Material',\r\n    color: '#2196F3',\r\n  },\r\n  {\r\n    name: 'Custom',\r\n    color: '#FFFFFF',\r\n  },\r\n];\r\n\r\nexport const socialLinks = {\r\n  github: 'https://github.com/Zenda-Cross/vega-app',\r\n  discord: 'https://discord.gg/cr42m6maWy',\r\n  sponsor: 'https://github.com/sponsors/Zenda-Cross',\r\n};\r\n","size_bytes":1224},"src/lib/downloader.ts":{"content":"import {ifExists} from './file/ifExists';\r\n// import {hlsDownloader} from './hlsDownloader';\r\nimport * as RNFS from '@dr.pogodin/react-native-fs';\r\nimport {Alert} from 'react-native';\r\nimport {downloadFolder} from './constants';\r\nimport requestStoragePermission from './file/getStoragePermission';\r\nimport {hlsDownloader2} from './hlsDownloader2';\r\nimport {notificationService} from './services/Notification';\r\n\r\nexport const downloadManager = async ({\r\n  title,\r\n  url,\r\n  fileName,\r\n  fileType,\r\n  setDownloadActive,\r\n  setAlreadyDownloaded,\r\n  setDownloadId,\r\n  headers,\r\n  deleteDownload,\r\n}: {\r\n  title: string;\r\n  url: string;\r\n  fileName: string;\r\n  fileType: string;\r\n  setDownloadActive: (value: boolean) => void;\r\n  headers?: any;\r\n  setAlreadyDownloaded: (value: boolean) => void;\r\n  setDownloadId: (value: number) => void;\r\n  deleteDownload: () => void;\r\n}) => {\r\n  await requestStoragePermission();\r\n\r\n  await notificationService.showDownloadStarting(title, fileName);\r\n  if (await ifExists(fileName)) {\r\n    console.log('File already exists');\r\n    setAlreadyDownloaded(true);\r\n    setDownloadActive(false);\r\n    return;\r\n  }\r\n  setDownloadActive(true);\r\n  // if (activeDownloads.length > 0) {\r\n  //   notifee.displayNotification({\r\n  //     id: 'downloadQueue',\r\n  //     title: 'Download Queue' + fileName,\r\n  //     body: 'Downloading ' + fileName,\r\n  //     android: {\r\n  //       channelId,\r\n  //       color: primary,\r\n  //     },\r\n  //   });\r\n  //   console.log(\r\n  //     'Downloading:',\r\n  //     activeDownloads[0],\r\n  //     activeDownloads[1],\r\n  //     activeDownloads.length,\r\n  //   );\r\n\r\n  //   return;\r\n  // }\r\n  try {\r\n    // downloadFile and save it to download folder\r\n    if (!(await RNFS.exists(downloadFolder))) {\r\n      await RNFS.mkdir(downloadFolder);\r\n    }\r\n    await notificationService.requestPermission();\r\n\r\n    if (fileType === 'm3u8') {\r\n      // hlsDownloader({\r\n      //   videoUrl: url,\r\n      //   downloadStore,\r\n      //   path: `${downloadFolder}/${fileName}.mp4`,\r\n      //   fileName,\r\n      //   title,\r\n      //   setAlreadyDownloaded,\r\n      //   setDownloadId: setDownloadId,\r\n      //   headers,\r\n      // });\r\n      hlsDownloader2({\r\n        videoUrl: url,\r\n        setDownloadActive,\r\n        path: `${downloadFolder}/${fileName}.mp4`,\r\n        fileName,\r\n        title,\r\n        setAlreadyDownloaded,\r\n        setDownloadId: setDownloadId,\r\n        headers,\r\n      });\r\n      // ToastAndroid.show(\r\n      //   'Hls video download is not supported, Use external Downloader',\r\n      //   ToastAndroid.LONG,\r\n      // );\r\n      // notifee.cancelNotification(fileName);\r\n      // downloadStore.removeActiveDownload(fileName);\r\n      // setAlreadyDownloaded(false);\r\n      console.log('Downloading HLS');\r\n      return;\r\n    }\r\n    const downloadDest = `${downloadFolder}/${fileName}.${fileType}`;\r\n    const ret = RNFS.downloadFile({\r\n      fromUrl: url,\r\n      progressInterval: 1000,\r\n      backgroundTimeout: 1000 * 60 * 60,\r\n      progressDivider: 1,\r\n      headers: headers ? headers : {},\r\n      toFile: downloadDest,\r\n      background: true,\r\n      begin: (res: any) => {\r\n        console.log('Download has started', res);\r\n        setDownloadId(ret.jobId);\r\n      },\r\n      progress: (res: any) => {\r\n        const progress = res.bytesWritten / res.contentLength;\r\n        const body =\r\n          res.contentLength < 1024 * 1024 * 1024\r\n            ? // less than 1GB?\r\n\r\n              Math.round(res.bytesWritten / 1024 / 1024) +\r\n              ' / ' +\r\n              Math.round(res.contentLength / 1024 / 1024) +\r\n              ' MB'\r\n            : parseFloat((res.bytesWritten / 1024 / 1024 / 1024).toFixed(2)) +\r\n              ' / ' +\r\n              parseFloat((res.contentLength / 1024 / 1024 / 1024).toFixed(2)) +\r\n              ' GB';\r\n        // console.log('Download progress:', progress * 100);\r\n        notificationService.showDownloadProgress(\r\n          title,\r\n          fileName,\r\n          progress,\r\n          body,\r\n          ret.jobId,\r\n        );\r\n      },\r\n    });\r\n    ret.promise.then(res => {\r\n      console.log('Download complete', res);\r\n      setAlreadyDownloaded(true);\r\n      notificationService.showDownloadComplete(title, fileName);\r\n      setDownloadActive(false);\r\n      // downloadManager({\r\n      //   ...activeDownloads[0],\r\n      //   downloadStore,\r\n      //   setAlreadyDownloaded,\r\n      // });\r\n    });\r\n    ret.promise.catch(err => {\r\n      deleteDownload();\r\n      console.log('Download error:', err);\r\n      Alert.alert('Download failed', err.message || 'Failed to download');\r\n      notificationService.showDownloadFailed(title, fileName);\r\n      setDownloadActive(false);\r\n      setAlreadyDownloaded(false);\r\n      // downloadManager({\r\n      //   ...activeDownloads[0],\r\n      //   downloadStore,\r\n      //   setAlreadyDownloaded,\r\n      // });\r\n    });\r\n    return ret.jobId;\r\n  } catch (error: any) {\r\n    console.error('Download error:', error);\r\n    deleteDownload();\r\n    Alert.alert('Download failed', 'Failed to download');\r\n    setDownloadActive(false);\r\n    setAlreadyDownloaded(false);\r\n  }\r\n};\r\n","size_bytes":5122},"src/lib/getHomepagedata.ts":{"content":"import {Content} from './zustand/contentStore';\r\nimport {Post} from './providers/types';\r\nimport {providerManager} from './services/ProviderManager';\r\n\r\nexport interface HomePageData {\r\n  title: string;\r\n  Posts: Post[];\r\n  filter: string;\r\n  error?: string;\r\n}\r\n\r\n// Optimized version with better error handling\r\nexport const getHomePageDataOptimized = async (\r\n  activeProvider: Content['provider'],\r\n  signal: AbortSignal,\r\n): Promise<HomePageData[]> => {\r\n  console.log('Fetching data for provider:', activeProvider.display_name);\r\n\r\n  const catalogs = providerManager.getCatalog({\r\n    providerValue: activeProvider.value,\r\n  });\r\n\r\n  // Use Promise.allSettled for partial success\r\n  const fetchPromises = catalogs.map(async item => {\r\n    try {\r\n      const data = await providerManager.getPosts({\r\n        filter: item.filter,\r\n        page: 1,\r\n        providerValue: activeProvider.value,\r\n        signal,\r\n      });\r\n\r\n      if (signal.aborted) {\r\n        throw new Error('Request aborted');\r\n      }\r\n\r\n      console.log(`✅ Fetched ${data?.length || 0} posts for: ${item.title}`);\r\n\r\n      return {\r\n        title: item.title,\r\n        Posts: data || [],\r\n        filter: item.filter,\r\n      };\r\n    } catch (error) {\r\n      console.error(`❌ Failed to fetch ${item.title}:`, error);\r\n\r\n      // Return partial data with error info instead of failing completely\r\n      return {\r\n        title: item.title,\r\n        Posts: [],\r\n        filter: item.filter,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      };\r\n    }\r\n  });\r\n\r\n  const results = await Promise.allSettled(fetchPromises);\r\n\r\n  // Extract successful results and log failures\r\n  const homePageData: HomePageData[] = [];\r\n  let successCount = 0;\r\n  let failureCount = 0;\r\n\r\n  results.forEach((result, index) => {\r\n    if (result.status === 'fulfilled') {\r\n      homePageData.push(result.value);\r\n      if (result.value.Posts.length > 0) {\r\n        successCount++;\r\n      }\r\n    } else {\r\n      failureCount++;\r\n      console.error(\r\n        `Failed to process catalog ${catalogs[index].title}:`,\r\n        result.reason,\r\n      );\r\n\r\n      // Add empty category to maintain layout\r\n      homePageData.push({\r\n        title: catalogs[index].title,\r\n        Posts: [],\r\n        filter: catalogs[index].filter,\r\n        error: result.reason?.message || 'Failed to load',\r\n      });\r\n    }\r\n  });\r\n\r\n  console.log(\r\n    `📊 Results: ${successCount} successful, ${failureCount} failed categories`,\r\n  );\r\n\r\n  // Ensure we have at least some data\r\n  if (successCount === 0) {\r\n    throw new Error('Failed to load any content categories');\r\n  }\r\n\r\n  return homePageData;\r\n};\r\n\r\n// Keep original for backward compatibility\r\nexport const getHomePageData = getHomePageDataOptimized;\r\n","size_bytes":2780},"src/lib/hlsDownloader.ts":{"content":"import {FFmpegKit, FFprobeKit, ReturnCode} from 'ffmpeg-kit-react-native';\r\nimport notifee from '@notifee/react-native';\r\nimport {Downloads} from './zustand/downloadsStore';\r\nimport {settingsStorage} from './storage';\r\n\r\nconst getVideoDuration = async (videoUrl: string) => {\r\n  try {\r\n    const information = await FFprobeKit.getMediaInformation(videoUrl);\r\n    const output = await information.getOutput();\r\n    const jsonOutput = JSON.parse(output);\r\n    console.log('Output: 🔥🔥🔥', jsonOutput.format.duration);\r\n    const duration = parseFloat(jsonOutput.format.duration);\r\n    return duration;\r\n  } catch (error) {\r\n    console.log('Error getting video duration', error);\r\n    return 0;\r\n  }\r\n};\r\n\r\nexport const hlsDownloader = async ({\r\n  videoUrl,\r\n  path,\r\n  fileName,\r\n  title,\r\n  downloadStore,\r\n  setAlreadyDownloaded,\r\n  setDownloadId,\r\n  headers = {},\r\n}: {\r\n  videoUrl: string;\r\n  path: string;\r\n  fileName: string;\r\n  title: string;\r\n  downloadStore: Downloads;\r\n  setAlreadyDownloaded: (value: boolean) => void;\r\n  setDownloadId: (value: number) => void;\r\n  headers?: any;\r\n}) => {\r\n  const ffprobeHttpHeaders = headers\r\n    ? Object.entries(headers)\r\n        .map(([key, value]) => `${key}: ${value}`)\r\n        .join('\\r\\n') + '\\r\\n'\r\n    : '';\r\n  const command = `-headers \"${ffprobeHttpHeaders}\" -i ${videoUrl} -c copy -bsf:a aac_adtstoasc -f mp4 -reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5 -timeout 5000000 -preset ultrafast ${path}`;\r\n  const channelId = await notifee.createChannel({\r\n    id: 'download',\r\n    name: 'Download Notifications',\r\n  });\r\n  const primary = settingsStorage.getPrimaryColor();\r\n  try {\r\n    const duration = (await getVideoDuration(videoUrl)) || 0;\r\n    await FFmpegKit.executeAsync(\r\n      command,\r\n      async session => {\r\n        console.log(\r\n          'FFmpeg process started with sessionId: ' + session.getSessionId(),\r\n        );\r\n\r\n        const returnCode = await session.getReturnCode();\r\n\r\n        if (ReturnCode.isSuccess(returnCode)) {\r\n          // If download was successful, move the downloaded file into the devices library\r\n          console.log('Download successful');\r\n          setAlreadyDownloaded(true);\r\n          downloadStore.removeActiveDownload(fileName);\r\n          await notifee.cancelNotification(fileName);\r\n          await notifee.displayNotification({\r\n            title: 'Download completed',\r\n            body: `Downloaded ${title}`,\r\n            android: {\r\n              pressAction: {\r\n                id: 'default',\r\n              },\r\n              color: primary,\r\n              smallIcon: 'ic_notification',\r\n              channelId,\r\n            },\r\n          });\r\n        } else {\r\n          setAlreadyDownloaded(false);\r\n          downloadStore.removeActiveDownload(fileName);\r\n          console.log('Download failed');\r\n          await notifee.cancelNotification(fileName);\r\n          await notifee.displayNotification({\r\n            title: 'Download failed',\r\n            body: `Failed to download ${title}`,\r\n            android: {\r\n              pressAction: {\r\n                id: 'default',\r\n              },\r\n              color: primary,\r\n              smallIcon: 'ic_notification',\r\n              channelId,\r\n            },\r\n          });\r\n        }\r\n      },\r\n      async log => {\r\n        const message = log.getMessage();\r\n        const regex = /time=(\\d{2}:\\d{2}:\\d{2}.\\d{2})/;\r\n        const currentTime = regex.exec(message as string);\r\n        if (currentTime && currentTime[1]) {\r\n          const currentTimeInSeconds =\r\n            parseInt(currentTime[1].split(':')[0]) * 3600 +\r\n            parseInt(currentTime[1].split(':')[1]) * 60 +\r\n            parseFloat(currentTime[1].split(':')[2]);\r\n          const progress = (currentTimeInSeconds / duration) * 100;\r\n          console.log('Progress: ', currentTimeInSeconds, duration, progress);\r\n          setDownloadId(log.getSessionId());\r\n          await notifee.displayNotification({\r\n            title: title,\r\n            body:\r\n              progress > 100\r\n                ? 'Downloading'\r\n                : `Downloaded ${progress.toFixed(2)}%`,\r\n            id: fileName,\r\n            data: {fileName, jobId: log.getSessionId()},\r\n            android: {\r\n              pressAction: {\r\n                id: 'default',\r\n              },\r\n              smallIcon: 'ic_notification',\r\n              onlyAlertOnce: true,\r\n              progress: {\r\n                max: 100,\r\n                indeterminate: progress > 100,\r\n                current: progress > 100 ? 100 : progress,\r\n              },\r\n              color: primary,\r\n              channelId,\r\n              actions: [\r\n                {\r\n                  title: 'Cancel',\r\n                  pressAction: {\r\n                    id: fileName,\r\n                  },\r\n                },\r\n              ],\r\n            },\r\n          });\r\n        }\r\n      },\r\n    );\r\n  } catch (error) {\r\n    setAlreadyDownloaded(false);\r\n    downloadStore.removeActiveDownload(fileName);\r\n    console.log('Error downloading', error);\r\n    await notifee.displayNotification({\r\n      title: 'Download failed',\r\n      body: `Failed to download ${fileName}`,\r\n      android: {\r\n        pressAction: {\r\n          id: 'default',\r\n        },\r\n        color: primary,\r\n        smallIcon: 'ic_notification',\r\n        channelId,\r\n      },\r\n    });\r\n  }\r\n};\r\n","size_bytes":5379},"src/lib/hlsDownloader2.ts":{"content":"import * as RNFS from '@dr.pogodin/react-native-fs';\r\nimport axios from 'axios';\r\nimport {notificationService} from './services/Notification';\r\n\r\ninterface SegmentInfo {\r\n  duration: number;\r\n  url: string;\r\n  index: number;\r\n}\r\n\r\ninterface M3U8Data {\r\n  segments: SegmentInfo[];\r\n  totalDuration: number;\r\n  isLive: boolean;\r\n}\r\n\r\nlet downloadCancelled = false;\r\nlet currentDownloadId: string | null = null;\r\n\r\n// Map to store the relationship between numeric IDs and fileName for HLS downloads\r\nconst hlsDownloadMap = new Map<number, string>();\r\nlet nextHlsId = 1000; // Start HLS IDs from 1000 to distinguish from RNFS job IDs\r\n\r\nconst parseM3U8Playlist = async (\r\n  url: string,\r\n  headers: any = {},\r\n): Promise<M3U8Data> => {\r\n  try {\r\n    console.log('Fetching M3U8 playlist:', url);\r\n    const response = await axios.get(url, {\r\n      headers,\r\n      timeout: 10000,\r\n    });\r\n\r\n    const content = response.data;\r\n    console.log('M3U8 content preview:', content.substring(0, 500));\r\n    const lines = content.split('\\n').map((line: string) => line.trim());\r\n\r\n    const segments: SegmentInfo[] = [];\r\n    let totalDuration = 0;\r\n    let isLive = false;\r\n    let segmentIndex = 0;\r\n\r\n    const baseUrl = url.substring(0, url.lastIndexOf('/') + 1);\r\n\r\n    // Check if this is a master playlist (contains #EXT-X-STREAM-INF)\r\n    const hasMasterPlaylist = lines.some((line: string) =>\r\n      line.includes('#EXT-X-STREAM-INF'),\r\n    );\r\n\r\n    if (hasMasterPlaylist) {\r\n      console.log(\r\n        'Detected master playlist, looking for best quality stream...',\r\n      );\r\n\r\n      // Find the best quality stream URL\r\n      let bestQualityUrl = null;\r\n      let highestBandwidth = 0;\r\n\r\n      for (let i = 0; i < lines.length; i++) {\r\n        const line = lines[i];\r\n\r\n        if (line.includes('#EXT-X-STREAM-INF')) {\r\n          // Extract bandwidth\r\n          const bandwidthMatch = line.match(/BANDWIDTH=(\\d+)/);\r\n          const bandwidth = bandwidthMatch\r\n            ? parseInt(bandwidthMatch[1], 10)\r\n            : 0;\r\n\r\n          // Get the next line which should be the playlist URL\r\n          if (i + 1 < lines.length) {\r\n            let playlistUrl = lines[i + 1];\r\n            if (\r\n              !playlistUrl.startsWith('http') &&\r\n              !playlistUrl.startsWith('#')\r\n            ) {\r\n              playlistUrl = baseUrl + playlistUrl;\r\n            }\r\n\r\n            // Choose the highest bandwidth stream\r\n            if (bandwidth > highestBandwidth) {\r\n              highestBandwidth = bandwidth;\r\n              bestQualityUrl = playlistUrl;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (bestQualityUrl) {\r\n        console.log(\r\n          'Found best quality stream:',\r\n          bestQualityUrl,\r\n          'with bandwidth:',\r\n          highestBandwidth,\r\n        );\r\n        // Recursively parse the actual playlist\r\n        return await parseM3U8Playlist(bestQualityUrl, headers);\r\n      } else {\r\n        throw new Error('No valid stream found in master playlist');\r\n      }\r\n    }\r\n\r\n    // Parse regular playlist with segments\r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i];\r\n\r\n      if (line.includes('#EXT-X-ENDLIST')) {\r\n        isLive = false;\r\n      } else if (line.includes('#EXTINF:')) {\r\n        const durationMatch = line.match(/#EXTINF:([\\d.]+)/);\r\n        const duration = durationMatch ? parseFloat(durationMatch[1]) : 0;\r\n\r\n        // Next line should be the segment URL\r\n        if (i + 1 < lines.length) {\r\n          let segmentUrl = lines[i + 1];\r\n\r\n          // Skip lines that start with # (comments/metadata)\r\n          if (segmentUrl.startsWith('#')) {\r\n            continue;\r\n          }\r\n\r\n          if (!segmentUrl.startsWith('http')) {\r\n            segmentUrl = baseUrl + segmentUrl;\r\n          }\r\n\r\n          segments.push({\r\n            duration,\r\n            url: segmentUrl,\r\n            index: segmentIndex++,\r\n          });\r\n\r\n          totalDuration += duration;\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log(\r\n      `Parsed ${segments.length} segments, total duration: ${totalDuration}s`,\r\n    );\r\n\r\n    return {\r\n      segments,\r\n      totalDuration,\r\n      isLive,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error parsing M3U8:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst downloadSegment = async (\r\n  segmentUrl: string,\r\n  outputPath: string,\r\n  headers: any = {},\r\n): Promise<void> => {\r\n  if (downloadCancelled) {\r\n    throw new Error('Download cancelled');\r\n  }\r\n\r\n  const response = await axios({\r\n    method: 'GET',\r\n    url: segmentUrl,\r\n    headers,\r\n    responseType: 'arraybuffer',\r\n    timeout: 30000,\r\n  });\r\n\r\n  // Convert ArrayBuffer to base64 string directly\r\n  const arrayBuffer = response.data as ArrayBuffer;\r\n  const uint8Array = new Uint8Array(arrayBuffer);\r\n  const binary = Array.from(uint8Array, byte => String.fromCharCode(byte)).join(\r\n    '',\r\n  );\r\n  const base64 = btoa(binary);\r\n\r\n  await RNFS.appendFile(outputPath, base64, 'base64');\r\n};\r\n\r\nconst mergeSegments = async (\r\n  segmentPaths: string[],\r\n  outputPath: string,\r\n): Promise<void> => {\r\n  // For TS segments, we can simply concatenate them by appending files\r\n  let isFirstFile = true;\r\n\r\n  for (const segmentPath of segmentPaths) {\r\n    if (await RNFS.exists(segmentPath)) {\r\n      const content = await RNFS.readFile(segmentPath, 'base64');\r\n\r\n      if (isFirstFile) {\r\n        await RNFS.writeFile(outputPath, content, 'base64');\r\n        isFirstFile = false;\r\n      } else {\r\n        await RNFS.appendFile(outputPath, content, 'base64');\r\n      }\r\n\r\n      // Clean up segment file\r\n      await RNFS.unlink(segmentPath);\r\n    }\r\n  }\r\n};\r\n\r\nexport const hlsDownloader2 = async ({\r\n  videoUrl,\r\n  path,\r\n  fileName,\r\n  title,\r\n  setDownloadActive,\r\n  setAlreadyDownloaded,\r\n  setDownloadId,\r\n  headers = {},\r\n}: {\r\n  videoUrl: string;\r\n  path: string;\r\n  fileName: string;\r\n  title: string;\r\n  setDownloadActive: (value: boolean) => void;\r\n  setAlreadyDownloaded: (value: boolean) => void;\r\n  setDownloadId: (value: number) => void;\r\n  headers?: any;\r\n}) => {\r\n  downloadCancelled = false;\r\n  currentDownloadId = fileName;\r\n\r\n  // Generate a unique numeric ID for this HLS download\r\n  const hlsJobId = nextHlsId++;\r\n  hlsDownloadMap.set(hlsJobId, fileName);\r\n  setDownloadId(hlsJobId);\r\n\r\n  const tempDir = RNFS.CachesDirectoryPath + '/hls_segments/';\r\n\r\n  try {\r\n    // Ensure temp directory exists\r\n    if (!(await RNFS.exists(tempDir))) {\r\n      await RNFS.mkdir(tempDir);\r\n    }\r\n\r\n    // Parse the M3U8 playlist\r\n    console.log('Parsing M3U8 playlist...');\r\n    const m3u8Data = await parseM3U8Playlist(videoUrl, headers);\r\n\r\n    if (m3u8Data.segments.length === 0) {\r\n      throw new Error('No segments found in playlist');\r\n    }\r\n\r\n    console.log(\r\n      `Found ${m3u8Data.segments.length} segments, total duration: ${m3u8Data.totalDuration}s`,\r\n    );\r\n\r\n    let downloadedSegments = 0;\r\n    const segmentPaths: string[] = [];\r\n    const maxConcurrentDownloads = 10; // Limit concurrent downloads\r\n\r\n    // Download segments in batches\r\n    for (let i = 0; i < m3u8Data.segments.length; i += maxConcurrentDownloads) {\r\n      if (downloadCancelled) {\r\n        throw new Error('Download cancelled by user');\r\n      }\r\n\r\n      const batch = m3u8Data.segments.slice(i, i + maxConcurrentDownloads);\r\n      const batchPromises = batch.map(async segment => {\r\n        const segmentPath = tempDir + `segment_${segment.index}.ts`;\r\n        segmentPaths[segment.index] = segmentPath;\r\n\r\n        try {\r\n          await downloadSegment(segment.url, segmentPath, headers);\r\n          downloadedSegments++;\r\n\r\n          const progress =\r\n            (downloadedSegments / m3u8Data.segments.length) * 100;\r\n\r\n          console.log(\r\n            `Downloaded segment ${segment.index + 1}/${\r\n              m3u8Data.segments.length\r\n            } (${progress.toFixed(1)}%)`,\r\n          );\r\n          await notificationService.showDownloadProgress(\r\n            title,\r\n            fileName,\r\n            progress / 100,\r\n            `Downloaded ${progress.toFixed(1)}%`,\r\n            hlsJobId,\r\n          );\r\n        } catch (error) {\r\n          console.error(`Failed to download segment ${segment.index}:`, error);\r\n          throw error;\r\n        }\r\n      });\r\n\r\n      await Promise.all(batchPromises);\r\n\r\n      // Small delay between batches to avoid overwhelming the server\r\n      if (i + maxConcurrentDownloads < m3u8Data.segments.length) {\r\n        await new Promise(resolve => setTimeout(resolve, 100));\r\n      }\r\n    }\r\n\r\n    if (downloadCancelled) {\r\n      throw new Error('Download cancelled by user');\r\n    }\r\n\r\n    // Merge all segments into final file\r\n    console.log('Merging segments...');\r\n    await notificationService.showDownloadProgress(\r\n      title,\r\n      fileName,\r\n      1,\r\n      'Merging video segments...',\r\n      hlsJobId,\r\n    );\r\n\r\n    await mergeSegments(segmentPaths, path);\r\n\r\n    // Clean up temp directory\r\n    if (await RNFS.exists(tempDir)) {\r\n      await RNFS.unlink(tempDir);\r\n    }\r\n\r\n    if (downloadCancelled) {\r\n      // Clean up the output file if cancelled during merge\r\n      if (await RNFS.exists(path)) {\r\n        await RNFS.unlink(path);\r\n      }\r\n      throw new Error('Download cancelled by user');\r\n    }\r\n\r\n    // Success\r\n    console.log('Download completed successfully');\r\n    setAlreadyDownloaded(true);\r\n    setDownloadActive(false);\r\n\r\n    await notificationService.showDownloadComplete(title, fileName);\r\n  } catch (error) {\r\n    console.error('HLS download failed:', error);\r\n\r\n    // Clean up on error\r\n    setAlreadyDownloaded(false);\r\n    setDownloadActive(false);\r\n\r\n    if (await RNFS.exists(tempDir)) {\r\n      await RNFS.unlink(tempDir);\r\n    }\r\n\r\n    if (await RNFS.exists(path)) {\r\n      await RNFS.unlink(path);\r\n    }\r\n\r\n    const errorMessage = downloadCancelled\r\n      ? 'Download cancelled'\r\n      : `Failed to download ${title}`;\r\n    console.error(errorMessage);\r\n\r\n    if (downloadCancelled) {\r\n      await notificationService.cancelNotification(fileName);\r\n    } else {\r\n      await notificationService.showDownloadFailed(title, fileName);\r\n    }\r\n  } finally {\r\n    currentDownloadId = null;\r\n    // Clean up the mapping\r\n    hlsDownloadMap.delete(hlsJobId);\r\n  }\r\n};\r\n\r\n// Function to cancel ongoing download\r\nexport const cancelHlsDownload = (downloadId: number | string) => {\r\n  // Handle both numeric HLS job IDs and string fileName\r\n  let targetFileName: string | null = null;\r\n\r\n  if (typeof downloadId === 'number') {\r\n    // It's an HLS job ID, get the fileName from mapping\r\n    targetFileName = hlsDownloadMap.get(downloadId) || null;\r\n  } else {\r\n    // It's a fileName directly\r\n    targetFileName = downloadId;\r\n  }\r\n\r\n  if (currentDownloadId === targetFileName) {\r\n    downloadCancelled = true;\r\n    console.log(`Cancelling HLS download: ${targetFileName}`);\r\n  }\r\n};\r\n\r\n// Check if a download is in progress\r\nexport const isHlsDownloadInProgress = (\r\n  downloadId: number | string,\r\n): boolean => {\r\n  let targetFileName: string | null = null;\r\n\r\n  if (typeof downloadId === 'number') {\r\n    targetFileName = hlsDownloadMap.get(downloadId) || null;\r\n  } else {\r\n    targetFileName = downloadId;\r\n  }\r\n\r\n  return currentDownloadId === targetFileName && !downloadCancelled;\r\n};\r\n","size_bytes":11274},"src/lib/m3u8Parcer.ts":{"content":"import axios from 'axios';\r\n\r\nasync function fetchM3U8(url: string) {\r\n  try {\r\n    const response = await axios(url, {\r\n      timeout: 10000,\r\n    });\r\n\r\n    const data = await response.data;\r\n    return data;\r\n  } catch (error) {\r\n    console.log('Failed to fetch the M3U8 file:', error);\r\n  }\r\n}\r\n\r\nfunction parseM3U8(data: string) {\r\n  const lines = data.split('\\n');\r\n  const qualityLinks: {quality: string; url: string}[] = [];\r\n\r\n  lines.forEach((line, index) => {\r\n    if (line.startsWith('#EXT-X-STREAM-INF')) {\r\n      const quality = line.match(/RESOLUTION=\\d+x(\\d+)/);\r\n      const nextLine = lines[index + 1];\r\n      if (quality && nextLine && !nextLine.startsWith('#')) {\r\n        qualityLinks.push({\r\n          quality: quality[1] + 'p',\r\n          url: nextLine,\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  return qualityLinks;\r\n}\r\n\r\nexport async function getQualityLinks(url: string) {\r\n  const m3u8Content = await fetchM3U8(url);\r\n  if (m3u8Content) {\r\n    const qualityLinks = parseM3U8(m3u8Content);\r\n    const baseUrl = url.substring(0, url.lastIndexOf('/') + 1);\r\n    const fullQualityLinks = qualityLinks.map(link => ({\r\n      quality: link.quality,\r\n      url: baseUrl + link.url,\r\n    }));\r\n    console.log('Quality Links:', fullQualityLinks);\r\n    return fullQualityLinks;\r\n  }\r\n  return [];\r\n}\r\n","size_bytes":1318},"src/screens/ScrollList.tsx":{"content":"import {View, Text, TouchableOpacity} from 'react-native';\r\nimport React, {useEffect, useState, useRef} from 'react';\r\nimport {NativeStackScreenProps} from '@react-navigation/native-stack';\r\nimport {HomeStackParamList, SearchStackParamList} from '../App';\r\nimport {Post} from '../lib/providers/types';\r\nimport {Image} from 'react-native';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport {NativeStackNavigationProp} from '@react-navigation/native-stack';\r\nimport useContentStore from '../lib/zustand/contentStore';\r\nimport {MaterialIcons} from '@expo/vector-icons';\r\nimport {settingsStorage} from '../lib/storage';\r\nimport {FlashList} from '@shopify/flash-list';\r\nimport SkeletonLoader from '../components/Skeleton';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport {providerManager} from '../lib/services/ProviderManager';\r\n\r\ntype Props = NativeStackScreenProps<HomeStackParamList, 'ScrollList'>;\r\n\r\nconst ScrollList = ({route}: Props): React.ReactElement => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const navigation =\r\n    useNavigation<NativeStackNavigationProp<SearchStackParamList>>();\r\n  const [posts, setPosts] = useState<Post[]>([]);\r\n  const {filter, providerValue} = route.params;\r\n  const [page, setPage] = useState<number>(1);\r\n  const [isLoading, setIsLoading] = useState<boolean>(true);\r\n  const [isEnd, setIsEnd] = useState<boolean>(false);\r\n  const {provider} = useContentStore(state => state);\r\n  const [viewType, setViewType] = useState<number>(\r\n    settingsStorage.getListViewType(),\r\n  );\r\n  // Add abort controller to cancel API requests when unmounting\r\n  const abortController = useRef<AbortController | null>(null);\r\n  const isMounted = useRef(true);\r\n  const isLoadingMore = useRef(false);\r\n\r\n  // Set up cleanup effect that runs on component unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      isMounted.current = false;\r\n      if (abortController.current) {\r\n        abortController.current.abort();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // Clean up the previous controller if it exists\r\n    if (abortController.current) {\r\n      abortController.current.abort();\r\n    }\r\n\r\n    // Create a new controller for this effect\r\n    abortController.current = new AbortController();\r\n    const signal = abortController.current.signal;\r\n\r\n    const fetchPosts = async () => {\r\n      // Don't fetch if we're already at the end\r\n      if (isEnd) return;\r\n\r\n      try {\r\n        // Prevent concurrent loading calls\r\n        if (isLoadingMore.current) return;\r\n        isLoadingMore.current = true;\r\n\r\n        setIsLoading(true);\r\n\r\n        // Simulate network delay to reduce rapid API calls\r\n        // Remove this in production if not needed\r\n        await new Promise(resolve => setTimeout(resolve, 300));\r\n\r\n        // Skip if component unmounted or request was aborted\r\n        if (!isMounted.current || signal.aborted) return;\r\n\r\n        const getNewPosts = route.params.isSearch\r\n          ? providerManager.getSearchPosts({\r\n              searchQuery: filter,\r\n              page,\r\n              providerValue: providerValue || provider.value,\r\n              signal,\r\n            })\r\n          : providerManager.getPosts({\r\n              filter,\r\n              page,\r\n              providerValue: providerValue || provider.value,\r\n              signal,\r\n            });\r\n\r\n        const newPosts = await getNewPosts;\r\n\r\n        // Skip if component unmounted or request was aborted\r\n        if (!isMounted.current || signal.aborted) return;\r\n\r\n        if (!newPosts || newPosts.length === 0) {\r\n          console.log('end', page);\r\n          setIsEnd(true);\r\n          setIsLoading(false);\r\n          isLoadingMore.current = false;\r\n          return;\r\n        }\r\n\r\n        setPosts(prev => [...prev, ...newPosts]);\r\n      } catch (error) {\r\n        // Skip handling if component unmounted or request was aborted\r\n        if (!isMounted.current || (error as any)?.name === 'AbortError') return;\r\n        console.error('Error fetching posts:', error);\r\n      } finally {\r\n        if (isMounted.current) {\r\n          setIsLoading(false);\r\n          isLoadingMore.current = false;\r\n        }\r\n      }\r\n    };\r\n\r\n    fetchPosts();\r\n  }, [page, route.params, filter, provider.value]);\r\n\r\n  const onEndReached = async () => {\r\n    // Don't trigger more loading if we're already loading or at the end\r\n    if (isLoading || isEnd || isLoadingMore.current) {\r\n      return;\r\n    }\r\n    setIsLoading(true);\r\n    setPage(prevPage => prevPage + 1);\r\n  };\r\n\r\n  // Limit the number of skeletons to prevent unnecessary renders\r\n  const renderSkeletons = () => {\r\n    const skeletonCount = viewType === 1 ? 6 : 3;\r\n    return Array.from({length: skeletonCount}).map((_, i) => (\r\n      <View\r\n        className=\"mx-3 gap-0 flex mb-3 justify-center items-center\"\r\n        key={i}>\r\n        <SkeletonLoader height={150} width={100} />\r\n        <SkeletonLoader height={12} width={97} />\r\n      </View>\r\n    ));\r\n  };\r\n\r\n  return (\r\n    <View className=\"h-full w-full bg-black items-center p-4\">\r\n      <View className=\"w-full px-4 font-semibold my-6 flex-row justify-between items-center\">\r\n        <Text className=\"text-2xl font-bold\" style={{color: primary}}>\r\n          {route.params.title}\r\n        </Text>\r\n        <TouchableOpacity\r\n          onPress={() => {\r\n            const newViewType = viewType === 1 ? 2 : 1;\r\n            setViewType(newViewType);\r\n            settingsStorage.setListViewType(newViewType);\r\n          }}>\r\n          <MaterialIcons\r\n            name={viewType === 1 ? 'view-module' : 'view-list'}\r\n            size={27}\r\n            color=\"white\"\r\n          />\r\n        </TouchableOpacity>\r\n      </View>\r\n      <View className=\"justify-center flex-row w-96 \">\r\n        <FlashList\r\n          estimatedItemSize={300}\r\n          ListFooterComponent={\r\n            <>\r\n              {isLoading && (\r\n                <View\r\n                  className={`flex ${\r\n                    viewType === 1 ? 'flex-row flex-wrap' : 'flex-col'\r\n                  } gap-1 justify-center items-center mb-16`}>\r\n                  {renderSkeletons()}\r\n                </View>\r\n              )}\r\n              <View className=\"h-32\" />\r\n            </>\r\n          }\r\n          data={posts}\r\n          numColumns={viewType === 1 ? 3 : 1}\r\n          key={`view-type-${viewType}`}\r\n          contentContainerStyle={{paddingBottom: 80}}\r\n          keyExtractor={(item, i) => `${item.title}-${i}`}\r\n          renderItem={({item}) => (\r\n            <TouchableOpacity\r\n              className={\r\n                viewType === 1\r\n                  ? 'flex flex-col m-3'\r\n                  : 'flex-row m-3 items-center'\r\n              }\r\n              onPress={() =>\r\n                navigation.navigate('Info', {\r\n                  link: item.link,\r\n                  provider: route.params.providerValue || provider.value,\r\n                  poster: item?.image,\r\n                })\r\n              }>\r\n              <Image\r\n                className=\"rounded-md\"\r\n                source={{\r\n                  uri:\r\n                    item.image ||\r\n                    'https://placehold.jp/24/363636/ffffff/100x150.png?text=Vega',\r\n                }}\r\n                style={\r\n                  viewType === 1\r\n                    ? {width: 100, height: 150}\r\n                    : {width: 70, height: 100}\r\n                }\r\n              />\r\n              <Text\r\n                className={\r\n                  viewType === 1\r\n                    ? 'text-white text-center truncate w-24 text-xs'\r\n                    : 'text-white ml-3 truncate w-72 font-semibold text-base'\r\n                }>\r\n                {item?.title?.length > 24 && viewType === 1\r\n                  ? item.title.slice(0, 24) + '...'\r\n                  : item.title}\r\n              </Text>\r\n            </TouchableOpacity>\r\n          )}\r\n          onEndReached={onEndReached}\r\n          onEndReachedThreshold={0.5}\r\n        />\r\n        {!isLoading && posts.length === 0 ? (\r\n          <View className=\"w-full h-full flex items-center justify-center\">\r\n            <Text className=\"text-white text-center font-semibold text-lg\">\r\n              No Content Found\r\n            </Text>\r\n          </View>\r\n        ) : null}\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default ScrollList;\r\n","size_bytes":8341},"src/screens/Search.tsx":{"content":"import {View, Text, FlatList} from 'react-native';\r\nimport React, {useState, useEffect, useCallback} from 'react';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport {NativeStackNavigationProp} from '@react-navigation/native-stack';\r\nimport {SearchStackParamList} from '../App';\r\nimport {MaterialIcons, Ionicons, Feather} from '@expo/vector-icons';\r\nimport {TextInput} from 'react-native';\r\nimport {TouchableOpacity} from 'react-native';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport {MMKV} from '../lib/Mmkv';\r\nimport {SafeAreaView} from 'react-native-safe-area-context';\r\nimport Animated, {\r\n  FadeInDown,\r\n  SlideInRight,\r\n  Layout,\r\n} from 'react-native-reanimated';\r\nimport {searchOMDB} from '../lib/services/omdb';\r\nimport debounce from 'lodash/debounce';\r\nimport {OMDBResult} from '../types/omdb';\r\n\r\nconst MAX_VISIBLE_RESULTS = 15; // Limit number of animated items to prevent excessive callbacks\r\nconst MAX_HISTORY_ITEMS = 30; // Maximum number of history items to store\r\n\r\nconst Search = () => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const navigation =\r\n    useNavigation<NativeStackNavigationProp<SearchStackParamList>>();\r\n  const [searchText, setSearchText] = useState('');\r\n  const [isFocused, setIsFocused] = useState(false);\r\n  const [searchHistory, setSearchHistory] = useState<string[]>(\r\n    MMKV.getArray<string>('searchHistory') || [],\r\n  );\r\n  const [searchResults, setSearchResults] = useState<OMDBResult[]>([]);\r\n\r\n  const debouncedSearch = useCallback(\r\n    debounce(async (text: string) => {\r\n      if (text.length >= 2) {\r\n        setSearchResults([]); // Clear previous results\r\n        const results = await searchOMDB(text);\r\n        if (results.length > 0) {\r\n          // Remove duplicates based on imdbID\r\n          const uniqueResults = results.reduce((acc, current) => {\r\n            const x = acc.find(\r\n              (item: OMDBResult) => item.imdbID === current.imdbID,\r\n            );\r\n            if (!x) {\r\n              return acc.concat([current]);\r\n            } else {\r\n              return acc;\r\n            }\r\n          }, [] as OMDBResult[]);\r\n\r\n          // Limit the number of results to prevent excessive animations\r\n          setSearchResults(uniqueResults.slice(0, MAX_VISIBLE_RESULTS));\r\n        }\r\n      } else {\r\n        setSearchResults([]);\r\n      }\r\n    }, 300), // Reduced debounce time for better responsiveness\r\n    [],\r\n  );\r\n\r\n  useEffect(() => {\r\n    debouncedSearch(searchText);\r\n    return () => {\r\n      debouncedSearch.cancel();\r\n    };\r\n  }, [searchText, debouncedSearch]);\r\n\r\n  const handleSearch = (text: string) => {\r\n    if (text.trim()) {\r\n      // Save to search history\r\n      const prevSearches = MMKV.getArray<string>('searchHistory') || [];\r\n      if (!prevSearches.includes(text.trim())) {\r\n        const newSearches = [text.trim(), ...prevSearches].slice(\r\n          0,\r\n          MAX_HISTORY_ITEMS,\r\n        );\r\n        MMKV.setArray('searchHistory', newSearches);\r\n        setSearchHistory(newSearches);\r\n      }\r\n\r\n      navigation.navigate('SearchResults', {\r\n        filter: text.trim(),\r\n      });\r\n    }\r\n  };\r\n\r\n  const removeHistoryItem = (search: string) => {\r\n    const newSearches = searchHistory.filter(item => item !== search);\r\n    MMKV.setArray('searchHistory', newSearches);\r\n    setSearchHistory(newSearches);\r\n  };\r\n\r\n  const clearHistory = () => {\r\n    MMKV.setArray('searchHistory', []);\r\n    setSearchHistory([]);\r\n  };\r\n\r\n  // Conditionally render animations based on state\r\n  const AnimatedContainer = Animated.View;\r\n\r\n  return (\r\n    <SafeAreaView className=\"flex-1 bg-black\">\r\n      {/* Title Section */}\r\n      <AnimatedContainer\r\n        entering={FadeInDown.springify()}\r\n        layout={Layout.springify()}\r\n        className=\"px-4 pt-4\">\r\n        <Text className=\"text-white text-xl font-bold mb-3\">Search</Text>\r\n        <View className=\"flex-row items-center space-x-3 mb-2\">\r\n          <View className=\"flex-1\">\r\n            <View className=\"overflow-hidden rounded-xl bg-[#141414] shadow-lg shadow-black/50\">\r\n              <View className=\"px-3 py-3\">\r\n                <View className=\"flex-row items-center\">\r\n                  <MaterialIcons\r\n                    name=\"search\"\r\n                    size={24}\r\n                    color={isFocused ? primary : '#666'}\r\n                  />\r\n                  <TextInput\r\n                    className=\"flex-1 text-white text-base ml-3\"\r\n                    placeholder=\"Search anime...\"\r\n                    placeholderTextColor=\"#666\"\r\n                    value={searchText}\r\n                    onChangeText={setSearchText}\r\n                    onFocus={() => setIsFocused(true)}\r\n                    onBlur={() => setIsFocused(false)}\r\n                    onSubmitEditing={e => handleSearch(e.nativeEvent.text)}\r\n                    returnKeyType=\"search\"\r\n                  />\r\n                  {searchText.length > 0 && (\r\n                    <TouchableOpacity\r\n                      onPress={() => setSearchText('')}\r\n                      className=\"bg-gray-800/50 rounded-full p-2\">\r\n                      <Feather name=\"x\" size={18} color=\"#999\" />\r\n                    </TouchableOpacity>\r\n                  )}\r\n                </View>\r\n              </View>\r\n            </View>\r\n          </View>\r\n        </View>\r\n      </AnimatedContainer>\r\n\r\n      {/* Search Results */}\r\n      <AnimatedContainer\r\n        layout={Layout.springify()}\r\n        className=\"flex-1\"\r\n        key={\r\n          searchResults.length > 0\r\n            ? 'results'\r\n            : searchHistory.length > 0\r\n            ? 'history'\r\n            : 'empty'\r\n        }>\r\n        {searchResults.length > 0 ? (\r\n          <FlatList\r\n            data={searchResults}\r\n            keyExtractor={item => item.imdbID.toString()}\r\n            renderItem={({item}) => (\r\n              <View className=\"px-4\">\r\n                <TouchableOpacity\r\n                  className=\"py-3 border-b border-white/10\"\r\n                  onPress={() => {\r\n                    const searchTitle = item.Title;\r\n                    // Save to search history\r\n                    const prevSearches =\r\n                      MMKV.getArray<string>('searchHistory') || [];\r\n                    if (searchTitle && !prevSearches.includes(searchTitle)) {\r\n                      const newSearches = [searchTitle, ...prevSearches].slice(\r\n                        0,\r\n                        MAX_HISTORY_ITEMS,\r\n                      );\r\n                      MMKV.setArray('searchHistory', newSearches);\r\n                      setSearchHistory(newSearches);\r\n                    }\r\n                    navigation.navigate('SearchResults', {\r\n                      filter: searchTitle,\r\n                    });\r\n                  }}>\r\n                  <View className=\"flex-row items-center\">\r\n                    <MaterialIcons\r\n                      name=\"search\"\r\n                      size={20}\r\n                      color=\"#666\"\r\n                      style={{marginRight: 12}}\r\n                    />\r\n                    <View>\r\n                      <Text className=\"text-white text-base\">{item.Title}</Text>\r\n                      <Text className=\"text-white/50 text-xs\">\r\n                        {item.Type === 'series' ? 'TV Show' : 'Movie'} •{' '}\r\n                        {item.Year}\r\n                      </Text>\r\n                    </View>\r\n                  </View>\r\n                </TouchableOpacity>\r\n              </View>\r\n            )}\r\n            contentContainerStyle={{paddingTop: 4}}\r\n            showsVerticalScrollIndicator={false}\r\n          />\r\n        ) : searchHistory.length > 0 ? (\r\n          <AnimatedContainer\r\n            entering={SlideInRight.springify()}\r\n            layout={Layout.springify()}\r\n            className=\"px-4 flex-1\">\r\n            <View className=\"flex-row items-center justify-between mb-2\">\r\n              <Text className=\"text-white/90 text-base font-semibold\">\r\n                Recent Searches\r\n              </Text>\r\n              <TouchableOpacity\r\n                onPress={clearHistory}\r\n                className=\"bg-red-500/10 rounded-full px-2 py-0.5\">\r\n                <Text className=\"text-red-500 text-xs\">Clear All</Text>\r\n              </TouchableOpacity>\r\n            </View>\r\n\r\n            <FlatList\r\n              data={searchHistory}\r\n              keyExtractor={(item, index) => `history-${index}`}\r\n              showsVerticalScrollIndicator={false}\r\n              contentContainerStyle={{paddingBottom: 20}}\r\n              renderItem={({item: search}) => (\r\n                <View className=\"bg-[#141414] rounded-lg p-3 mb-2 flex-row justify-between items-center border border-white/5\">\r\n                  <TouchableOpacity\r\n                    onPress={() => handleSearch(search)}\r\n                    className=\"flex-row flex-1 items-center space-x-2\">\r\n                    <View className=\"bg-white/10 rounded-full p-1.5\">\r\n                      <Ionicons name=\"time-outline\" size={16} color={primary} />\r\n                    </View>\r\n                    <Text className=\"text-white text-sm ml-2\">{search}</Text>\r\n                  </TouchableOpacity>\r\n                  <TouchableOpacity\r\n                    onPress={() => removeHistoryItem(search)}\r\n                    className=\"bg-white/5 rounded-full p-1.5\">\r\n                    <Feather name=\"x\" size={14} color=\"#999\" />\r\n                  </TouchableOpacity>\r\n                </View>\r\n              )}\r\n            />\r\n          </AnimatedContainer>\r\n        ) : (\r\n          // Empty State - Only show when no history and no results\r\n          <AnimatedContainer\r\n            layout={Layout.springify()}\r\n            className=\"items-center justify-center flex-1\">\r\n            <View className=\"bg-white/5 rounded-full p-6 mb-4\">\r\n              <Ionicons name=\"search\" size={32} color={primary} />\r\n            </View>\r\n            <Text className=\"text-white/70 text-base text-center\">\r\n              Search for your favorite anime\r\n            </Text>\r\n            <Text className=\"text-white/40 text-sm text-center mt-1\">\r\n              Your recent searches will appear here\r\n            </Text>\r\n          </AnimatedContainer>\r\n        )}\r\n      </AnimatedContainer>\r\n    </SafeAreaView>\r\n  );\r\n};\r\n\r\nexport default Search;\r\n","size_bytes":10345},"src/screens/SearchResults.tsx":{"content":"import {\r\n  SafeAreaView,\r\n  ScrollView,\r\n  ActivityIndicator,\r\n  Text,\r\n  View,\r\n} from 'react-native';\r\nimport Slider from '../components/Slider';\r\nimport React, {useEffect, useState, useRef, useCallback, useMemo} from 'react';\r\nimport {NativeStackScreenProps} from '@react-navigation/native-stack';\r\nimport {SearchStackParamList} from '../App';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport {providerManager} from '../lib/services/ProviderManager';\r\nimport useContentStore from '../lib/zustand/contentStore';\r\n\r\ntype Props = NativeStackScreenProps<SearchStackParamList, 'SearchResults'>;\r\n\r\ninterface SearchPageData {\r\n  title: string;\r\n  Posts: any[];\r\n  filter: string;\r\n  providerValue: string;\r\n  value: string;\r\n  name: string;\r\n}\r\n\r\nconst SearchResults = ({route}: Props): React.ReactElement => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const {installedProviders} = useContentStore(state => state);\r\n  const [searchData, setSearchData] = useState<SearchPageData[]>([]);\r\n  const [emptyResults, setEmptyResults] = useState<SearchPageData[]>([]);\r\n\r\n  const trueLoading = useMemo(\r\n    () =>\r\n      installedProviders.map(item => ({\r\n        name: item.display_name,\r\n        value: item.value,\r\n        isLoading: true,\r\n      })),\r\n    [installedProviders],\r\n  );\r\n\r\n  const [loading, setLoading] = useState(trueLoading);\r\n  const abortController = useRef<AbortController | null>(null);\r\n\r\n  const updateSearchData = useCallback((newData: SearchPageData) => {\r\n    setSearchData(prev => [...prev, newData]);\r\n  }, []);\r\n\r\n  const updateEmptyResults = useCallback((newData: SearchPageData) => {\r\n    setEmptyResults(prev => [...prev, newData]);\r\n  }, []);\r\n\r\n  const updateLoading = useCallback(\r\n    (value: string, updates: Partial<{isLoading: boolean; error: boolean}>) => {\r\n      setLoading(prev =>\r\n        prev.map(i => (i.value === value ? {...i, ...updates} : i)),\r\n      );\r\n    },\r\n    [],\r\n  );\r\n\r\n  const isAllLoaded = useMemo(\r\n    () => loading.every(i => !i.isLoading),\r\n    [loading],\r\n  );\r\n\r\n  useEffect(() => {\r\n    // Clean up previous controller if exists\r\n    if (abortController.current) {\r\n      abortController.current.abort();\r\n    }\r\n\r\n    // Create a new controller for this effect\r\n    abortController.current = new AbortController();\r\n    const signal = abortController.current.signal;\r\n\r\n    // Reset states when component mounts or filter changes\r\n    setSearchData([]);\r\n    setEmptyResults([]);\r\n    setLoading(trueLoading);\r\n\r\n    const fetchPromises: Promise<void>[] = [];\r\n\r\n    const getSearchResults = () => {\r\n      installedProviders.forEach(item => {\r\n        const fetchPromise = (async () => {\r\n          try {\r\n            const data = await providerManager.getSearchPosts({\r\n              searchQuery: route.params.filter,\r\n              page: 1,\r\n              providerValue: item.value,\r\n              signal: signal,\r\n            });\r\n\r\n            // Skip updating state if request was aborted\r\n            if (signal.aborted) return;\r\n\r\n            if (data && data.length > 0) {\r\n              const newData = {\r\n                title: item.display_name,\r\n                Posts: data,\r\n                filter: route.params.filter,\r\n                providerValue: item.value,\r\n                value: item.value,\r\n                name: item.display_name,\r\n              };\r\n              updateSearchData(newData);\r\n            } else {\r\n              const newData = {\r\n                title: item.display_name,\r\n                Posts: data || [],\r\n                filter: route.params.filter,\r\n                providerValue: item.value,\r\n                value: item.value,\r\n                name: item.display_name,\r\n              };\r\n              updateEmptyResults(newData);\r\n            }\r\n\r\n            updateLoading(item.value, {isLoading: false});\r\n          } catch (error) {\r\n            if (signal.aborted) return;\r\n\r\n            console.error(\r\n              `Error fetching data for ${item.display_name}:`,\r\n              error,\r\n            );\r\n            updateLoading(item.value, {isLoading: false, error: true});\r\n          }\r\n        })();\r\n\r\n        fetchPromises.push(fetchPromise);\r\n      });\r\n\r\n      // Use Promise.allSettled to handle all promises regardless of their outcome\r\n      return Promise.allSettled(fetchPromises);\r\n    };\r\n\r\n    getSearchResults();\r\n\r\n    return () => {\r\n      // Cleanup function: abort any ongoing API requests\r\n      if (abortController.current) {\r\n        abortController.current.abort();\r\n        abortController.current = null;\r\n      }\r\n    };\r\n  }, [\r\n    route.params.filter,\r\n    trueLoading,\r\n    installedProviders,\r\n    updateSearchData,\r\n    updateEmptyResults,\r\n    updateLoading,\r\n  ]);\r\n\r\n  const renderSlider = useCallback(\r\n    (item: SearchPageData, index: number, isEmptyResult: boolean = false) => {\r\n      const loadingState = loading.find(i => i.value === item.value);\r\n      const posts = isEmptyResult\r\n        ? emptyResults.find(i => i.providerValue === item.value)?.Posts || []\r\n        : searchData.find(i => i.providerValue === item.value)?.Posts || [];\r\n\r\n      return (\r\n        <Slider\r\n          isLoading={loadingState?.isLoading || false}\r\n          key={`${item.value}-${isEmptyResult ? 'empty' : 'data'}`}\r\n          title={item.name}\r\n          posts={posts}\r\n          filter={route.params.filter}\r\n          providerValue={item.value}\r\n          isSearch={true}\r\n        />\r\n      );\r\n    },\r\n    [loading, searchData, emptyResults, route.params.filter],\r\n  );\r\n\r\n  const searchSliders = useMemo(\r\n    () => searchData.map((item, index) => renderSlider(item, index, false)),\r\n    [searchData, renderSlider],\r\n  );\r\n\r\n  const emptySliders = useMemo(\r\n    () => emptyResults.map((item, index) => renderSlider(item, index, true)),\r\n    [emptyResults, renderSlider],\r\n  );\r\n\r\n  return (\r\n    <SafeAreaView className=\"bg-black h-full w-full\">\r\n      <ScrollView showsVerticalScrollIndicator={false}>\r\n        <View className=\"mt-14 px-4 flex flex-row justify-between items-center gap-x-3\">\r\n          <Text className=\"text-white text-2xl font-semibold \">\r\n            {isAllLoaded ? 'Searched for' : 'Searching for'}{' '}\r\n            <Text style={{color: primary}}>\"{route?.params?.filter}\"</Text>\r\n          </Text>\r\n          {!isAllLoaded && (\r\n            <View className=\"flex justify-center items-center h-20\">\r\n              <ActivityIndicator\r\n                size=\"small\"\r\n                color={primary}\r\n                animating={true}\r\n              />\r\n            </View>\r\n          )}\r\n        </View>\r\n\r\n        <View className=\"px-4\">\r\n          {searchSliders}\r\n          {emptySliders}\r\n        </View>\r\n        <View className=\"h-16\" />\r\n      </ScrollView>\r\n    </SafeAreaView>\r\n  );\r\n};\r\n\r\nexport default SearchResults;\r\n","size_bytes":6827},"src/screens/WatchHistory.tsx":{"content":"import {\n  View,\n  Text,\n  TouchableOpacity,\n  Image,\n  StatusBar,\n  Platform,\n} from 'react-native';\nimport React, {useEffect, useState} from 'react';\nimport useWatchHistoryStore from '../lib/zustand/watchHistrory';\nimport {FlashList} from '@shopify/flash-list';\nimport {NativeStackScreenProps} from '@react-navigation/native-stack';\nimport {WatchHistoryStackParamList} from '../App';\nimport MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';\nimport useThemeStore from '../lib/zustand/themeStore';\nimport {mainStorage} from '../lib/storage';\n\ntype Props = NativeStackScreenProps<WatchHistoryStackParamList, 'WatchHistory'>;\nconst WatchHistory = ({navigation}: Props) => {\n  const {primary} = useThemeStore(state => state);\n  const {history, clearHistory} = useWatchHistoryStore(state => state);\n  const [progressData, setProgressData] = useState<Record<string, number>>({});\n\n  // Filter out duplicates by link, keeping only the most recent entry\n  const uniqueHistory = React.useMemo(() => {\n    const seen = new Set();\n    return history.filter(item => {\n      if (seen.has(item.link)) {\n        return false;\n      }\n      seen.add(item.link);\n      return true;\n    });\n  }, [history]);\n  // Load all progress data when component mounts\n  useEffect(() => {\n    const loadProgressData = () => {\n      const progressMap: Record<string, number> = {};\n      uniqueHistory.forEach(item => {\n        try {\n          // First try to get the dedicated watch history progress\n          // Use the infoUrl or link as the key, matching Player.tsx\n          const historyKey = item.link;\n          const historyProgressKey = `watch_history_progress_${historyKey}`;\n          const storedProgress = mainStorage.getString(historyProgressKey);\n          // Log what we're looking for and what we found\n          console.log(\n            `Looking for progress: ${historyProgressKey}`,\n            storedProgress ? 'FOUND' : 'NOT FOUND',\n          );\n\n          if (storedProgress) {\n            const parsed = JSON.parse(storedProgress);\n            console.log(`Progress data for ${item.title}:`, {\n              percentage: parsed.percentage?.toFixed(1) + '%',\n              currentTime: parsed.currentTime?.toFixed(1),\n              duration: parsed.duration?.toFixed(1),\n              updatedAt: new Date(parsed.updatedAt).toLocaleTimeString(),\n            });\n            if (parsed.percentage) {\n              progressMap[item.link] = Math.min(\n                Math.max(parsed.percentage, 0),\n                100,\n              );\n              return;\n            } else if (parsed.currentTime && parsed.duration) {\n              const percentage = (parsed.currentTime / parsed.duration) * 100;\n              progressMap[item.link] = Math.min(Math.max(percentage, 0), 100);\n              return;\n            }\n          }\n          // Try episode-specific key if this item has an episodeTitle\n          if (item.episodeTitle) {\n            const episodeKey = `watch_history_progress_${historyKey}_${item.episodeTitle.replace(\n              /\\s+/g,\n              '_',\n            )}`;\n            const episodeData = mainStorage.getString(episodeKey);\n            if (episodeData) {\n              const parsed = JSON.parse(episodeData);\n              if (parsed.percentage) {\n                progressMap[item.link] = Math.min(\n                  Math.max(parsed.percentage, 0),\n                  100,\n                );\n                return;\n              }\n            }\n          }\n\n          // Fall back to standard video position cache\n          const cachedProgress = mainStorage.getString(item.link);\n          if (cachedProgress) {\n            const parsed = JSON.parse(cachedProgress);\n            if (parsed.position && parsed.duration) {\n              const percentage = (parsed.position / parsed.duration) * 100;\n              progressMap[item.link] = Math.min(Math.max(percentage, 0), 100);\n              return;\n            }\n          }\n\n          // Use the progress from history item itself as last resort\n          if (item.currentTime && item.duration) {\n            const percentage = (item.currentTime / item.duration) * 100;\n            progressMap[item.link] = Math.min(Math.max(percentage, 0), 100);\n            return;\n          }\n        } catch (e) {\n          console.error('Error processing progress for item:', item.title, e);\n        }\n      });\n      console.log('Final progress data loaded:', progressMap);\n      setProgressData(progressMap);\n    };\n\n    loadProgressData();\n  }, [uniqueHistory]);\n\n  const handleNavigateToInfo = (item: any) => {\n    try {\n      // Parse the link if it's a JSON string\n      let linkData = item.link;\n      if (typeof item.link === 'string' && item.link.startsWith('{')) {\n        try {\n          linkData = JSON.parse(item.link);\n        } catch (e) {\n          console.error('Failed to parse link:', e);\n        }\n      }\n\n      // Simple direct navigation to Info screen\n      navigation.navigate('Info', {\n        link: linkData,\n        provider: item.provider || 'multiStream',\n        poster: item.image || '',\n      });\n    } catch (error) {\n      console.error('Navigation error:', error);\n    }\n  };\n\n  return (\n    <View className=\"flex-1 bg-black\">\n      <StatusBar\n        translucent\n        backgroundColor=\"transparent\"\n        barStyle=\"light-content\"\n      />\n\n      <View\n        className=\"w-full bg-black\"\n        style={{\n          paddingTop: Platform.OS === 'android' ? StatusBar.currentHeight : 0,\n        }}\n      />\n\n      <View className=\"flex-row justify-between items-center p-4\">\n        <Text className=\"text-white text-2xl font-bold\">Watch History</Text>\n        {uniqueHistory.length > 0 && (\n          <TouchableOpacity\n            onPress={() => clearHistory()}\n            className=\"bg-white/10 px-3 py-1 rounded-full\">\n            <Text className=\"text-white\">Clear</Text>\n          </TouchableOpacity>\n        )}\n      </View>\n\n      <FlashList\n        data={uniqueHistory}\n        estimatedItemSize={150}\n        numColumns={3}\n        ListEmptyComponent={() => (\n          <View className=\"flex-1 justify-center items-center mt-10\">\n            <MaterialCommunityIcons name=\"history\" size={80} color={primary} />\n            <Text className=\"text-white/70 text-base mt-4\">\n              No watch history\n            </Text>\n          </View>\n        )}\n        renderItem={({item}) => {\n          // Get the progress for this item\n          const progress = progressData[item.link] || 0;\n\n          return (\n            <View className=\"flex-1 m-1\">\n              <TouchableOpacity\n                onPress={() => handleNavigateToInfo(item)}\n                activeOpacity={0.8}>\n                <View className=\"relative overflow-hidden\">\n                  <Image\n                    source={{uri: item.image}}\n                    className=\"w-full aspect-[2/3] rounded-lg\"\n                  />\n\n                  {/* Enhanced Progress Bar */}\n                  <View\n                    className=\"absolute bottom-0 left-0 right-0 h-2\"\n                    style={{\n                      backgroundColor: 'rgba(0,0,0,0.6)',\n                      zIndex: 10,\n                    }}>\n                    {/* Progress bar fill with gradient effect */}\n                    <View\n                      style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        height: '100%',\n                        width: `${progress}%`,\n                        backgroundColor: primary,\n                        zIndex: 20,\n                        shadowColor: primary,\n                        shadowOffset: {width: 0, height: 0},\n                        shadowOpacity: 0.5,\n                        shadowRadius: 3,\n                        elevation: 5,\n                      }}\n                    />\n                  </View>\n\n                  {/* Overlay gradient for better text readability */}\n                  {progress > 0 && (\n                    <View\n                      className=\"absolute bottom-0 left-0 right-0 h-16\"\n                      style={{\n                        backgroundColor: 'rgba(0,0,0,0.8)',\n                        zIndex: 10,\n                      }}\n                    />\n                  )}\n                  {/* IMPROVED percentage indicator with more visible fill */}\n                  {progress > 0 && progress < 100 && (\n                    <View\n                      className=\"absolute bottom-3 right-2\"\n                      style={{\n                        zIndex: 15,\n                      }}>\n                      {/* Container with fixed width for consistent size */}\n                      <View\n                        style={{\n                          width: 45, // Fixed width for consistent sizing\n                          height: 18, // Fixed height\n                          backgroundColor: 'rgba(0,0,0,0.7)',\n                          borderRadius: 9,\n                          overflow: 'hidden',\n                          borderLeftWidth: 2,\n                          borderLeftColor: primary,\n                          flexDirection: 'row', // For horizontal layout\n                          alignItems: 'center', // Center text vertically\n                        }}>\n                        {/* More visible fill with primary color */}\n                        <View\n                          style={{\n                            position: 'absolute',\n                            left: 0,\n                            top: 0,\n                            bottom: 0,\n                            width: `${progress}%`,\n                            backgroundColor: `${primary}CC`, // More opaque primary color (80%)\n                          }}\n                        />\n\n                        {/* Percentage text always centered */}\n                        <Text\n                          className=\"text-white text-[10px] font-medium w-full text-center\"\n                          style={{\n                            textShadowColor: 'rgba(0,0,0,0.9)',\n                            textShadowRadius: 3,\n                            textShadowOffset: {width: 0, height: 0},\n                            zIndex: 20, // Ensure text is on top\n                          }}>\n                          {Math.round(progress)}%\n                        </Text>\n                      </View>\n                    </View>\n                  )}\n\n                  {/* Checkmark overlay when progress is 100% */}\n                  {progress >= 100 && (\n                    <View\n                      className=\"absolute top-2 right-2 p-1 rounded-full\"\n                      style={{\n                        backgroundColor: 'rgba(0,0,0,0.6)',\n                        borderWidth: 1.5,\n                        borderColor: primary,\n                        zIndex: 15,\n                      }}>\n                      <MaterialCommunityIcons\n                        name=\"check-circle\"\n                        size={18}\n                        color={primary}\n                      />\n                    </View>\n                  )}\n                </View>\n\n                <Text numberOfLines={2} className=\"text-white text-sm mt-1\">\n                  {item.title}\n                </Text>\n                {item.episodeTitle && (\n                  <Text numberOfLines={1} className=\"text-white/60 text-xs\">\n                    {item.episodeTitle}\n                  </Text>\n                )}\n              </TouchableOpacity>\n            </View>\n          );\n        }}\n      />\n    </View>\n  );\n};\n\nexport default WatchHistory;\n","size_bytes":11667},"src/screens/WatchList.tsx":{"content":"import {View, Text, Platform, Image, Dimensions, FlatList} from 'react-native';\r\nimport React from 'react';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport {WatchListStackParamList} from '../App';\r\nimport {NativeStackNavigationProp} from '@react-navigation/native-stack';\r\nimport {TouchableOpacity} from 'react-native';\r\nimport useThemeStore from '../lib/zustand/themeStore';\r\nimport useWatchListStore from '../lib/zustand/watchListStore';\r\nimport MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';\r\nimport {StatusBar} from 'expo-status-bar';\r\n\r\nconst WatchList = () => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const navigation =\r\n    useNavigation<NativeStackNavigationProp<WatchListStackParamList>>();\r\n  const {watchList} = useWatchListStore(state => state);\r\n\r\n  // Calculate how many items can fit per row\r\n  const screenWidth = Dimensions.get('window').width;\r\n  const containerPadding = 12; // from the px-3 class (3*4=12)\r\n  const itemSpacing = 10;\r\n\r\n  // Available width for the grid\r\n  const availableWidth = screenWidth - containerPadding * 2;\r\n\r\n  // Determine number of columns and adjusted item width\r\n  const numColumns = Math.floor(\r\n    (availableWidth + itemSpacing) / (100 + itemSpacing),\r\n  );\r\n\r\n  // Calculate the actual item width to fill the space exactly\r\n  const itemWidth =\r\n    (availableWidth - itemSpacing * (numColumns - 1)) / numColumns;\r\n\r\n  // Render each grid item\r\n  const renderItem = ({item, index}: {item: any; index: number}) => (\r\n    <TouchableOpacity\r\n      key={item.link + index}\r\n      onPress={() =>\r\n        navigation.navigate('Info', {\r\n          link: item.link,\r\n          provider: item.provider,\r\n          poster: item.poster,\r\n        })\r\n      }\r\n      style={{\r\n        width: itemWidth,\r\n        marginBottom: 16,\r\n      }}>\r\n      <View className=\"relative overflow-hidden\">\r\n        <Image\r\n          className=\"rounded-xl\"\r\n          resizeMode=\"cover\"\r\n          style={{\r\n            width: itemWidth,\r\n            height: 155,\r\n            borderRadius: 10,\r\n          }}\r\n          source={{uri: item.poster}}\r\n        />\r\n        <Text\r\n          className=\"text-white text-xs truncate text-center mt-1\"\r\n          style={{maxWidth: itemWidth}}\r\n          numberOfLines={1}>\r\n          {item.title}\r\n        </Text>\r\n      </View>\r\n    </TouchableOpacity>\r\n  );\r\n\r\n  return (\r\n    <View className=\"flex-1 bg-black justify-center items-center\">\r\n      <StatusBar translucent backgroundColor=\"transparent\" />\r\n\r\n      <View\r\n        className=\"w-full bg-black\"\r\n        style={{\r\n          paddingTop: Platform.OS === 'android' ? 15 : 0, // Adjust for Android status bar height\r\n        }}\r\n      />\r\n\r\n      <View className=\"flex-1 w-full px-3\">\r\n        <Text\r\n          className=\"text-2xl text-center font-bold mb-6 mt-4\"\r\n          style={{color: primary}}>\r\n          Watchlist\r\n        </Text>\r\n\r\n        {watchList.length > 0 ? (\r\n          <FlatList\r\n            data={watchList}\r\n            renderItem={renderItem}\r\n            keyExtractor={(item, index) => item.link + index}\r\n            numColumns={numColumns}\r\n            columnWrapperStyle={{\r\n              gap: itemSpacing,\r\n              justifyContent: 'flex-start',\r\n            }}\r\n            contentContainerStyle={{\r\n              paddingBottom: 50,\r\n            }}\r\n            showsVerticalScrollIndicator={false}\r\n          />\r\n        ) : (\r\n          <View className=\"flex-1\">\r\n            <View className=\"items-center justify-center mt-20 mb-12\">\r\n              <MaterialCommunityIcons\r\n                name=\"playlist-remove\"\r\n                size={80}\r\n                color={primary}\r\n              />\r\n              <Text className=\"text-white/70 text-base mt-4 text-center\">\r\n                Your WatchList is empty\r\n              </Text>\r\n            </View>\r\n          </View>\r\n        )}\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default WatchList;\r\n","size_bytes":3968},"src/screens/WebView.tsx":{"content":"import {View, Text, SafeAreaView, Linking} from 'react-native';\r\nimport React from 'react';\r\nimport {WebView} from 'react-native-webview';\r\nimport {NativeStackScreenProps} from '@react-navigation/native-stack';\r\nimport {HomeStackParamList} from '../App';\r\nimport {MaterialIcons} from '@expo/vector-icons';\r\n\r\ntype Props = NativeStackScreenProps<HomeStackParamList, 'Webview'>;\r\n\r\nconst Webview = ({route, navigation}: Props) => {\r\n  return (\r\n    <SafeAreaView className=\"bg-black w-full h-full\">\r\n      <View className=\"bg-black w-full mt-6 h-16 flex flex-row justify-between p-3 items-center\">\r\n        <Text className=\"text-white text-lg font-bold\">Webview</Text>\r\n        <View className=\"flex flex-row items-center gap-5\">\r\n          <MaterialIcons\r\n            name=\"open-in-browser\"\r\n            size={24}\r\n            color=\"white\"\r\n            onPress={() => {\r\n              Linking.openURL(route.params.link);\r\n            }}\r\n          />\r\n          <MaterialIcons\r\n            name=\"close\"\r\n            size={24}\r\n            color=\"white\"\r\n            onPress={() => {\r\n              navigation.goBack();\r\n            }}\r\n          />\r\n        </View>\r\n      </View>\r\n      <WebView\r\n        // javaScriptCanOpenWindowsAutomatically={false}\r\n        javaScriptEnabled={false}\r\n        source={{uri: route.params.link}}\r\n      />\r\n    </SafeAreaView>\r\n  );\r\n};\r\n\r\nexport default Webview;\r\n","size_bytes":1402},"src/types/omdb.ts":{"content":"export interface OMDBResult {\n  Title: string;\n  Year: string;\n  imdbID: string;\n  Type: 'movie' | 'series' | 'episode';\n  Poster: string;\n}\n\nexport interface OMDBResponse {\n  Search: OMDBResult[];\n  totalResults: string;\n  Response: string;\n}\n","size_bytes":244},"src/lib/file/getStoragePermission.ts":{"content":"import {Platform, PermissionsAndroid, Alert} from 'react-native';\r\n\r\nexport default async function requestStoragePermission() {\r\n  try {\r\n    console.log('requesting storage permission', Platform.OS, Platform.Version);\r\n    if (Platform.OS === 'android' && Platform.Version > 29) {\r\n      return true;\r\n    }\r\n    const granted = await PermissionsAndroid.request(\r\n      PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE,\r\n      {\r\n        title: 'Storage Permission',\r\n        message: 'App needs access to your storage to download files.',\r\n        buttonNeutral: 'Ask Me Later',\r\n        buttonNegative: 'Cancel',\r\n        buttonPositive: 'OK',\r\n      },\r\n    );\r\n    if (granted !== PermissionsAndroid.RESULTS.GRANTED) {\r\n      Alert.alert(\r\n        'Permission Denied',\r\n        'Please enable storage permission in settings',\r\n      );\r\n    }\r\n    return granted === PermissionsAndroid.RESULTS.GRANTED;\r\n  } catch (err) {\r\n    console.warn(err);\r\n    return false;\r\n  }\r\n}\r\n","size_bytes":984},"src/lib/file/ifExists.ts":{"content":"import * as RNFS from '@dr.pogodin/react-native-fs';\r\nimport {downloadFolder} from '../constants';\r\n\r\n// check if file exists in download folder folder\r\n\r\nexport const ifExists = async (fileName: string) => {\r\n  try {\r\n    const files = await RNFS.readDir(downloadFolder);\r\n\r\n    // Find a file with the given name (without extension)\r\n    const file = files.find(file => {\r\n      const nameWithoutExtension = file.name.split('.').slice(0, -1).join('.');\r\n      return nameWithoutExtension === fileName;\r\n    });\r\n\r\n    if (file) {\r\n      return file.path;\r\n    } else {\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.log('Error reading directory:', error);\r\n    return false;\r\n  }\r\n};\r\n","size_bytes":702},"src/lib/hooks/useContentInfo.ts":{"content":"import {useQuery} from '@tanstack/react-query';\r\nimport {providerManager} from '../services/ProviderManager';\r\nimport {cacheStorage} from '../storage';\r\nimport axios from 'axios';\r\n\r\n// Hook for fetching content info/metadata\r\nexport const useContentInfo = (link: string, providerValue: string) => {\r\n  return useQuery({\r\n    queryKey: ['contentInfo', link, providerValue],\r\n    queryFn: async () => {\r\n      console.log('Fetching content info for:', link);\r\n\r\n      const data = await providerManager.getMetaData({\r\n        link,\r\n        provider: providerValue,\r\n      });\r\n      if (!data || (!data?.title && !data?.synopsis && !data?.image)) {\r\n        throw new Error('Error: No data returned from provider');\r\n      }\r\n\r\n      return data;\r\n    },\r\n    enabled: !!link && !!providerValue,\r\n    staleTime: 10 * 60 * 1000, // 10 minutes\r\n    gcTime: 60 * 60 * 1000, // 1 hour\r\n    retry: 2,\r\n    // Use cached data as initial data\r\n    initialData: () => {\r\n      const cached = cacheStorage.getString(link);\r\n      if (cached) {\r\n        try {\r\n          return JSON.parse(cached);\r\n        } catch {\r\n          return undefined;\r\n        }\r\n      }\r\n      return undefined;\r\n    },\r\n    // Cache successful responses\r\n    meta: {\r\n      onSuccess: (data: any) => {\r\n        if (data) {\r\n          cacheStorage.setString(link, JSON.stringify(data));\r\n        }\r\n      },\r\n    },\r\n  });\r\n};\r\n\r\n// Hook for fetching enhanced metadata from Stremio\r\nexport const useEnhancedMetadata = (imdbId: string, type: string) => {\r\n  return useQuery({\r\n    queryKey: ['enhancedMeta', imdbId, type],\r\n    queryFn: async () => {\r\n      console.log('Fetching enhanced metadata for:', imdbId);\r\n      try {\r\n        // Validate imdbId and type\r\n        if (!imdbId || !type) {\r\n          throw new Error('Invalid imdbId or type');\r\n        }\r\n      } catch (error) {\r\n        console.log('Error validating imdbId or type:', error);\r\n        return {};\r\n      }\r\n      const response = await axios.get(\r\n        `https://v3-cinemeta.strem.io/meta/${type}/${imdbId}.json`,\r\n        {timeout: 10000},\r\n      );\r\n\r\n      return response.data?.meta;\r\n    },\r\n    enabled: !!imdbId && !!type,\r\n    staleTime: 30 * 60 * 1000, // 30 minutes - metadata changes rarely\r\n    gcTime: 2 * 60 * 60 * 1000, // 2 hours\r\n    retry: 1, // Don't retry too much for external API\r\n    // Use cached data as initial data\r\n    initialData: () => {\r\n      const cached = cacheStorage.getString(imdbId);\r\n      if (cached) {\r\n        try {\r\n          return JSON.parse(cached);\r\n        } catch {\r\n          return undefined;\r\n        }\r\n      }\r\n      return undefined;\r\n    },\r\n    // Cache successful responses\r\n    meta: {\r\n      onSuccess: (data: any) => {\r\n        if (data && imdbId) {\r\n          cacheStorage.setString(imdbId, JSON.stringify(data));\r\n        }\r\n      },\r\n    },\r\n  });\r\n};\r\n\r\n// Combined hook for both info and metadata\r\nexport const useContentDetails = (link: string, providerValue: string) => {\r\n  // First, get the basic content info\r\n  const {\r\n    data: info,\r\n    isLoading: infoLoading,\r\n    error: infoError,\r\n    refetch: refetchInfo,\r\n  } = useContentInfo(link, providerValue);\r\n\r\n  // Then, get enhanced metadata if imdbId is available\r\n  const {\r\n    data: meta,\r\n    isLoading: metaLoading,\r\n    error: metaError,\r\n    refetch: refetchMeta,\r\n  } = useEnhancedMetadata(info?.imdbId || '', info?.type || '');\r\n\r\n  return {\r\n    info,\r\n    meta,\r\n    isLoading: infoLoading || metaLoading,\r\n    error: infoError || metaError,\r\n    refetch: async () => {\r\n      await Promise.all([refetchInfo(), refetchMeta()]);\r\n    },\r\n  };\r\n};\r\n","size_bytes":3629},"src/lib/hooks/useEpisodes.ts":{"content":"import {useQuery} from '@tanstack/react-query';\r\nimport {providerManager} from '../services/ProviderManager';\r\nimport {cacheStorage} from '../storage';\r\nimport {EpisodeLink} from '../providers/types';\r\nimport {extensionManager} from '../services';\r\n\r\nexport const useEpisodes = (\r\n  episodesLink: string | undefined,\r\n  providerValue: string,\r\n  enabled: boolean = true,\r\n) => {\r\n  return useQuery<EpisodeLink[], Error>({\r\n    queryKey: ['episodes', episodesLink, providerValue],\r\n    queryFn: async () => {\r\n      if (!episodesLink || !providerValue || !enabled) {\r\n        return [];\r\n      }\r\n\r\n      console.log('Fetching episodes for:', episodesLink);\r\n\r\n      // Check if provider has episodes module\r\n      const hasEpisodesModule =\r\n        extensionManager.getProviderModules(providerValue)?.modules.episodes;\r\n\r\n      console.log('Has episodes module:', !!hasEpisodesModule);\r\n\r\n      if (!hasEpisodesModule) {\r\n        return [];\r\n      }\r\n\r\n      const episodes = await providerManager.getEpisodes({\r\n        url: episodesLink,\r\n        providerValue: providerValue,\r\n      });\r\n\r\n      // Cache successful responses\r\n      if (episodes && episodes.length > 0) {\r\n        cacheStorage.setString(episodesLink, JSON.stringify(episodes));\r\n      }\r\n\r\n      return episodes || [];\r\n    },\r\n    enabled: enabled && !!episodesLink && !!providerValue,\r\n    staleTime: 15 * 60 * 1000, // 15 minutes\r\n    gcTime: 60 * 60 * 1000, // 1 hour (was cacheTime)\r\n    retry: (failureCount, _error) => {\r\n      // Don't retry on provider/network errors\r\n      if (failureCount >= 2) {\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\r\n    // Use cached data as initial data\r\n    initialData: () => {\r\n      if (!episodesLink) {\r\n        return undefined;\r\n      }\r\n\r\n      const cached = cacheStorage.getString(episodesLink);\r\n      if (cached) {\r\n        try {\r\n          return JSON.parse(cached);\r\n        } catch {\r\n          return undefined;\r\n        }\r\n      }\r\n      return undefined;\r\n    },\r\n    // Prevent background refetches unless data is stale\r\n    refetchOnMount: false,\r\n    refetchOnWindowFocus: false,\r\n    refetchOnReconnect: 'always',\r\n  });\r\n};\r\n\r\n// Hook for managing streams for external player\r\nexport const useStreamData = () => {\r\n  const fetchStreams = async (\r\n    link: string,\r\n    type: string,\r\n    providerValue: string,\r\n  ) => {\r\n    const controller = new AbortController();\r\n\r\n    try {\r\n      const stream = await providerManager.getStream({\r\n        link,\r\n        type,\r\n        signal: controller.signal,\r\n        providerValue,\r\n      });\r\n\r\n      return stream || [];\r\n    } catch (error) {\r\n      console.error('Error fetching streams:', error);\r\n      throw `Failed to fetch streams for ${type} at ${link} : ${error}`;\r\n    }\r\n  };\r\n\r\n  return {fetchStreams};\r\n};\r\n","size_bytes":2892},"src/lib/hooks/useHomePageData.ts":{"content":"import {useQuery} from '@tanstack/react-query';\r\nimport {getHomePageData, HomePageData} from '../getHomepagedata';\r\nimport {Content} from '../zustand/contentStore';\r\nimport {cacheStorage} from '../storage';\r\n\r\ninterface UseHomePageDataOptions {\r\n  provider: Content['provider'];\r\n  enabled?: boolean;\r\n}\r\n\r\nexport const useHomePageData = ({\r\n  provider,\r\n  enabled = true,\r\n}: UseHomePageDataOptions) => {\r\n  return useQuery<HomePageData[], Error>({\r\n    queryKey: ['homePageData', provider.value],\r\n    queryFn: async ({signal}) => {\r\n      // Fetch fresh data - cache is handled by React Query\r\n      const data = await getHomePageData(provider, signal);\r\n      return data;\r\n    },\r\n    enabled: enabled && !!provider?.value,\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n    gcTime: 30 * 60 * 1000, // 30 minutes\r\n    retry: (failureCount, error) => {\r\n      if (error.name === 'AbortError') {\r\n        return false;\r\n      }\r\n      return failureCount < 3;\r\n    },\r\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\r\n    // Add initial data from cache for instant loading\r\n    initialData: () => {\r\n      const cache = cacheStorage.getString('homeData' + provider.value);\r\n      if (cache) {\r\n        try {\r\n          return JSON.parse(cache);\r\n        } catch {\r\n          return undefined;\r\n        }\r\n      }\r\n      return undefined;\r\n    },\r\n    // Cache successful responses\r\n    meta: {\r\n      onSuccess: (data: HomePageData[]) => {\r\n        if (data && data.length > 0) {\r\n          cacheStorage.setString(\r\n            'homeData' + provider.value,\r\n            JSON.stringify(data),\r\n          );\r\n        }\r\n      },\r\n    },\r\n  });\r\n};\r\n\r\n// Memoized hero selection with stable reference\r\nexport const getRandomHeroPost = (homeData: HomePageData[]) => {\r\n  if (!homeData || homeData.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const lastCategory = homeData[homeData.length - 1];\r\n  if (!lastCategory.Posts || lastCategory.Posts.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const randomIndex = Math.floor(Math.random() * lastCategory.Posts.length);\r\n  return lastCategory.Posts[randomIndex];\r\n};\r\n\r\n// New hook for hero metadata with React Query\r\nexport const useHeroMetadata = (heroLink: string, providerValue: string) => {\r\n  return useQuery({\r\n    queryKey: ['heroMetadata', heroLink, providerValue],\r\n    queryFn: async () => {\r\n      const {providerManager} = await import('../services/ProviderManager');\r\n      const {default: axios} = await import('axios');\r\n\r\n      const info = await providerManager.getMetaData({\r\n        link: heroLink,\r\n        provider: providerValue,\r\n      });\r\n\r\n      // Try to get enhanced metadata from Stremio if imdbId is available\r\n      if (info.imdbId) {\r\n        try {\r\n          const response = await axios.get(\r\n            `https://v3-cinemeta.strem.io/meta/${info.type}/${info.imdbId}.json`,\r\n            {timeout: 5000},\r\n          );\r\n          return response.data?.meta || info;\r\n        } catch {\r\n          return info; // Fallback to original info if Stremio fails\r\n        }\r\n      }\r\n\r\n      return info;\r\n    },\r\n    enabled: !!heroLink && !!providerValue,\r\n    staleTime: 10 * 60 * 1000, // 10 minutes - hero metadata changes less frequently\r\n    gcTime: 60 * 60 * 1000, // 1 hour\r\n    retry: 2,\r\n    // Cache hero metadata separately\r\n    meta: {\r\n      onSuccess: (data: any) => {\r\n        cacheStorage.setString(heroLink, JSON.stringify(data));\r\n      },\r\n    },\r\n    // Use cached data as initial data\r\n    initialData: () => {\r\n      const cached = cacheStorage.getString(heroLink);\r\n      if (cached) {\r\n        try {\r\n          return JSON.parse(cached);\r\n        } catch {\r\n          return undefined;\r\n        }\r\n      }\r\n      return undefined;\r\n    },\r\n  });\r\n};\r\n","size_bytes":3769},"src/lib/hooks/usePlayerSettings.ts":{"content":"import {useCallback, useRef, useState} from 'react';\r\nimport {cacheStorage, mainStorage} from '../storage';\r\n\r\ninterface UsePlayerProgressOptions {\r\n  activeEpisode: any;\r\n  routeParams: any;\r\n  playbackRate: number;\r\n  updatePlaybackInfo: (link: string, data: any) => void;\r\n}\r\n\r\nexport const usePlayerProgress = ({\r\n  activeEpisode,\r\n  routeParams,\r\n  playbackRate,\r\n  updatePlaybackInfo,\r\n}: UsePlayerProgressOptions) => {\r\n  const videoPositionRef = useRef({position: 0, duration: 0});\r\n  const lastSavedPositionRef = useRef(0);\r\n\r\n  // Memoized progress handler\r\n  const handleProgress = useCallback(\r\n    (e: {currentTime: number; seekableDuration: number}) => {\r\n      const {currentTime, seekableDuration} = e;\r\n\r\n      videoPositionRef.current = {\r\n        position: currentTime,\r\n        duration: seekableDuration,\r\n      };\r\n\r\n      // Update playback info for watch history\r\n      if (routeParams?.episodeList && routeParams?.linkIndex !== undefined) {\r\n        updatePlaybackInfo(\r\n          routeParams.episodeList[routeParams.linkIndex].link,\r\n          {\r\n            currentTime,\r\n            duration: seekableDuration,\r\n            playbackRate,\r\n          },\r\n        );\r\n      }\r\n\r\n      // Store progress data for watch history display\r\n      storeWatchProgressForHistory(\r\n        routeParams.episodeList[routeParams.linkIndex].link,\r\n        currentTime,\r\n        seekableDuration,\r\n      );\r\n\r\n      // Save progress periodically (every 5 seconds)\r\n      if (\r\n        Math.abs(currentTime - lastSavedPositionRef.current) > 5 ||\r\n        currentTime - lastSavedPositionRef.current > 5\r\n      ) {\r\n        cacheStorage.setString(\r\n          activeEpisode.link,\r\n          JSON.stringify({\r\n            position: currentTime,\r\n            duration: seekableDuration,\r\n          }),\r\n        );\r\n        lastSavedPositionRef.current = currentTime;\r\n      }\r\n    },\r\n    [\r\n      activeEpisode.link,\r\n      routeParams.episodeList,\r\n      routeParams.linkIndex,\r\n      routeParams.infoUrl,\r\n      routeParams.primaryTitle,\r\n      routeParams.secondaryTitle,\r\n      updatePlaybackInfo,\r\n      playbackRate,\r\n    ],\r\n  );\r\n\r\n  // Dedicated function to store watch progress for history display\r\n  const storeWatchProgressForHistory = useCallback(\r\n    (link: string, currentTime: number, duration: number) => {\r\n      try {\r\n        if (currentTime > 0 && duration > 0) {\r\n          const historyKey = routeParams.infoUrl || link;\r\n          const historyProgressKey = `watch_history_progress_${historyKey}`;\r\n          const percentage = (currentTime / duration) * 100;\r\n\r\n          const progressData = {\r\n            currentTime,\r\n            duration,\r\n            percentage: percentage,\r\n            infoUrl: routeParams.infoUrl || '',\r\n            title: routeParams?.primaryTitle || '',\r\n            episodeTitle: routeParams?.secondaryTitle || '',\r\n            updatedAt: Date.now(),\r\n          };\r\n\r\n          mainStorage.setString(\r\n            historyProgressKey,\r\n            JSON.stringify(progressData),\r\n          );\r\n\r\n          // Also store with episodeTitle-specific key for series episodes\r\n          if (routeParams?.secondaryTitle) {\r\n            const episodeKey = `watch_history_progress_${historyKey}_${routeParams.secondaryTitle.replace(\r\n              /\\s+/g,\r\n              '_',\r\n            )}`;\r\n            mainStorage.setString(episodeKey, JSON.stringify(progressData));\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Error storing watch progress for history:', error);\r\n      }\r\n    },\r\n    [routeParams],\r\n  );\r\n\r\n  return {\r\n    videoPositionRef,\r\n    handleProgress,\r\n  };\r\n};\r\n\r\n// Hook for player settings and UI state\r\nexport const usePlayerSettings = () => {\r\n  const [showControls, setShowControls] = useState(true);\r\n  const [showSettings, setShowSettings] = useState(false);\r\n  const [activeTab, setActiveTab] = useState<\r\n    'audio' | 'subtitle' | 'server' | 'quality' | 'speed'\r\n  >('audio');\r\n  const [resizeMode, setResizeMode] = useState<any>('none');\r\n  const [playbackRate, setPlaybackRate] = useState(1.0);\r\n  const [isPlayerLocked, setIsPlayerLocked] = useState(false);\r\n  const [showUnlockButton, setShowUnlockButton] = useState(false);\r\n  const [toastMessage, setToastMessage] = useState<string>('');\r\n  const [showToast, setShowToast] = useState(false);\r\n  const [isTextVisible, setIsTextVisible] = useState(false);\r\n\r\n  const unlockButtonTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  // Memoized resize mode handler\r\n  const handleResizeMode = useCallback(() => {\r\n    const modes = [\r\n      {mode: 'none', name: 'Fit'},\r\n      {mode: 'cover', name: 'Cover'},\r\n      {mode: 'stretch', name: 'Stretch'},\r\n      {mode: 'contain', name: 'Contain'},\r\n    ];\r\n    const index = modes.findIndex(mode => mode.mode === resizeMode);\r\n    const nextMode = modes[(index + 1) % modes.length];\r\n    setResizeMode(nextMode.mode);\r\n    setToast('Resize Mode: ' + nextMode.name, 2000);\r\n  }, [resizeMode]);\r\n\r\n  // Memoized toast setter\r\n  const setToast = useCallback((message: string, duration: number) => {\r\n    setToastMessage(message);\r\n    setShowToast(true);\r\n    setTimeout(() => {\r\n      setShowToast(false);\r\n    }, duration);\r\n  }, []);\r\n\r\n  // Memoized player lock toggle\r\n  const togglePlayerLock = useCallback(() => {\r\n    const newLockState = !isPlayerLocked;\r\n    setIsPlayerLocked(newLockState);\r\n\r\n    if (!newLockState) {\r\n      setShowControls(true);\r\n    } else {\r\n      setShowUnlockButton(false);\r\n    }\r\n\r\n    if (unlockButtonTimerRef.current) {\r\n      clearTimeout(unlockButtonTimerRef.current);\r\n      unlockButtonTimerRef.current = null;\r\n    }\r\n\r\n    setToast(newLockState ? 'Player Locked' : 'Player Unlocked', 2000);\r\n  }, [isPlayerLocked, setToast]);\r\n\r\n  // Memoized locked screen tap handler\r\n  const handleLockedScreenTap = useCallback(() => {\r\n    if (showUnlockButton) {\r\n      setShowUnlockButton(false);\r\n      return;\r\n    }\r\n\r\n    setShowUnlockButton(true);\r\n\r\n    if (unlockButtonTimerRef.current) {\r\n      clearTimeout(unlockButtonTimerRef.current);\r\n    }\r\n\r\n    unlockButtonTimerRef.current = setTimeout(() => {\r\n      setShowUnlockButton(false);\r\n    }, 10000);\r\n  }, [showUnlockButton]);\r\n\r\n  return {\r\n    showControls,\r\n    setShowControls,\r\n    showSettings,\r\n    setShowSettings,\r\n    activeTab,\r\n    setActiveTab,\r\n    resizeMode,\r\n    setResizeMode,\r\n    playbackRate,\r\n    setPlaybackRate,\r\n    isPlayerLocked,\r\n    showUnlockButton,\r\n    toastMessage,\r\n    showToast,\r\n    isTextVisible,\r\n    setIsTextVisible,\r\n    handleResizeMode,\r\n    setToast,\r\n    togglePlayerLock,\r\n    handleLockedScreenTap,\r\n    unlockButtonTimerRef,\r\n  };\r\n};\r\n","size_bytes":6686},"src/lib/hooks/useStream.ts":{"content":"import {useQuery} from '@tanstack/react-query';\r\nimport {useState, useEffect} from 'react';\r\nimport {ToastAndroid} from 'react-native';\r\nimport {providerManager} from '../services/ProviderManager';\r\nimport {settingsStorage} from '../storage';\r\nimport {ifExists} from '../file/ifExists';\r\nimport {Stream} from '../providers/types';\r\n\r\ninterface UseStreamOptions {\r\n  activeEpisode: any;\r\n  routeParams: any;\r\n  provider: string;\r\n  enabled?: boolean;\r\n}\r\n\r\nexport const useStream = ({\r\n  activeEpisode,\r\n  routeParams,\r\n  provider,\r\n  enabled = true,\r\n}: UseStreamOptions) => {\r\n  const [selectedStream, setSelectedStream] = useState<Stream>({\r\n    server: '',\r\n    link: '',\r\n    type: '',\r\n  });\r\n  const [externalSubs, setExternalSubs] = useState<any[]>([]);\r\n\r\n  const {\r\n    data: streamData = [],\r\n    isLoading,\r\n    error,\r\n    refetch,\r\n  } = useQuery<Stream[], Error>({\r\n    queryKey: ['stream', activeEpisode?.link, routeParams?.type, provider],\r\n    queryFn: async () => {\r\n      if (!activeEpisode?.link) {\r\n        return [];\r\n      }\r\n\r\n      console.log('Fetching stream for:', activeEpisode);\r\n\r\n      // Handle direct URL (downloaded content)\r\n      if (routeParams?.directUrl) {\r\n        return [\r\n          {server: 'Downloaded', link: routeParams.directUrl, type: 'mp4'},\r\n        ];\r\n      }\r\n\r\n      // Check for local downloaded file\r\n      if (routeParams?.primaryTitle && routeParams?.secondaryTitle) {\r\n        const file = (\r\n          routeParams.primaryTitle +\r\n          routeParams.secondaryTitle +\r\n          activeEpisode.title\r\n        ).replaceAll(/[^a-zA-Z0-9]/g, '_');\r\n\r\n        const exists = await ifExists(file);\r\n        if (exists) {\r\n          return [{server: 'downloaded', link: exists, type: 'mp4'}];\r\n        }\r\n      }\r\n\r\n      // Fetch streams from provider\r\n      const controller = new AbortController();\r\n      const data = await providerManager.getStream({\r\n        link: activeEpisode.link,\r\n        type: routeParams?.type,\r\n        signal: controller.signal,\r\n        providerValue: routeParams?.providerValue || provider,\r\n      });\r\n\r\n      // Filter out excluded qualities\r\n      const excludedQualities = settingsStorage.getExcludedQualities() || [];\r\n      const filteredQualities = data?.filter(\r\n        streamItem => !excludedQualities.includes(streamItem?.quality + 'p'),\r\n      );\r\n\r\n      const filteredData =\r\n        filteredQualities?.length > 0 ? filteredQualities : data;\r\n\r\n      if (!filteredData || filteredData.length === 0) {\r\n        throw new Error('No streams available');\r\n      }\r\n\r\n      return filteredData;\r\n    },\r\n    enabled: enabled && !!activeEpisode?.link,\r\n    staleTime: 5 * 60 * 1000, // 5 minutes\r\n    gcTime: 30 * 60 * 1000, // 30 minutes\r\n    retry: (failureCount, _error) => {\r\n      if (failureCount >= 2) {\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 10000),\r\n    refetchOnMount: true,\r\n    refetchOnWindowFocus: false,\r\n  });\r\n\r\n  // Update selected stream when data changes\r\n  useEffect(() => {\r\n    if (streamData && streamData.length > 0) {\r\n      setSelectedStream(streamData[0]);\r\n\r\n      // Extract external subtitles\r\n      const subs: any[] = [];\r\n      streamData.forEach(track => {\r\n        if (track?.subtitles?.length && track.subtitles.length > 0) {\r\n          subs.push(...track.subtitles);\r\n        }\r\n      });\r\n      setExternalSubs(subs);\r\n    }\r\n  }, [streamData]);\r\n\r\n  // Handle errors\r\n  useEffect(() => {\r\n    if (error) {\r\n      console.error('Stream fetch error:', error);\r\n      ToastAndroid.show('No stream found, try again later', ToastAndroid.SHORT);\r\n    }\r\n  }, [error]);\r\n\r\n  const switchToNextStream = () => {\r\n    if (streamData && streamData.length > 0) {\r\n      const currentIndex = streamData.indexOf(selectedStream);\r\n      if (currentIndex < streamData.length - 1) {\r\n        setSelectedStream(streamData[currentIndex + 1]);\r\n        ToastAndroid.show(\r\n          'Video could not be played, Trying next server',\r\n          ToastAndroid.SHORT,\r\n        );\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  return {\r\n    streamData,\r\n    selectedStream,\r\n    setSelectedStream,\r\n    externalSubs,\r\n    setExternalSubs,\r\n    isLoading,\r\n    error,\r\n    refetch,\r\n    switchToNextStream,\r\n  };\r\n};\r\n\r\n// Hook for managing video tracks and settings\r\nexport const useVideoSettings = () => {\r\n  const [audioTracks, setAudioTracks] = useState<any[]>([]);\r\n  const [textTracks, setTextTracks] = useState<any[]>([]);\r\n  const [videoTracks, setVideoTracks] = useState<any[]>([]);\r\n\r\n  const [selectedAudioTrackIndex, setSelectedAudioTrackIndex] = useState(0);\r\n  const [selectedTextTrackIndex, setSelectedTextTrackIndex] = useState(1000);\r\n  const [selectedQualityIndex, setSelectedQualityIndex] = useState(1000);\r\n\r\n  const processAudioTracks = (tracks: any[]) => {\r\n    const uniqueMap = new Map();\r\n    const uniqueTracks = tracks.filter(track => {\r\n      const key = `${track.type}-${track.title}-${track.language}`;\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, true);\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n    setAudioTracks(uniqueTracks);\r\n  };\r\n\r\n  const processVideoTracks = (tracks: any[]) => {\r\n    const uniqueMap = new Map();\r\n    const uniqueTracks = tracks.filter(track => {\r\n      const key = `${track.bitrate}-${track.height}`;\r\n      if (!uniqueMap.has(key)) {\r\n        uniqueMap.set(key, true);\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n    setVideoTracks(uniqueTracks);\r\n  };\r\n\r\n  return {\r\n    audioTracks,\r\n    textTracks,\r\n    videoTracks,\r\n    selectedAudioTrackIndex,\r\n    selectedTextTrackIndex,\r\n    selectedQualityIndex,\r\n    setAudioTracks,\r\n    setTextTracks,\r\n    setVideoTracks,\r\n    setSelectedAudioTrackIndex,\r\n    setSelectedTextTrackIndex,\r\n    setSelectedQualityIndex,\r\n    processAudioTracks,\r\n    processVideoTracks,\r\n  };\r\n};\r\n","size_bytes":5960},"src/lib/providers/gdflixExtractor.ts":{"content":"import axios from 'axios';\r\nimport * as cheerio from 'cheerio';\r\nimport {Stream} from './types';\r\nimport {headers} from './headers';\r\n\r\nexport async function gdFlixExtracter(link: string, signal: AbortSignal) {\r\n  try {\r\n    const streamLinks: Stream[] = [];\r\n    const res = await axios(`${link}`, {headers, signal});\r\n    console.log('gdFlixExtracter', link);\r\n    const data = res.data;\r\n    let $drive = cheerio.load(data);\r\n    // handle if redirected to another link\r\n\r\n    if ($drive('body').attr('onload')?.includes('location.replace')) {\r\n      const newLink = $drive('body')\r\n        .attr('onload')\r\n        ?.split(\"location.replace('\")?.[1]\r\n        .split(\"'\")?.[0];\r\n\r\n      console.log('newLink', newLink);\r\n      if (newLink) {\r\n        const newRes = await axios.get(newLink, {headers, signal});\r\n        $drive = cheerio.load(newRes.data);\r\n      }\r\n    }\r\n\r\n    // try {\r\n    //   const resumeBot = $drive('.fab.fa-artstation').prev().attr('href') || '';\r\n    //   console.log('resumeBot', resumeBot);\r\n    //   const resumeBotRes = await axios.get(resumeBot, {headers});\r\n    //   const resumeBotToken = resumeBotRes.data.match(\r\n    //     /formData\\.append\\('token', '([a-f0-9]+)'\\)/,\r\n    //   )[1];\r\n    //   const resumeBotBody = new FormData();\r\n    //   resumeBotBody.append('token', resumeBotToken);\r\n    //   const resumeBotPath = resumeBotRes.data.match(\r\n    //     /fetch\\('\\/download\\?id=([a-zA-Z0-9\\/+]+)'/,\r\n    //   )[1];\r\n    //   const resumeBotBaseUrl = resumeBot.split('/download')[0];\r\n    //   // console.log(\r\n    //   //   'resumeBotPath',\r\n    //   //   resumeBotBaseUrl + '/download?id=' + resumeBotPath,\r\n    //   // );\r\n    //   // console.log('resumeBotBody', resumeBotToken);\r\n\r\n    //   const resumeBotDownload = await fetch(\r\n    //     resumeBotBaseUrl + '/download?id=' + resumeBotPath,\r\n    //     {\r\n    //       method: 'POST',\r\n    //       body: resumeBotBody,\r\n    //       headers: {\r\n    //         Referer: resumeBot,\r\n    //         Cookie: 'PHPSESSID=7e9658ce7c805dab5bbcea9046f7f308',\r\n    //       },\r\n    //     },\r\n    //   );\r\n    //   const resumeBotDownloadData = await resumeBotDownload.json();\r\n    //   console.log('resumeBotDownloadData', resumeBotDownloadData.url);\r\n    //   streamLinks.push({\r\n    //     server: 'ResumeBot',\r\n    //     link: resumeBotDownloadData.url,\r\n    //     type: 'mkv',\r\n    //   });\r\n    // } catch (err) {\r\n    //   console.log('ResumeBot link not found', err);\r\n    // }\r\n\r\n    // r2\r\n    try {\r\n      const r2Link =\r\n        $drive('..btn.btn-outline-success').attr('href') ||\r\n        $drive('a:contains(\"CLOUD DOWNLOAD\")').attr('href') ||\r\n        '';\r\n      console.log('r2Link', r2Link);\r\n      if (r2Link) {\r\n        streamLinks.push({\r\n          server: 'R2',\r\n          link: r2Link,\r\n          type: 'mkv',\r\n        });\r\n      }\r\n    } catch (err) {\r\n      console.log('R2 link not found', err);\r\n    }\r\n\r\n    // pixel drain\r\n    try {\r\n      const pixelDrainLink = $drive('.btn.btn-success').attr('href') || '';\r\n      console.log('pixelDrainLink', pixelDrainLink);\r\n      if (pixelDrainLink) {\r\n        streamLinks.push({\r\n          server: 'PixelDrain',\r\n          link: pixelDrainLink,\r\n          type: 'mkv',\r\n        });\r\n      }\r\n    } catch (err) {\r\n      console.log('PixelDrain link not found', err);\r\n    }\r\n    /// resume cloud\r\n    try {\r\n      const baseUrl = link.split('/').slice(0, 3).join('/');\r\n      const resumeDrive = $drive('.btn-secondary').attr('href') || '';\r\n      console.log('resumeDrive', resumeDrive);\r\n      const hostname = resumeDrive.split('/')[2] || '';\r\n      console.log('hostname', hostname);\r\n      if (resumeDrive.includes('indexbot') || hostname.includes('bot')) {\r\n        const resumeBotRes = await axios.get(resumeDrive, {headers});\r\n        console.log('resumeBotRes', resumeBotRes.data);\r\n        const resumeBotToken = resumeBotRes.data.match(\r\n          /formData\\.append\\('token', '([a-f0-9]+)'\\)/,\r\n        )[1];\r\n        console.log('resumeBotToken', resumeBotToken);\r\n        const resumeBotBody = new FormData();\r\n        resumeBotBody.append('token', resumeBotToken);\r\n        const resumeBotPath = resumeBotRes.data.match(\r\n          /fetch\\('\\/download\\?id=([a-zA-Z0-9\\/+]+)'/,\r\n        )[1];\r\n        const resumeBotBaseUrl = resumeDrive.split('/download')[0];\r\n        // console.log(\r\n        //   'resumeBotPath',\r\n        //   resumeBotBaseUrl + '/download?id=' + resumeBotPath,\r\n        // );\r\n        // console.log('resumeBotBody', resumeBotToken);\r\n\r\n        const resumeBotDownload = await fetch(\r\n          resumeBotBaseUrl + '/download?id=' + resumeBotPath,\r\n          {\r\n            method: 'POST',\r\n            body: resumeBotBody,\r\n            headers: {\r\n              Referer: resumeDrive,\r\n              Cookie: 'PHPSESSID=7e9658ce7c805dab5bbcea9046f7f308',\r\n            },\r\n          },\r\n        );\r\n        const resumeBotDownloadData = await resumeBotDownload.json();\r\n        console.log('resumeBotDownloadData', resumeBotDownloadData.url);\r\n        streamLinks.push({\r\n          server: 'ResumeBot',\r\n          link: resumeBotDownloadData.url,\r\n          type: 'mkv',\r\n        });\r\n      } else {\r\n        const url = baseUrl + resumeDrive;\r\n        const resumeDriveRes = await axios.get(url, {headers});\r\n        const resumeDriveHtml = resumeDriveRes.data;\r\n        const $resumeDrive = cheerio.load(resumeDriveHtml);\r\n        const resumeLink = $resumeDrive('.btn-success').attr('href');\r\n        //   console.log('resumeLink', resumeLink);\r\n        if (resumeLink) {\r\n          streamLinks.push({\r\n            server: 'ResumeCloud',\r\n            link: resumeLink,\r\n            type: 'mkv',\r\n          });\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.log('Resume link not found', err);\r\n    }\r\n\r\n    //instant link\r\n    try {\r\n      const seed = $drive('.btn-danger').attr('href') || '';\r\n      console.log('seed', seed);\r\n      if (!seed.includes('?url=')) {\r\n        const newLinkRes = await axios.head(seed, {headers, signal});\r\n        console.log('newLinkRes', newLinkRes.request?.responseURL);\r\n        const newLink =\r\n          newLinkRes.request?.responseURL?.split('?url=')?.[1] || seed;\r\n        streamLinks.push({server: 'G-Drive', link: newLink, type: 'mkv'});\r\n      } else {\r\n        const instantToken = seed.split('=')[1];\r\n        //   console.log('InstantToken', instantToken);\r\n        const InstantFromData = new FormData();\r\n        InstantFromData.append('keys', instantToken);\r\n        const videoSeedUrl = seed.split('/').slice(0, 3).join('/') + '/api';\r\n        //   console.log('videoSeedUrl', videoSeedUrl);\r\n        const instantLinkRes = await fetch(videoSeedUrl, {\r\n          method: 'POST',\r\n          body: InstantFromData,\r\n          headers: {\r\n            'x-token': videoSeedUrl,\r\n          },\r\n        });\r\n        const instantLinkData = await instantLinkRes.json();\r\n        //   console.log('instantLinkData', instantLinkData);\r\n        if (instantLinkData.error === false) {\r\n          const instantLink = instantLinkData.url;\r\n          streamLinks.push({\r\n            server: 'Gdrive-Instant',\r\n            link: instantLink,\r\n            type: 'mkv',\r\n          });\r\n        } else {\r\n          console.log('Instant link not found', instantLinkData);\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.log('Instant link not found', err);\r\n    }\r\n    return streamLinks;\r\n  } catch (error) {\r\n    console.log('gdflix error: ', error);\r\n    return [];\r\n  }\r\n}\r\n","size_bytes":7522},"src/lib/providers/getBaseUrl.ts":{"content":"import {cacheStorageService} from '../storage';\r\n\r\n// 1 hour\r\nconst expireTime = 60 * 60 * 1000;\r\n\r\nexport const getBaseUrl = async (providerValue: string) => {\r\n  try {\r\n    let baseUrl = '';\r\n    const cacheKey = 'CacheBaseUrl' + providerValue;\r\n    const timeKey = 'baseUrlTime' + providerValue;\r\n\r\n    const cachedUrl = cacheStorageService.getString(cacheKey);\r\n    const cachedTime = cacheStorageService.getObject<number>(timeKey);\r\n\r\n    if (cachedUrl && cachedTime && Date.now() - cachedTime < expireTime) {\r\n      baseUrl = cachedUrl;\r\n    } else {\r\n      const baseUrlRes = await fetch(\r\n        'https://himanshu8443.github.io/providers/modflix.json',\r\n      );\r\n      const baseUrlData = await baseUrlRes.json();\r\n      baseUrl = baseUrlData[providerValue].url;\r\n      cacheStorageService.setString(cacheKey, baseUrl);\r\n      cacheStorageService.setObject(timeKey, Date.now());\r\n    }\r\n    return baseUrl;\r\n  } catch (error) {\r\n    console.error(`Error fetching baseUrl: ${providerValue}`, error);\r\n    return '';\r\n  }\r\n};\r\n","size_bytes":1035},"src/lib/providers/gofileExtracter.ts":{"content":"import axios from 'axios';\r\n\r\nexport async function gofileExtracter(\r\n  id: string,\r\n): Promise<{link: string; token: string}> {\r\n  try {\r\n    const gofileRes = await axios.get('https://gofile.io/d/' + id);\r\n    const genAccountres = await axios.post('https://api.gofile.io/accounts');\r\n    const token = genAccountres.data.data.token;\r\n    console.log('gofile token', token);\r\n\r\n    const wtRes = await axios.get('https://gofile.io/dist/js/global.js');\r\n    const wt = wtRes.data.match(/appdata\\.wt\\s*=\\s*[\"']([^\"']+)[\"']/)[1];\r\n    console.log('gofile wt', wt);\r\n\r\n    const res = await axios.get(\r\n      `https://api.gofile.io/contents/${id}?wt=${wt}`,\r\n      {\r\n        headers: {\r\n          Authorization: `Bearer ${token}`,\r\n        },\r\n      },\r\n    );\r\n    const oId = Object.keys(res.data.data.children)[0];\r\n    console.log('gofile extracter', res.data.data.children[oId].link);\r\n    const link = res.data.data.children[oId].link;\r\n    return {\r\n      link,\r\n      token,\r\n    };\r\n  } catch (e) {\r\n    console.log('gofile extracter err', e);\r\n    return {\r\n      link: '',\r\n      token: '',\r\n    };\r\n  }\r\n}\r\n","size_bytes":1118},"src/lib/providers/headers.ts":{"content":"export const headers = {\r\n  'sec-ch-ua':\r\n    '\"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Microsoft Edge\";v=\"120\"',\r\n  'sec-ch-ua-mobile': '?0',\r\n  'sec-ch-ua-platform': '\"Windows\"',\r\n  // 'Sec-Fetch-Site': 'none',\r\n  // 'Sec-Fetch-User': '?1',\r\n  'User-Agent':\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0',\r\n};\r\n","size_bytes":400},"src/lib/providers/hubcloudExtractor.ts":{"content":"import axios from 'axios';\r\nimport * as cheerio from 'cheerio';\r\nimport {Stream} from './types';\r\nimport {headers} from './headers';\r\n\r\nconst decode = function (value: string) {\r\n  if (value === undefined) {\r\n    return '';\r\n  }\r\n  return atob(value.toString());\r\n};\r\n\r\nexport async function hubcloudExtracter(link: string, signal: AbortSignal) {\r\n  try {\r\n    console.log('hubcloudExtracter', link);\r\n    const baseUrl = link.split('/').slice(0, 3).join('/');\r\n    const streamLinks: Stream[] = [];\r\n    const vLinkRes = await axios(`${link}`, {headers, signal});\r\n    const vLinkText = vLinkRes.data;\r\n    const $vLink = cheerio.load(vLinkText);\r\n    const vLinkRedirect = vLinkText.match(/var\\s+url\\s*=\\s*'([^']+)';/) || [];\r\n    let vcloudLink =\r\n      decode(vLinkRedirect[1]?.split('r=')?.[1]) ||\r\n      vLinkRedirect[1] ||\r\n      $vLink('.fa-file-download.fa-lg').parent().attr('href') ||\r\n      link;\r\n    console.log('vcloudLink', vcloudLink);\r\n    if (vcloudLink?.startsWith('/')) {\r\n      vcloudLink = `${baseUrl}${vcloudLink}`;\r\n      console.log('New vcloudLink', vcloudLink);\r\n    }\r\n    const vcloudRes = await fetch(vcloudLink, {\r\n      headers,\r\n      signal,\r\n      redirect: 'follow',\r\n    });\r\n    const $ = cheerio.load(await vcloudRes.text());\r\n    // console.log('vcloudRes', $.text());\r\n\r\n    const linkClass = $('.btn-success.btn-lg.h6,.btn-danger,.btn-secondary');\r\n    for (const element of linkClass) {\r\n      const itm = $(element);\r\n      let link = itm.attr('href') || '';\r\n      if (link?.includes('.dev') && !link?.includes('/?id=')) {\r\n        streamLinks.push({server: 'Cf Worker', link: link, type: 'mkv'});\r\n      }\r\n      if (link?.includes('pixeld')) {\r\n        if (!link?.includes('api')) {\r\n          const token = link.split('/').pop();\r\n          const baseUrl = link.split('/').slice(0, -2).join('/');\r\n          link = `${baseUrl}/api/file/${token}?download`;\r\n        }\r\n        streamLinks.push({server: 'Pixeldrain', link: link, type: 'mkv'});\r\n      }\r\n      if (link?.includes('hubcloud') || link?.includes('/?id=')) {\r\n        try {\r\n          const newLinkRes = await axios.head(link, {headers, signal});\r\n          const newLink =\r\n            newLinkRes.request?.responseURL?.split('link=')?.[1] || link;\r\n          streamLinks.push({server: 'hubcloud', link: newLink, type: 'mkv'});\r\n        } catch (error) {\r\n          console.log('hubcloudExtracter error in hubcloud link: ', error);\r\n        }\r\n      }\r\n      if (link?.includes('cloudflarestorage')) {\r\n        streamLinks.push({server: 'CfStorage', link: link, type: 'mkv'});\r\n      }\r\n      if (link?.includes('fastdl')) {\r\n        streamLinks.push({server: 'FastDl', link: link, type: 'mkv'});\r\n      }\r\n      if (link.includes('hubcdn')) {\r\n        streamLinks.push({\r\n          server: 'HubCdn',\r\n          link: link,\r\n          type: 'mkv',\r\n        });\r\n      }\r\n    }\r\n    console.log('streamLinks', streamLinks);\r\n    return streamLinks;\r\n  } catch (error) {\r\n    console.log('hubcloudExtracter error: ', error);\r\n    return [];\r\n  }\r\n}\r\n","size_bytes":3058},"src/lib/providers/providerContext.ts":{"content":"import axios from 'axios';\r\nimport {getBaseUrl} from './getBaseUrl';\r\nimport {headers} from './headers';\r\nimport * as cheerio from 'cheerio';\r\nimport {hubcloudExtracter} from './hubcloudExtractor';\r\nimport {gofileExtracter} from './gofileExtracter';\r\nimport {superVideoExtractor} from './superVideoExtractor';\r\nimport {gdFlixExtracter} from './gdflixExtractor';\r\nimport {ProviderContext} from './types';\r\nimport * as Crypto from 'expo-crypto';\r\n\r\n/**\r\n * Context for provider functions.\r\n * This context is used to pass common dependencies to provider functions.\r\n */\r\n\r\nconst extractors = {\r\n  hubcloudExtracter,\r\n  gofileExtracter,\r\n  superVideoExtractor,\r\n  gdFlixExtracter,\r\n};\r\n\r\nexport const providerContext: ProviderContext = {\r\n  axios,\r\n  getBaseUrl,\r\n  commonHeaders: headers,\r\n  Crypto,\r\n  cheerio,\r\n  extractors,\r\n};\r\n","size_bytes":830},"src/lib/providers/superVideoExtractor.ts":{"content":"export async function superVideoExtractor(data: any) {\r\n  try {\r\n    // Step 1: Extract the function parameters and the encoded string\r\n    var functionRegex =\r\n      /eval\\(function\\((.*?)\\)\\{.*?return p\\}.*?\\('(.*?)'\\.split/;\r\n    var match = functionRegex.exec(data);\r\n    let p = '';\r\n    if (match) {\r\n      // var params = match[1].split(',').map(param => param.trim());\r\n      var encodedString = match[2];\r\n\r\n      // console.log('Parameters:', params);\r\n      // console.log('Encoded String:', encodedString.split(\"',36,\")[0], '🔥🔥');\r\n\r\n      p = encodedString.split(\"',36,\")?.[0].trim();\r\n      let a = 36;\r\n      let c = encodedString.split(\"',36,\")[1].slice(2).split('|').length;\r\n      let k = encodedString.split(\"',36,\")[1].slice(2).split('|');\r\n\r\n      while (c--) {\r\n        if (k[c]) {\r\n          var regex = new RegExp('\\\\b' + c.toString(a) + '\\\\b', 'g');\r\n          p = p.replace(regex, k[c]);\r\n        }\r\n      }\r\n\r\n      // console.log('Decoded String:', p);\r\n    } else {\r\n      console.log('No match found');\r\n    }\r\n\r\n    const streamUrl = p?.match(/file:\\s*\"([^\"]+\\.m3u8[^\"]*)\"/)?.[1];\r\n    console.log('streamUrl:', streamUrl);\r\n\r\n    return streamUrl || '';\r\n  } catch (err) {\r\n    console.error('SuperVideoExtractor Error:', err);\r\n    return '';\r\n  }\r\n}\r\n","size_bytes":1291},"src/lib/providers/types.ts":{"content":"import {AxiosStatic} from 'axios';\r\nimport * as cheerio from 'cheerio';\r\nimport {Content} from '../zustand/contentStore';\r\nimport * as Crypto from 'expo-crypto';\r\n\r\nexport interface ProvidersList {\r\n  name: string;\r\n  value: string;\r\n  type: string;\r\n  flag: string;\r\n}\r\n\r\nexport interface Post {\r\n  title: string;\r\n  link: string;\r\n  image: string;\r\n  provider?: string;\r\n}\r\n\r\nexport declare enum TextTrackType {\r\n  SUBRIP = 'application/x-subrip',\r\n  TTML = 'application/ttml+xml',\r\n  VTT = 'text/vtt',\r\n}\r\n\r\nexport type TextTracks = {\r\n  title: string;\r\n  language: ISO639_1;\r\n  type: TextTrackType;\r\n  uri: string;\r\n}[];\r\n\r\n// getStream\r\nexport interface Stream {\r\n  server: string;\r\n  link: string;\r\n  type: string;\r\n  quality?: '360' | '480' | '720' | '1080' | '2160';\r\n  subtitles?: TextTracks;\r\n  headers?: any;\r\n}\r\n\r\n// getInfo\r\nexport interface Info {\r\n  title: string;\r\n  image: string;\r\n  synopsis: string;\r\n  imdbId: string;\r\n  type: string;\r\n  tags?: string[];\r\n  cast?: string[];\r\n  rating?: string;\r\n  linkList: Link[];\r\n}\r\n// getEpisodeLinks\r\nexport interface EpisodeLink {\r\n  title: string;\r\n  link: string;\r\n}\r\n\r\nexport interface Link {\r\n  title: string;\r\n  quality?: string;\r\n  episodesLink?: string;\r\n  directLinks?: {\r\n    title: string;\r\n    link: string;\r\n    type?: 'movie' | 'series';\r\n  }[];\r\n}\r\n\r\n// catalog\r\nexport interface Catalog {\r\n  title: string;\r\n  filter: string;\r\n}\r\n\r\nexport interface ProviderType {\r\n  searchFilter?: string;\r\n  catalog: Catalog[];\r\n  genres: Catalog[];\r\n  blurImage?: boolean;\r\n  nonStreamableServer?: string[];\r\n  nonDownloadableServer?: string[];\r\n  GetStream: ({\r\n    link,\r\n    type,\r\n    signal,\r\n    providerContext,\r\n  }: {\r\n    link: string;\r\n    type: string;\r\n    signal: AbortSignal;\r\n    providerContext: ProviderContext;\r\n  }) => Promise<Stream[]>;\r\n  GetHomePosts: ({\r\n    filter,\r\n    page,\r\n    providerValue,\r\n    signal,\r\n    providerContext,\r\n  }: {\r\n    filter: string;\r\n    page: number;\r\n    providerValue: string;\r\n    signal: AbortSignal;\r\n    providerContext: ProviderContext;\r\n  }) => Promise<Post[]>;\r\n  GetEpisodeLinks?: ({\r\n    url,\r\n    providerContext,\r\n  }: {\r\n    url: string;\r\n    providerContext: ProviderContext;\r\n  }) => Promise<EpisodeLink[]>;\r\n  GetMetaData: ({\r\n    link,\r\n    provider,\r\n    providerContext,\r\n  }: {\r\n    link: string;\r\n    provider: Content['provider'];\r\n    providerContext: ProviderContext;\r\n  }) => Promise<Info>;\r\n  GetSearchPosts: ({\r\n    searchQuery,\r\n    page,\r\n    providerValue,\r\n    signal,\r\n    providerContext,\r\n  }: {\r\n    searchQuery: string;\r\n    page: number;\r\n    providerValue: string;\r\n    signal: AbortSignal;\r\n    providerContext: ProviderContext;\r\n  }) => Promise<Post[]>;\r\n}\r\n\r\nexport type ProviderContext = {\r\n  axios: AxiosStatic;\r\n  Crypto: typeof Crypto;\r\n  getBaseUrl: (providerValue: string) => Promise<string>;\r\n  commonHeaders: Record<string, string>;\r\n  cheerio: typeof cheerio;\r\n  extractors: {\r\n    hubcloudExtracter: (link: string, signal: AbortSignal) => Promise<Stream[]>;\r\n    gofileExtracter: (id: string) => Promise<{\r\n      link: string;\r\n      token: string;\r\n    }>;\r\n    superVideoExtractor: (data: any) => Promise<string>;\r\n    gdFlixExtracter: (link: string, signal: AbortSignal) => Promise<Stream[]>;\r\n  };\r\n};\r\n\r\nexport type ISO639_1 =\r\n  | 'aa'\r\n  | 'ab'\r\n  | 'ae'\r\n  | 'af'\r\n  | 'ak'\r\n  | 'am'\r\n  | 'an'\r\n  | 'ar'\r\n  | 'as'\r\n  | 'av'\r\n  | 'ay'\r\n  | 'az'\r\n  | 'ba'\r\n  | 'be'\r\n  | 'bg'\r\n  | 'bi'\r\n  | 'bm'\r\n  | 'bn'\r\n  | 'bo'\r\n  | 'br'\r\n  | 'bs'\r\n  | 'ca'\r\n  | 'ce'\r\n  | 'ch'\r\n  | 'co'\r\n  | 'cr'\r\n  | 'cs'\r\n  | 'cu'\r\n  | 'cv'\r\n  | 'cy'\r\n  | 'da'\r\n  | 'de'\r\n  | 'dv'\r\n  | 'dz'\r\n  | 'ee'\r\n  | 'el'\r\n  | 'en'\r\n  | 'eo'\r\n  | 'es'\r\n  | 'et'\r\n  | 'eu'\r\n  | 'fa'\r\n  | 'ff'\r\n  | 'fi'\r\n  | 'fj'\r\n  | 'fo'\r\n  | 'fr'\r\n  | 'fy'\r\n  | 'ga'\r\n  | 'gd'\r\n  | 'gl'\r\n  | 'gn'\r\n  | 'gu'\r\n  | 'gv'\r\n  | 'ha'\r\n  | 'he'\r\n  | 'hi'\r\n  | 'ho'\r\n  | 'hr'\r\n  | 'ht'\r\n  | 'hu'\r\n  | 'hy'\r\n  | 'hz'\r\n  | 'ia'\r\n  | 'id'\r\n  | 'ie'\r\n  | 'ig'\r\n  | 'ii'\r\n  | 'ik'\r\n  | 'io'\r\n  | 'is'\r\n  | 'it'\r\n  | 'iu'\r\n  | 'ja'\r\n  | 'jv'\r\n  | 'ka'\r\n  | 'kg'\r\n  | 'ki'\r\n  | 'kj'\r\n  | 'kk'\r\n  | 'kl'\r\n  | 'km'\r\n  | 'kn'\r\n  | 'ko'\r\n  | 'kr'\r\n  | 'ks'\r\n  | 'ku'\r\n  | 'kv'\r\n  | 'kw'\r\n  | 'ky'\r\n  | 'la'\r\n  | 'lb'\r\n  | 'lg'\r\n  | 'li'\r\n  | 'ln'\r\n  | 'lo'\r\n  | 'lt'\r\n  | 'lu'\r\n  | 'lv'\r\n  | 'mg'\r\n  | 'mh'\r\n  | 'mi'\r\n  | 'mk'\r\n  | 'ml'\r\n  | 'mn'\r\n  | 'mr'\r\n  | 'ms'\r\n  | 'mt'\r\n  | 'my'\r\n  | 'na'\r\n  | 'nb'\r\n  | 'nd'\r\n  | 'ne'\r\n  | 'ng'\r\n  | 'nl'\r\n  | 'nn'\r\n  | 'no'\r\n  | 'nr'\r\n  | 'nv'\r\n  | 'ny'\r\n  | 'oc'\r\n  | 'oj'\r\n  | 'om'\r\n  | 'or'\r\n  | 'os'\r\n  | 'pa'\r\n  | 'pi'\r\n  | 'pl'\r\n  | 'ps'\r\n  | 'pt'\r\n  | 'qu'\r\n  | 'rm'\r\n  | 'rn'\r\n  | 'ro'\r\n  | 'ru'\r\n  | 'rw'\r\n  | 'sa'\r\n  | 'sc'\r\n  | 'sd'\r\n  | 'se'\r\n  | 'sg'\r\n  | 'si'\r\n  | 'sk'\r\n  | 'sl'\r\n  | 'sm'\r\n  | 'sn'\r\n  | 'so'\r\n  | 'sq'\r\n  | 'sr'\r\n  | 'ss'\r\n  | 'st'\r\n  | 'su'\r\n  | 'sv'\r\n  | 'sw'\r\n  | 'ta'\r\n  | 'te'\r\n  | 'tg'\r\n  | 'th'\r\n  | 'ti'\r\n  | 'tk'\r\n  | 'tl'\r\n  | 'tn'\r\n  | 'to'\r\n  | 'tr'\r\n  | 'ts'\r\n  | 'tt'\r\n  | 'tw'\r\n  | 'ty'\r\n  | 'ug'\r\n  | 'uk'\r\n  | 'ur'\r\n  | 'uz'\r\n  | 've'\r\n  | 'vi'\r\n  | 'vo'\r\n  | 'wa'\r\n  | 'wo'\r\n  | 'xh'\r\n  | 'yi'\r\n  | 'yo'\r\n  | 'za'\r\n  | 'zh'\r\n  | 'zu';\r\n","size_bytes":5131},"src/lib/services/DownloadManager.ts":{"content":"import {downloadFolder} from '../constants';\r\nimport {downloadsStorage} from '../storage';\r\nimport {DownloadPayload} from '../storage/DownloadsStorage';\r\nimport * as RNFS from '@dr.pogodin/react-native-fs';\r\n\r\nexport class DownloadManager {\r\n  private static instance: DownloadManager;\r\n\r\n  private downloads: Map<string, DownloadPayload> =\r\n    downloadsStorage.getDownloads();\r\n\r\n  public static getInstance(): DownloadManager {\r\n    if (!DownloadManager.instance) {\r\n      DownloadManager.instance = new DownloadManager();\r\n    }\r\n    return DownloadManager.instance;\r\n  }\r\n\r\n  updateDownloadStatus(\r\n    id: string,\r\n    status: 'downloading' | 'paused' | 'downloaded',\r\n  ): void {\r\n    const download = this.downloads.get(id);\r\n    if (download) {\r\n      download.status = status;\r\n      this.downloads.set(id, download);\r\n      downloadsStorage.saveDownloads(this.downloads);\r\n    }\r\n  }\r\n\r\n  updateDownload(id: string, payload: Partial<DownloadPayload>): void {\r\n    const download = this.downloads.get(id);\r\n    if (download) {\r\n      Object.assign(download, payload);\r\n      this.downloads.set(id, download);\r\n      downloadsStorage.saveDownloads(this.downloads);\r\n    }\r\n  }\r\n\r\n  addDownload(id: string, payload: DownloadPayload): void {\r\n    this.downloads.set(id, payload);\r\n    downloadsStorage.saveDownloads(this.downloads);\r\n  }\r\n\r\n  async removeDownloadAsync(id: string): Promise<void> {\r\n    const download = this.downloads.get(id);\r\n    if (!download) {\r\n      return;\r\n    }\r\n    try {\r\n      await RNFS.unlink(this.generateDownloadLocation(download));\r\n    } catch (error) {\r\n      console.error('Failed to remove download:', error);\r\n      console.log('path:', this.generateDownloadLocation(download));\r\n    }\r\n    const downloadExists = await RNFS.exists(\r\n      this.generateDownloadLocation(download),\r\n    );\r\n    console.log('Download exists after removal attempt:', downloadExists);\r\n\r\n    if (!downloadExists) {\r\n      this.downloads.delete(id);\r\n      downloadsStorage.saveDownloads(this.downloads);\r\n    }\r\n  }\r\n\r\n  removeDownload(id: string): void {\r\n    this.downloads.delete(id);\r\n    downloadsStorage.saveDownloads(this.downloads);\r\n  }\r\n\r\n  getDownload(id: string): DownloadPayload | undefined {\r\n    return this.downloads.get(id);\r\n  }\r\n\r\n  isDownloaded(id: string): boolean {\r\n    return (\r\n      this.downloads.has(id) && this.downloads.get(id)?.status === 'downloaded'\r\n    );\r\n  }\r\n\r\n  getAllDownloads(): Map<string, DownloadPayload> {\r\n    return this.downloads;\r\n  }\r\n\r\n  generateDownloadId({\r\n    folderName,\r\n    fileName,\r\n  }: {\r\n    folderName: string;\r\n    fileName: string;\r\n  }): string {\r\n    return `${folderName}${fileName}`;\r\n  }\r\n\r\n  generateDownloadLocation(downloadPayload: DownloadPayload): string {\r\n    return `${downloadFolder}/${downloadPayload.provider}/${downloadPayload.folderName}/${downloadPayload.fileName}.${downloadPayload.fileType}`;\r\n  }\r\n}\r\n\r\nexport const downloadManager = DownloadManager.getInstance();\r\n","size_bytes":2980},"src/lib/services/ExtensionManager.ts":{"content":"import axios from 'axios';\r\nimport {\r\n  extensionStorage,\r\n  ProviderExtension,\r\n  ProviderModule,\r\n} from '../storage/extensionStorage';\r\n/**\r\n * Extension manager service for handling dynamic provider loading\r\n */\r\nexport class ExtensionManager {\r\n  private static instance: ExtensionManager;\r\n  private baseUrl =\r\n    'https://raw.githubusercontent.com/Zenda-Cross/vega-providers/refs/heads/main';\r\n\r\n  private testMode = false;\r\n  private baseUrlTestMode = '';\r\n\r\n  private manifestUrl = `${this.baseUrl}/manifest.json`;\r\n\r\n  // Test mode configuration\r\n  private testModuleCacheExpiry = 200000;\r\n  private testModuleCache = new Map<\r\n    string,\r\n    {module: ProviderModule; cachedAt: number}\r\n  >();\r\n\r\n  static getInstance(): ExtensionManager {\r\n    if (!ExtensionManager.instance) {\r\n      ExtensionManager.instance = new ExtensionManager();\r\n    }\r\n    return ExtensionManager.instance;\r\n  }\r\n\r\n  /**\r\n   * Fetch latest manifest from GitHub\r\n   */\r\n  async fetchManifest(force = false): Promise<ProviderExtension[]> {\r\n    try {\r\n      // Check cache first\r\n      if (!force && !extensionStorage.isManifestCacheExpired()) {\r\n        const cached = extensionStorage.getManifestCache();\r\n        if (cached.length > 0) {\r\n          return cached;\r\n        }\r\n      }\r\n\r\n      const manifestUrl = this.testMode\r\n        ? `${this.baseUrlTestMode}/manifest.json`\r\n        : this.manifestUrl;\r\n      console.log('Fetching manifest from:', manifestUrl);\r\n      const response = await axios.get(manifestUrl, {\r\n        timeout: 10000,\r\n      });\r\n\r\n      if (!response.data || !Array.isArray(response.data)) {\r\n        throw new Error('Invalid manifest format');\r\n      }\r\n\r\n      const providers: ProviderExtension[] = response.data.map((item: any) => ({\r\n        value: item.value,\r\n        display_name: item.display_name,\r\n        disabled: item.disabled || false,\r\n        version: item.version,\r\n        icon: item.icon || '',\r\n        type: item.type || 'global',\r\n        installed: false,\r\n      }));\r\n\r\n      // Cache the manifest\r\n      extensionStorage.setManifestCache(providers);\r\n      extensionStorage.setAvailableProviders(providers);\r\n\r\n      return providers;\r\n    } catch (error) {\r\n      console.error('Failed to fetch manifest:', error);\r\n\r\n      // Return cached data if available\r\n      const cached = extensionStorage.getManifestCache();\r\n      if (cached.length > 0) {\r\n        return cached;\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Download and cache provider modules\r\n   */\r\n  async downloadProviderModules(\r\n    providerValue: string,\r\n    version: string,\r\n  ): Promise<ProviderModule> {\r\n    if (this.testMode) {\r\n      return this.downloadTestProviderModule(providerValue);\r\n    }\r\n    try {\r\n      const requiredFiles = ['posts', 'meta', 'stream', 'catalog'];\r\n      const optionalFiles = ['episodes'];\r\n      const allFiles = [...requiredFiles, ...optionalFiles];\r\n\r\n      const modules: Record<string, string> = {};\r\n      const downloadPromises = allFiles.map(async fileName => {\r\n        try {\r\n          const url = `${this.baseUrl}/dist/${providerValue}/${fileName}.js`;\r\n          console.log(`Downloading: ${url}`);\r\n\r\n          const response = await axios.get(url, {\r\n            timeout: 15000,\r\n          });\r\n\r\n          if (response.data) {\r\n            modules[fileName] = response.data;\r\n          }\r\n        } catch (error) {\r\n          // Only log error for required files\r\n          if (requiredFiles.includes(fileName)) {\r\n            console.error(\r\n              `Failed to download ${fileName}.js for ${providerValue}:`,\r\n              error,\r\n            );\r\n            throw error;\r\n          } else {\r\n            console.warn(\r\n              `Optional file ${fileName}.js not found for ${providerValue}`,\r\n            );\r\n          }\r\n        }\r\n      });\r\n\r\n      await Promise.all(downloadPromises);\r\n\r\n      // Verify required files were downloaded\r\n      const missingRequired = requiredFiles.filter(file => !modules[file]);\r\n      if (missingRequired.length > 0) {\r\n        throw new Error(\r\n          `Missing required files: ${missingRequired.join(', ')}`,\r\n        );\r\n      }\r\n\r\n      const providerModule: ProviderModule = {\r\n        value: providerValue,\r\n        version,\r\n        modules: {\r\n          posts: modules.posts,\r\n          meta: modules.meta,\r\n          stream: modules.stream,\r\n          catalog: modules.catalog,\r\n          episodes: modules.episodes,\r\n        },\r\n        cachedAt: Date.now(),\r\n      };\r\n\r\n      // Cache the modules\r\n      extensionStorage.cacheProviderModules(providerModule);\r\n\r\n      return providerModule;\r\n    } catch (error) {\r\n      console.error(`Failed to download modules for ${providerValue}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async downloadTestProviderModule(\r\n    providerValue: string,\r\n  ): Promise<ProviderModule> {\r\n    try {\r\n      const url = `${this.baseUrlTestMode}/dist/${providerValue}/`;\r\n      const requiredFiles = ['posts', 'meta', 'stream', 'catalog'];\r\n      const optionalFiles = ['episodes'];\r\n      const allFiles = [...requiredFiles, ...optionalFiles];\r\n      const modules: Record<string, string> = {};\r\n      const downloadPromises = allFiles.map(async fileName => {\r\n        try {\r\n          const fileUrl = `${url}${fileName}.js`;\r\n          console.log(`Downloading test module: ${fileUrl}`);\r\n\r\n          const response = await axios.get(fileUrl, {\r\n            timeout: 15000,\r\n          });\r\n\r\n          if (response.data) {\r\n            modules[fileName] = response.data;\r\n          } else {\r\n            throw new Error(`No data received for ${fileName}`);\r\n          }\r\n        } catch (error) {\r\n          // Only log error for required files\r\n          if (requiredFiles.includes(fileName)) {\r\n            console.error(\r\n              `Failed to download ${fileName}.js for ${providerValue}:`,\r\n              error,\r\n            );\r\n            throw error;\r\n          } else {\r\n            console.warn(\r\n              `Optional file ${fileName}.js not found for ${providerValue}`,\r\n            );\r\n          }\r\n        }\r\n      });\r\n\r\n      await Promise.all(downloadPromises);\r\n\r\n      if (!modules.posts) {\r\n        throw new Error(`No data received for ${providerValue}`);\r\n      }\r\n\r\n      const providerModule: ProviderModule = {\r\n        value: providerValue,\r\n        version: 'test',\r\n        modules: {\r\n          posts: modules.posts,\r\n          meta: modules.meta,\r\n          stream: modules.stream,\r\n          catalog: modules.catalog,\r\n          episodes: modules.episodes,\r\n        },\r\n        cachedAt: Date.now(),\r\n      };\r\n\r\n      // Cache the test module\r\n      this.testModuleCache.set(providerValue, {\r\n        module: providerModule,\r\n        cachedAt: Date.now(),\r\n      });\r\n\r\n      return providerModule;\r\n    } catch (error) {\r\n      console.error(\r\n        `Failed to download test module for ${providerValue}:`,\r\n        error,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Install a provider\r\n   */\r\n  async installProvider(provider: ProviderExtension): Promise<void> {\r\n    try {\r\n      // Download the provider modules\r\n      await this.downloadProviderModules(provider.value, provider.version);\r\n\r\n      // Mark as installed\r\n      extensionStorage.installProvider(provider);\r\n\r\n      console.log(`Successfully installed provider: ${provider.display_name}`);\r\n    } catch (error) {\r\n      console.error(\r\n        `Failed to install provider ${provider.display_name}:`,\r\n        error,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uninstall a provider\r\n   */\r\n  uninstallProvider(providerValue: string): void {\r\n    extensionStorage.uninstallProvider(providerValue);\r\n    console.log(`Uninstalled provider: ${providerValue}`);\r\n  }\r\n\r\n  /**\r\n   * Update a provider\r\n   */\r\n  async updateProvider(provider: ProviderExtension): Promise<void> {\r\n    try {\r\n      // Download updated modules\r\n      await this.downloadProviderModules(provider.value, provider.version);\r\n\r\n      // Update installation record\r\n      extensionStorage.installProvider(provider);\r\n\r\n      console.log(`Successfully updated provider: ${provider.display_name}`);\r\n    } catch (error) {\r\n      console.error(\r\n        `Failed to update provider ${provider.display_name}:`,\r\n        error,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n  /**\r\n   * Get cached provider modules (works synchronously for both normal and test mode)\r\n   */\r\n  getProviderModules(providerValue: string): ProviderModule | undefined {\r\n    if (this.testMode) {\r\n      // In test mode, return cached test module and trigger background refresh\r\n      const cached = this.testModuleCache.get(providerValue);\r\n      if (cached) {\r\n        // Trigger background refresh for next call\r\n        this.refreshTestModuleInBackground(providerValue);\r\n\r\n        return cached.module;\r\n      }\r\n      this.refreshTestModuleInBackground(providerValue);\r\n\r\n      // If no test cache exists, fall back to regular cache\r\n      console.warn(\r\n        `No test module cache found for ${providerValue}, falling back to regular cache`,\r\n      );\r\n    }\r\n\r\n    return extensionStorage.getProviderModules(providerValue);\r\n  }\r\n\r\n  /**\r\n   * Check if provider needs update\r\n   */\r\n  checkForUpdates(): ProviderExtension[] {\r\n    return extensionStorage.getProvidersNeedingUpdate();\r\n  }\r\n\r\n  /**\r\n   * Initialize extension system\r\n   */\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      // Load providers from cache\r\n      const installed = extensionStorage.getInstalledProviders();\r\n      const available = extensionStorage.getAvailableProviders();\r\n\r\n      console.log(`Loaded ${installed.length} installed providers`);\r\n      console.log(`Loaded ${available.length} available providers`);\r\n\r\n      // Try to fetch latest manifest if cache is expired\r\n      if (extensionStorage.isManifestCacheExpired()) {\r\n        try {\r\n          await this.fetchManifest(false);\r\n        } catch (error) {\r\n          console.warn('Failed to refresh manifest on startup:', error);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to initialize extension system:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enable/disable test mode\r\n   */\r\n  setTestMode(enabled: boolean): void {\r\n    this.testMode = enabled;\r\n    console.log(`Test mode ${enabled ? 'enabled' : 'disabled'}`);\r\n  }\r\n  /**\r\n   * Check if test module cache is expired\r\n   */\r\n  private isTestModuleCacheExpired(providerValue: string): boolean {\r\n    const cached = this.testModuleCache.get(providerValue);\r\n    if (!cached) {\r\n      return true;\r\n    }\r\n\r\n    return Date.now() - cached.cachedAt > this.testModuleCacheExpiry;\r\n  }\r\n  /**\r\n   * Pre-fetch test modules to ensure they're available synchronously\r\n   */\r\n  async preFetchTestModules(providerValues: string[]): Promise<void> {\r\n    if (!this.testMode) {\r\n      return;\r\n    }\r\n\r\n    console.log('Pre-fetching test modules for:', providerValues);\r\n\r\n    const fetchPromises = providerValues.map(async providerValue => {\r\n      try {\r\n        const module = await this.downloadTestProviderModule(providerValue);\r\n        this.testModuleCache.set(providerValue, {\r\n          module,\r\n          cachedAt: Date.now(),\r\n        });\r\n        console.log(`Pre-fetched test module for: ${providerValue}`);\r\n      } catch (error) {\r\n        console.error(\r\n          `Failed to pre-fetch test module for ${providerValue}:`,\r\n          error,\r\n        );\r\n      }\r\n    });\r\n\r\n    await Promise.allSettled(fetchPromises);\r\n  }\r\n  /**\r\n   * Refresh test module in background if needed\r\n   */\r\n  private refreshTestModuleInBackground(providerValue: string): void {\r\n    if (!this.testMode) {\r\n      return;\r\n    }\r\n\r\n    // Refresh in background without blocking\r\n    this.downloadTestProviderModule(providerValue)\r\n      .then(module => {\r\n        this.testModuleCache.set(providerValue, {\r\n          module,\r\n          cachedAt: Date.now(),\r\n        });\r\n        console.log(`Background refreshed test module for: ${providerValue}`);\r\n      })\r\n      .catch(error => {\r\n        console.error(\r\n          `Failed to background refresh test module for ${providerValue}:`,\r\n          error,\r\n        );\r\n      });\r\n  }\r\n}\r\n\r\n/**\r\n * Global extension manager instance\r\n */\r\nexport const extensionManager = ExtensionManager.getInstance();\r\n","size_bytes":12322},"src/lib/services/Notification.ts":{"content":"import notifee, {\r\n  AndroidImportance,\r\n  EventDetail,\r\n  EventType,\r\n} from '@notifee/react-native';\r\nimport {settingsStorage} from '../storage';\r\nimport * as RNFS from '@dr.pogodin/react-native-fs';\r\nimport {downloadFolder} from '../constants';\r\nimport {cancelHlsDownload} from '../hlsDownloader2';\r\nimport RNApkInstaller from '@himanshu8443/react-native-apk-installer';\r\n\r\nexport interface NotificationOptions {\r\n  id: string;\r\n  title: string;\r\n  body: string;\r\n  data?: any;\r\n  progress?: {\r\n    max: number;\r\n    current: number;\r\n    indeterminate?: boolean;\r\n  };\r\n  actions?: Array<{\r\n    title: string;\r\n    pressAction: {\r\n      id: string;\r\n    };\r\n  }>;\r\n  onlyAlertOnce?: boolean;\r\n}\r\n\r\nexport interface ChannelOptions {\r\n  id: string;\r\n  name: string;\r\n  importance?: AndroidImportance;\r\n  description?: string;\r\n}\r\n\r\nclass NotificationService {\r\n  private _defaultChannelId = 'default';\r\n  private _downloadChannelId = 'download';\r\n  private _updateChannelId = 'update';\r\n  private initialized = false;\r\n\r\n  constructor() {\r\n    this.initialize();\r\n  }\r\n  private async initialize() {\r\n    if (this.initialized) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Create default channels\r\n      await this.createDefaultChannels();\r\n      this.initialized = true;\r\n    } catch (error) {\r\n      console.error('Failed to initialize notification service:', error);\r\n    }\r\n  }\r\n\r\n  private async createDefaultChannels() {\r\n    // Default channel\r\n    await notifee.createChannel({\r\n      id: this._defaultChannelId,\r\n      name: 'Default Notifications',\r\n      importance: AndroidImportance.DEFAULT,\r\n    });\r\n\r\n    // Download channel\r\n    await notifee.createChannel({\r\n      id: this._downloadChannelId,\r\n      name: 'Download Notifications',\r\n      importance: AndroidImportance.HIGH,\r\n      description: 'Notifications for download progress and completion',\r\n    });\r\n\r\n    // Update channel\r\n    await notifee.createChannel({\r\n      id: this._updateChannelId,\r\n      name: 'Update Notifications',\r\n      importance: AndroidImportance.DEFAULT,\r\n      description: 'Notifications for app and provider updates',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Request notification permission\r\n   */\r\n  async requestPermission(): Promise<any> {\r\n    await this.ensureInitialized();\r\n    return await notifee.requestPermission();\r\n  }\r\n\r\n  /**\r\n   * Create a custom channel\r\n   */\r\n  async createChannel(options: ChannelOptions): Promise<string> {\r\n    await this.ensureInitialized();\r\n    return await notifee.createChannel({\r\n      id: options.id,\r\n      name: options.name,\r\n      importance: options.importance || AndroidImportance.DEFAULT,\r\n      description: options.description,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Display a notification with common settings\r\n   */\r\n  async displayNotification(\r\n    options: NotificationOptions,\r\n    channelId?: string,\r\n  ): Promise<void> {\r\n    await this.ensureInitialized();\r\n    const primary = settingsStorage.getPrimaryColor();\r\n\r\n    await notifee.displayNotification({\r\n      id: options.id,\r\n      title: options.title,\r\n      body: options.body,\r\n      data: options.data,\r\n      android: {\r\n        smallIcon: 'ic_notification',\r\n        channelId: channelId || this._defaultChannelId,\r\n        color: primary,\r\n        pressAction: {\r\n          id: 'default',\r\n        },\r\n\r\n        progress: options.progress,\r\n        actions: options.actions,\r\n        onlyAlertOnce: options.onlyAlertOnce || false,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Display a download notification\r\n   */\r\n  async displayDownloadNotification(\r\n    options: NotificationOptions,\r\n  ): Promise<void> {\r\n    await this.displayNotification(options, this._downloadChannelId);\r\n  }\r\n\r\n  /**\r\n   * Display an update notification\r\n   */\r\n  async displayUpdateNotification(options: NotificationOptions): Promise<void> {\r\n    await this.displayNotification(options, this._updateChannelId);\r\n  }\r\n\r\n  /**\r\n   * Cancel a notification\r\n   */\r\n  async cancelNotification(notificationId: string): Promise<void> {\r\n    await this.ensureInitialized();\r\n    await notifee.cancelNotification(notificationId);\r\n  }\r\n\r\n  /**\r\n   * Cancel all notifications\r\n   */\r\n  async cancelAllNotifications(): Promise<void> {\r\n    await this.ensureInitialized();\r\n    await notifee.cancelAllNotifications();\r\n  }\r\n\r\n  /**\r\n   * Helper method to show download starting notification\r\n   */\r\n  async showDownloadStarting(title: string, fileName: string): Promise<void> {\r\n    await this.displayDownloadNotification({\r\n      id: fileName,\r\n      title: title,\r\n      body: 'Starting download',\r\n      progress: {\r\n        max: 100,\r\n        current: 0,\r\n        indeterminate: true,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Helper method to show download progress notification\r\n   */\r\n  async showDownloadProgress(\r\n    title: string,\r\n    fileName: string,\r\n    progress: number,\r\n    progressText: string,\r\n    jobId?: number,\r\n  ): Promise<void> {\r\n    await this.displayDownloadNotification({\r\n      id: fileName,\r\n      title: title,\r\n      body: progressText,\r\n      data: {jobId, fileName},\r\n      progress: {\r\n        max: 100,\r\n        current: Math.min(Math.max(progress * 100, 0), 100),\r\n        indeterminate: false,\r\n      },\r\n      actions: [\r\n        {\r\n          title: 'Cancel',\r\n          pressAction: {\r\n            id: fileName,\r\n          },\r\n        },\r\n      ],\r\n      onlyAlertOnce: true,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Helper method to show download complete notification\r\n   */\r\n  async showDownloadComplete(title: string, fileName: string): Promise<void> {\r\n    await this.cancelNotification(fileName);\r\n    await this.displayDownloadNotification({\r\n      id: `downloadComplete${fileName}`,\r\n      title: 'Download complete',\r\n      body: title,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Helper method to show download failed notification\r\n   */\r\n  async showDownloadFailed(title: string, fileName: string): Promise<void> {\r\n    await this.cancelNotification(fileName);\r\n    await this.displayDownloadNotification({\r\n      id: `downloadFailed${fileName}`,\r\n      title: 'Download failed',\r\n      body: title,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Helper method to show update available notification\r\n   */\r\n  async showUpdateAvailable(\r\n    title: string,\r\n    body: string,\r\n    actions?: Array<{title: string; pressAction: {id: string}}>,\r\n  ): Promise<void> {\r\n    await this.displayUpdateNotification({\r\n      id: 'updateAvailable',\r\n      title: title,\r\n      body: body,\r\n      actions: actions,\r\n    });\r\n  }\r\n\r\n  async actionHandler({type, detail}: {type: EventType; detail: EventDetail}) {\r\n    console.log('Notification action', type, detail);\r\n    console.log('EventType.PRESS:', EventType.PRESS);\r\n    console.log('EventType.ACTION_PRESS:', EventType.ACTION_PRESS);\r\n    console.log('Actual type received:', type);\r\n    console.log('pressAction:', detail.pressAction);\r\n\r\n    // Handle download cancellation\r\n    if (\r\n      type === EventType.ACTION_PRESS &&\r\n      detail.pressAction?.id === detail.notification?.data?.fileName\r\n    ) {\r\n      // console.log('Cancel download');\r\n      RNFS.stopDownload(Number(detail.notification?.data?.jobId));\r\n      cancelHlsDownload(detail.notification?.data?.fileName!);\r\n      // FFMPEGKIT CANCEL\r\n      // FFmpegKit.cancel(Number(detail.notification?.data?.jobId));\r\n\r\n      // setAlreadyDownloaded(false);\r\n      try {\r\n        const files = await RNFS.readDir(downloadFolder);\r\n        // Find a file with the given name (without extension)\r\n        const foundFile = files.find(fileItem => {\r\n          const nameWithoutExtension = fileItem.name\r\n            .split('.')\r\n            .slice(0, -1)\r\n            .join('.');\r\n          return nameWithoutExtension === detail.notification?.data?.fileName;\r\n        });\r\n        if (foundFile) {\r\n          await RNFS.unlink(foundFile.path);\r\n        }\r\n      } catch (error) {\r\n        console.log(error);\r\n      }\r\n    }\r\n\r\n    // Handle app update installation - check for both PRESS and ACTION_PRESS\r\n    if (\r\n      (type === EventType.PRESS || type === EventType.ACTION_PRESS) &&\r\n      (detail.pressAction?.id === 'install' ||\r\n        detail.notification?.data?.action === 'install')\r\n    ) {\r\n      console.log('Install action pressed');\r\n      const apkPath = `${RNFS.DownloadDirectoryPath}/${detail.notification?.data?.name}`;\r\n      console.log('APK path:', apkPath);\r\n      const res = await RNFS.exists(apkPath);\r\n      console.log('APK exists:', res);\r\n      if (res) {\r\n        console.log('Starting APK installation...');\r\n        try {\r\n          await RNApkInstaller.install(apkPath);\r\n          console.log('APK installation initiated successfully');\r\n        } catch (error) {\r\n          console.error('APK installation error:', error);\r\n        }\r\n      } else {\r\n        console.error('APK file not found at path:', apkPath);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper method to show update progress notification\r\n   */\r\n  async showUpdateProgress(\r\n    title: string,\r\n    body: string,\r\n    progress?: {max: number; current: number; indeterminate?: boolean},\r\n  ): Promise<void> {\r\n    await this.displayUpdateNotification({\r\n      id: 'updateProgress',\r\n      title: title,\r\n      body: body,\r\n      progress: progress,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the default download channel ID\r\n   */\r\n  getDownloadChannelId(): string {\r\n    return this._downloadChannelId;\r\n  }\r\n\r\n  /**\r\n   * Get the default update channel ID\r\n   */\r\n  getUpdateChannelId(): string {\r\n    return this._updateChannelId;\r\n  }\r\n\r\n  /**\r\n   * Get the default channel ID\r\n   */\r\n  getDefaultChannelId(): string {\r\n    return this._defaultChannelId;\r\n  }\r\n\r\n  private async ensureInitialized(): Promise<void> {\r\n    if (!this.initialized) {\r\n      await this.initialize();\r\n    }\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const notificationService = new NotificationService();\r\nexport default notificationService;\r\n","size_bytes":9902},"src/lib/services/ProviderManager.ts":{"content":"import {ToastAndroid} from 'react-native';\r\nimport {providerContext} from '../providers/providerContext';\r\nimport {Catalog, EpisodeLink, Info, Post} from '../providers/types';\r\nimport {extensionManager} from './ExtensionManager';\r\n\r\nexport class ProviderManager {\r\n  private createExecutionContext() {\r\n    return {\r\n      exports: {},\r\n      require: () => ({}), // Mock require function\r\n      module: {exports: {}},\r\n      console,\r\n      Promise,\r\n      __awaiter: (thisArg: any, _arguments: any, P: any, generator: any) => {\r\n        function adopt(value: any) {\r\n          return value instanceof P\r\n            ? value\r\n            : new P(function (resolve: any) {\r\n                resolve(value);\r\n              });\r\n        }\r\n        return new (P || (P = Promise))(function (resolve: any, reject: any) {\r\n          function fulfilled(value: any) {\r\n            try {\r\n              step(generator.next(value));\r\n            } catch (e) {\r\n              reject(e);\r\n            }\r\n          }\r\n          function rejected(value: any) {\r\n            try {\r\n              step(generator.throw(value));\r\n            } catch (e) {\r\n              reject(e);\r\n            }\r\n          }\r\n          function step(result: any) {\r\n            result.done\r\n              ? resolve(result.value)\r\n              : adopt(result.value).then(fulfilled, rejected);\r\n          }\r\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n      },\r\n      Object,\r\n    };\r\n  }\r\n\r\n  private executeModule(moduleCode: string, ...args: any[]): any {\r\n    const context = this.createExecutionContext();\r\n\r\n    const executeModule = new Function(\r\n      'context',\r\n      ...Array.from({length: args.length}, (_, i) => `arg${i}`),\r\n      `\r\n      const exports = context.exports;\r\n      const __awaiter = context.__awaiter;\r\n      const Object = context.Object;\r\n      const console = context.console;\r\n      const Promise = context.Promise;\r\n      \r\n      ${moduleCode}\r\n      \r\n      return exports;\r\n      `,\r\n    );\r\n    return executeModule(context, ...args);\r\n  }\r\n  getCatalog = ({providerValue}: {providerValue: string}): Catalog[] => {\r\n    // Use extensionManager which now handles test mode automatically\r\n    const catalogModule =\r\n      extensionManager.getProviderModules(providerValue)?.modules.catalog;\r\n    if (!catalogModule) {\r\n      return [];\r\n    }\r\n    try {\r\n      const moduleExports = this.executeModule(catalogModule);\r\n\r\n      // Return the catalog array directly from exports\r\n      return moduleExports.catalog || [];\r\n    } catch (error) {\r\n      console.error('Error loading catalog:', error);\r\n      console.error('Module content:', catalogModule);\r\n      throw new Error(`Invalid catalog module for provider: ${providerValue}`);\r\n    }\r\n  };\r\n  getGenres = ({providerValue}: {providerValue: string}): Catalog[] => {\r\n    // Use extensionManager which now handles test mode automatically\r\n    const catalogModule =\r\n      extensionManager.getProviderModules(providerValue)?.modules.catalog;\r\n    if (!catalogModule) {\r\n      return [];\r\n    }\r\n    try {\r\n      const moduleExports = this.executeModule(catalogModule);\r\n\r\n      // Return the genres array directly from exports\r\n      return moduleExports.genres || [];\r\n    } catch (error) {\r\n      console.error('Error loading genres:', error);\r\n      console.error('Module content:', catalogModule);\r\n      throw new Error(`Invalid catalog module for provider: ${providerValue}`);\r\n    }\r\n  };\r\n  getPosts = async ({\r\n    filter,\r\n    page,\r\n    providerValue,\r\n    signal,\r\n  }: {\r\n    filter: string;\r\n    page: number;\r\n    providerValue: string;\r\n    signal: AbortSignal;\r\n  }): Promise<Post[]> => {\r\n    // Use extensionManager which now handles test mode automatically\r\n    const getPostsModule =\r\n      extensionManager.getProviderModules(providerValue)?.modules.posts;\r\n    if (!getPostsModule) {\r\n      throw new Error(`No posts module found for provider: ${providerValue}`);\r\n    }\r\n    try {\r\n      const moduleExports = this.executeModule(\r\n        getPostsModule,\r\n        filter,\r\n        page,\r\n        providerValue,\r\n        signal,\r\n        providerContext,\r\n      );\r\n\r\n      // Call the getPosts function\r\n      return await moduleExports.getPosts({\r\n        filter,\r\n        page,\r\n        providerValue,\r\n        signal,\r\n        providerContext,\r\n      });\r\n    } catch (error) {\r\n      console.error('Error creating posts function:', error);\r\n      console.error('Module content:', getPostsModule);\r\n      throw new Error(`Invalid posts module for provider: ${providerValue}`);\r\n    }\r\n  };\r\n  getSearchPosts = async ({\r\n    searchQuery,\r\n    page,\r\n    providerValue,\r\n    signal,\r\n  }: {\r\n    searchQuery: string;\r\n    page: number;\r\n    providerValue: string;\r\n    signal: AbortSignal;\r\n  }): Promise<Post[]> => {\r\n    // Use extensionManager which now handles test mode automatically\r\n    const getPostsModule =\r\n      extensionManager.getProviderModules(providerValue)?.modules.posts;\r\n    if (!getPostsModule) {\r\n      throw new Error(`No posts module found for provider: ${providerValue}`);\r\n    }\r\n    try {\r\n      const moduleExports = this.executeModule(\r\n        getPostsModule,\r\n        searchQuery,\r\n        page,\r\n        providerValue,\r\n        signal,\r\n        providerContext,\r\n      );\r\n\r\n      // Call the getSearchPosts function\r\n      return await moduleExports.getSearchPosts({\r\n        searchQuery,\r\n        page,\r\n        providerValue,\r\n        signal,\r\n        providerContext,\r\n      });\r\n    } catch (error) {\r\n      console.error('Error creating search posts function:', error);\r\n      console.error('Module content:', getPostsModule);\r\n      throw new Error(`Invalid posts module for provider: ${providerValue}`);\r\n    }\r\n  };\r\n  getMetaData = async ({\r\n    link,\r\n    provider,\r\n  }: {\r\n    link: string;\r\n    provider: string;\r\n  }): Promise<Info> => {\r\n    // Use extensionManager which now handles test mode automatically\r\n    const getMetaDataModule =\r\n      extensionManager.getProviderModules(provider)?.modules.meta;\r\n    if (!getMetaDataModule) {\r\n      throw new Error(`No meta data module found for provider: ${provider}`);\r\n    }\r\n    try {\r\n      const moduleExports = this.executeModule(\r\n        getMetaDataModule,\r\n        link,\r\n        provider,\r\n        providerContext,\r\n      );\r\n\r\n      // Call the getMetaData function\r\n      return await moduleExports.getMeta({\r\n        link,\r\n        provider,\r\n        providerContext,\r\n      });\r\n    } catch (error) {\r\n      console.error('Error creating meta data function:', error);\r\n      console.error('Module content:', getMetaDataModule);\r\n      throw new Error(`Invalid meta data module for provider: ${provider}`);\r\n    }\r\n  };\r\n  getStream = async ({\r\n    link,\r\n    type,\r\n    signal,\r\n    providerValue,\r\n  }: {\r\n    link: string;\r\n    type: string;\r\n    signal: AbortSignal;\r\n    providerValue: string;\r\n  }): Promise<any[]> => {\r\n    // Use extensionManager which now handles test mode automatically\r\n    const getStreamModule =\r\n      extensionManager.getProviderModules(providerValue)?.modules.stream;\r\n    if (!getStreamModule) {\r\n      throw new Error(`No stream module found for provider: ${providerValue}`);\r\n    }\r\n    try {\r\n      const moduleExports = this.executeModule(\r\n        getStreamModule,\r\n        link,\r\n        type,\r\n        signal,\r\n        providerContext,\r\n      );\r\n\r\n      // Call the getStream function\r\n      return await moduleExports.getStream({\r\n        link,\r\n        type,\r\n        signal,\r\n        providerContext,\r\n      });\r\n    } catch (error) {\r\n      console.error('Error creating stream function:', error);\r\n      console.error('Module content:', getStreamModule);\r\n      throw new Error(`Invalid stream module for provider: ${providerValue}`);\r\n    }\r\n  };\r\n  getEpisodes = async ({\r\n    url,\r\n    providerValue,\r\n  }: {\r\n    url: string;\r\n    providerValue: string;\r\n  }): Promise<EpisodeLink[]> => {\r\n    // Use extensionManager which now handles test mode automatically\r\n    const getEpisodeLinksModule =\r\n      extensionManager.getProviderModules(providerValue)?.modules.episodes;\r\n    if (!getEpisodeLinksModule) {\r\n      throw new Error(\r\n        `No episode links module found for provider: ${providerValue}`,\r\n      );\r\n    }\r\n    try {\r\n      const moduleExports = this.executeModule(\r\n        getEpisodeLinksModule,\r\n        url,\r\n        providerContext,\r\n      );\r\n\r\n      // Call the getEpisodes function\r\n      return await moduleExports.getEpisodes({\r\n        url,\r\n        providerContext,\r\n      });\r\n    } catch (error) {\r\n      console.error('Error creating episode links function:', error);\r\n      console.error('Module content:', getEpisodeLinksModule);\r\n      ToastAndroid.show(\r\n        `Invalid episode links module for provider: ${providerValue}`,\r\n        ToastAndroid.LONG,\r\n      );\r\n      throw new Error(\r\n        `Invalid episode links module for provider: ${providerValue}`,\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\nexport const providerManager = new ProviderManager();\r\n","size_bytes":9069},"src/lib/services/UpdateProviders.ts":{"content":"import {AndroidImportance} from '@notifee/react-native';\r\nimport {extensionStorage, ProviderExtension} from '../storage/extensionStorage';\r\nimport {extensionManager} from './ExtensionManager';\r\nimport {settingsStorage} from '../storage';\r\nimport {notificationService} from './Notification';\r\n\r\nexport interface UpdateInfo {\r\n  provider: ProviderExtension;\r\n  currentVersion: string;\r\n  newVersion: string;\r\n  hasUpdate: boolean;\r\n}\r\n\r\nclass UpdateProvidersService {\r\n  private isUpdating = false;\r\n  private updateCheckInterval: NodeJS.Timeout | null = null;\r\n\r\n  /**\r\n   * Check for updates for all installed providers\r\n   */\r\n  async checkForUpdates(): Promise<UpdateInfo[]> {\r\n    try {\r\n      const installedProviders = extensionStorage.getInstalledProviders();\r\n      const availableProviders = await extensionManager.fetchManifest(true);\r\n\r\n      const updateInfos: UpdateInfo[] = [];\r\n\r\n      for (const installed of installedProviders) {\r\n        const available = availableProviders.find(\r\n          p => p.value === installed.value,\r\n        );\r\n\r\n        if (\r\n          available &&\r\n          this.isNewerVersion(available.version, installed.version)\r\n        ) {\r\n          updateInfos.push({\r\n            provider: available,\r\n            currentVersion: installed.version,\r\n            newVersion: available.version,\r\n            hasUpdate: true,\r\n          });\r\n        } else {\r\n          updateInfos.push({\r\n            provider: installed,\r\n            currentVersion: installed.version,\r\n            newVersion: installed.version,\r\n            hasUpdate: false,\r\n          });\r\n        }\r\n      }\r\n\r\n      return updateInfos;\r\n    } catch (error) {\r\n      console.error('Error checking for updates:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a specific provider\r\n   */\r\n  async updateProvider(provider: ProviderExtension): Promise<boolean> {\r\n    try {\r\n      // Uninstall old version\r\n      extensionStorage.uninstallProvider(provider.value);\r\n\r\n      // Install new version\r\n      await extensionManager.installProvider(provider);\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating provider:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update multiple providers with progress notifications\r\n   */\r\n  async updateProviders(providers: ProviderExtension[]): Promise<{\r\n    updated: ProviderExtension[];\r\n    failed: ProviderExtension[];\r\n  }> {\r\n    if (this.isUpdating || providers.length === 0) {\r\n      return {updated: [], failed: []};\r\n    }\r\n\r\n    this.isUpdating = true;\r\n    const updated: ProviderExtension[] = [];\r\n    const failed: ProviderExtension[] = [];\r\n\r\n    try {\r\n      // Show updating notification\r\n      await this.showUpdatingNotification(providers);\r\n\r\n      for (const provider of providers) {\r\n        const success = await this.updateProvider(provider);\r\n        if (success) {\r\n          updated.push(provider);\r\n        } else {\r\n          failed.push(provider);\r\n        }\r\n      }\r\n\r\n      // Show completion notification\r\n      await this.showUpdateCompleteNotification(updated, failed);\r\n\r\n      return {updated, failed};\r\n    } finally {\r\n      this.isUpdating = false;\r\n    }\r\n  }\r\n  /**\r\n   * Check for updates and automatically start updating if updates are available\r\n   */\r\n  async checkForUpdatesAndAutoUpdate(): Promise<UpdateInfo[]> {\r\n    const updateInfos = await this.checkForUpdates();\r\n    const availableUpdates = updateInfos.filter(info => info.hasUpdate);\r\n    if (\r\n      availableUpdates.length > 0 &&\r\n      settingsStorage.isNotificationsEnabled()\r\n    ) {\r\n      // Automatically start updating instead of just showing notification\r\n      const providersToUpdate = availableUpdates.map(update => update.provider);\r\n      // Don't await here to avoid blocking - let it run in background\r\n      this.updateProviders(providersToUpdate);\r\n    }\r\n    return updateInfos;\r\n  }\r\n\r\n  /**\r\n   * Check for updates without auto-updating (for manual refresh)\r\n   */\r\n  async checkForUpdatesManual(): Promise<UpdateInfo[]> {\r\n    return await this.checkForUpdates();\r\n  }\r\n\r\n  /**\r\n   * Start automatic update checking\r\n   */\r\n  startAutomaticUpdateCheck(): void {\r\n    // Check immediately\r\n    this.checkForUpdatesAndAutoUpdate();\r\n\r\n    // Check every 6 hours\r\n    this.updateCheckInterval = setInterval(\r\n      () => {\r\n        this.checkForUpdatesAndAutoUpdate();\r\n      },\r\n      6 * 60 * 60 * 1000,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Stop automatic update checking\r\n   */\r\n  stopAutomaticUpdateCheck(): void {\r\n    if (this.updateCheckInterval) {\r\n      clearInterval(this.updateCheckInterval);\r\n      this.updateCheckInterval = null;\r\n    }\r\n  }\r\n  /**\r\n   * Compare version strings to determine if newVersion is newer than currentVersion\r\n   */\r\n  private isNewerVersion(newVersion: string, currentVersion: string): boolean {\r\n    const parseVersion = (version: string) => {\r\n      return version.split('.').map(part => parseInt(part, 10) || 0);\r\n    };\r\n\r\n    const newParts = parseVersion(newVersion);\r\n    const currentParts = parseVersion(currentVersion);\r\n\r\n    for (let i = 0; i < Math.max(newParts.length, currentParts.length); i++) {\r\n      const newPart = newParts[i] || 0;\r\n      const currentPart = currentParts[i] || 0;\r\n\r\n      if (newPart > currentPart) {\r\n        return true;\r\n      }\r\n      if (newPart < currentPart) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Show notification when providers are being updated\r\n   */\r\n  private async showUpdatingNotification(\r\n    providers: ProviderExtension[],\r\n  ): Promise<void> {\r\n    await notificationService.showUpdateProgress(\r\n      'Updating Providers',\r\n      `Updating ${providers.length} provider${\r\n        providers.length > 1 ? 's' : ''\r\n      }...`,\r\n      {\r\n        max: 100,\r\n        current: 0,\r\n        indeterminate: true,\r\n      },\r\n    );\r\n  }\r\n\r\n  /**   * Show notification when updates are complete\r\n   */\r\n  private async showUpdateCompleteNotification(\r\n    updated: ProviderExtension[],\r\n    failed: ProviderExtension[],\r\n  ): Promise<void> {\r\n    // Cancel the updating notification\r\n    await notificationService.cancelNotification('updateProgress');\r\n\r\n    if (updated.length === 0 && failed.length === 0) {\r\n      return;\r\n    }\r\n\r\n    let title = '';\r\n    let body = '';\r\n\r\n    if (updated.length > 0 && failed.length === 0) {\r\n      title = 'Providers Updated Successfully';\r\n      body = `${updated.length} provider${\r\n        updated.length > 1 ? 's' : ''\r\n      } updated: ${updated.map(p => p.display_name).join(', ')}`;\r\n    } else if (updated.length > 0 && failed.length > 0) {\r\n      title = 'Providers Update Complete';\r\n      body = `${updated.length} updated, ${failed.length} failed`;\r\n    } else {\r\n      title = 'Provider Update Failed';\r\n      body = `Failed to update ${failed.length} provider${\r\n        failed.length > 1 ? 's' : ''\r\n      }`;\r\n    }\r\n\r\n    await notificationService.displayUpdateNotification({\r\n      id: 'providers-updated',\r\n      title,\r\n      body,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get current updating state\r\n   */\r\n  get updating(): boolean {\r\n    return this.isUpdating;\r\n  }\r\n}\r\n\r\nexport const updateProvidersService = new UpdateProvidersService();\r\n","size_bytes":7245},"src/lib/services/index.ts":{"content":"// Export ExtensionManager\r\nexport {ExtensionManager, extensionManager} from './ExtensionManager';\r\n\r\n// Export ProviderManager\r\nexport {ProviderManager, providerManager} from './ProviderManager';\r\n\r\n// Export DownloadManager\r\nexport {DownloadManager, downloadManager} from './DownloadManager';\r\n","size_bytes":296},"src/lib/services/omdb.ts":{"content":"import { OMDBResult, OMDBResponse } from '../types/omdb';\n\nconst OMDB_API_KEY = '7755307f';\nconst BASE_URL = 'https://www.omdbapi.com';\n\nexport const searchOMDB = async (query: string): Promise<OMDBResult[]> => {\n  if (!query) {\n    return [];\n  }\n\n  try {\n    const response = await fetch(\n      `${BASE_URL}/?apikey=${OMDB_API_KEY}&s=${encodeURIComponent(query)}`,\n    );\n    const data: OMDBResponse = await response.json();\n    return data.Response === 'True' ? data.Search : [];\n  } catch (error) {\n    console.error('OMDB search error:', error);\n    return [];\n  }\n};\n","size_bytes":574},"src/lib/storage/CacheStorage.ts":{"content":"import {cacheStorage} from './StorageService';\r\n\r\n/**\r\n * Cache storage manager for storing temporary data\r\n */\r\nexport class CacheStorage {\r\n  /**\r\n   * Set a string value in cache\r\n   */\r\n  setString(key: string, value: string): void {\r\n    cacheStorage.setString(key, value);\r\n  }\r\n\r\n  /**\r\n   * Get a string value from cache\r\n   */\r\n  getString(key: string): string | undefined {\r\n    return cacheStorage.getString(key);\r\n  }\r\n\r\n  /**\r\n   * Set a boolean value in cache\r\n   */\r\n  setBool(key: string, value: boolean): void {\r\n    cacheStorage.setBool(key, value);\r\n  }\r\n\r\n  /**\r\n   * Get a boolean value from cache\r\n   */\r\n  getBool(key: string): boolean | undefined {\r\n    return cacheStorage.getBool(key, undefined);\r\n  }\r\n\r\n  /**\r\n   * Set an object value in cache\r\n   */\r\n  setObject<T>(key: string, value: T): void {\r\n    cacheStorage.setObject(key, value);\r\n  }\r\n\r\n  /**\r\n   * Get an object value from cache\r\n   */\r\n  getObject<T>(key: string): T | undefined {\r\n    return cacheStorage.getObject<T>(key);\r\n  }\r\n\r\n  /**\r\n   * Delete a value from cache\r\n   */\r\n  delete(key: string): void {\r\n    cacheStorage.delete(key);\r\n  }\r\n\r\n  /**\r\n   * Check if a key exists in cache\r\n   */\r\n  contains(key: string): boolean {\r\n    return cacheStorage.contains(key);\r\n  }\r\n\r\n  /**\r\n   * Clear all cache\r\n   */\r\n  clearAll(): void {\r\n    cacheStorage.clearAll();\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const cacheStorageService = new CacheStorage();\r\n","size_bytes":1456},"src/lib/storage/DownloadsStorage.ts":{"content":"import {cacheStorage, mainStorage} from './StorageService';\r\nimport * as FileSystem from 'expo-file-system';\r\n\r\n/**\r\n * Storage keys for downloads\r\n */\r\nexport enum DownloadsKeys {\r\n  FILES = 'downloadFiles',\r\n  THUMBNAILS = 'downloadThumbnails',\r\n  DOWNLOADED_FILES = 'downloadedFiles',\r\n}\r\n\r\nexport interface DownloadPayload {\r\n  id?: number;\r\n  url?: string;\r\n  fileName: string;\r\n  provider: string;\r\n  progress?: number;\r\n  folderName: string;\r\n  fileType: string;\r\n  status: 'downloading' | 'paused' | 'downloaded';\r\n}\r\n\r\n/**\r\n * Downloads storage manager\r\n */\r\n\r\nexport class DownloadsStorage {\r\n  /**\r\n   * Get all downloaded files\r\n   */\r\n  getDownloads(): Map<string, DownloadPayload> {\r\n    const downloadsString = mainStorage.getString(\r\n      DownloadsKeys.DOWNLOADED_FILES,\r\n    );\r\n    if (!downloadsString) {\r\n      return new Map<string, DownloadPayload>();\r\n    }\r\n    try {\r\n      const downloads: Record<string, DownloadPayload> =\r\n        JSON.parse(downloadsString);\r\n      return new Map(Object.entries(downloads));\r\n    } catch (error) {\r\n      console.error('Failed to parse downloads:', error);\r\n      return new Map<string, DownloadPayload>();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save downloaded files information\r\n   */\r\n  saveDownloads(downloads: Map<string, DownloadPayload>): void {\r\n    mainStorage.setString(\r\n      DownloadsKeys.DOWNLOADED_FILES,\r\n      JSON.stringify(Object.fromEntries(downloads)),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Save download files information\r\n   */\r\n  saveFilesInfo(files: FileSystem.FileInfo[]): void {\r\n    cacheStorage.setObject(DownloadsKeys.FILES, files);\r\n  }\r\n\r\n  /**\r\n   * Get download files information\r\n   */\r\n  getFilesInfo(): FileSystem.FileInfo[] | null {\r\n    return (\r\n      cacheStorage.getObject<FileSystem.FileInfo[]>(DownloadsKeys.FILES) || null\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Save download thumbnails\r\n   */\r\n  saveThumbnails(thumbnails: Record<string, string>): void {\r\n    cacheStorage.setObject(DownloadsKeys.THUMBNAILS, thumbnails);\r\n  }\r\n\r\n  /**\r\n   * Get download thumbnails\r\n   */\r\n  getThumbnails(): Record<string, string> | null {\r\n    return (\r\n      cacheStorage.getObject<Record<string, string>>(\r\n        DownloadsKeys.THUMBNAILS,\r\n      ) || null\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clear downloads cache\r\n   */\r\n  clearCache(): void {\r\n    cacheStorage.delete(DownloadsKeys.FILES);\r\n    cacheStorage.delete(DownloadsKeys.THUMBNAILS);\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const downloadsStorage = new DownloadsStorage();\r\n","size_bytes":2502},"src/lib/storage/ProvidersStorage.ts":{"content":"import {mainStorage} from './StorageService';\r\nimport {providersList} from '../constants';\r\n\r\n/**\r\n * Storage keys for providers\r\n */\r\nexport enum ProvidersKeys {\r\n  DISABLED_PROVIDERS = 'disabledProviders',\r\n}\r\n\r\n/**\r\n * Providers storage manager\r\n */\r\nexport class ProvidersStorage {\r\n  /**\r\n   * Get disabled providers list\r\n   */\r\n  getDisabledProviders(): string[] {\r\n    const saved = mainStorage.getObject<string[]>(\r\n      ProvidersKeys.DISABLED_PROVIDERS,\r\n    );\r\n    if (!saved || saved.length === 0) {\r\n      const allProviders = providersList.map(p => p.value);\r\n      this.setDisabledProviders(allProviders);\r\n      return allProviders;\r\n    }\r\n    return saved;\r\n  }\r\n\r\n  /**\r\n   * Set disabled providers list\r\n   */\r\n  setDisabledProviders(providers: string[]): void {\r\n    mainStorage.setObject(ProvidersKeys.DISABLED_PROVIDERS, providers);\r\n  }\r\n\r\n  /**\r\n   * Enable all providers\r\n   */\r\n  enableAllProviders(): void {\r\n    mainStorage.setObject(ProvidersKeys.DISABLED_PROVIDERS, []);\r\n  }\r\n\r\n  /**\r\n   * Toggle provider enabled/disabled status\r\n   */\r\n  toggleProvider(providerId: string): string[] {\r\n    const disabledProviders = this.getDisabledProviders();\r\n\r\n    const newDisabled = disabledProviders.includes(providerId)\r\n      ? disabledProviders.filter(id => id !== providerId)\r\n      : [...disabledProviders, providerId];\r\n\r\n    this.setDisabledProviders(newDisabled);\r\n    return newDisabled;\r\n  }\r\n\r\n  /**\r\n   * Check if a provider is disabled\r\n   */\r\n  isProviderDisabled(providerId: string): boolean {\r\n    const disabledProviders = this.getDisabledProviders();\r\n    return disabledProviders.includes(providerId);\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const providersStorage = new ProvidersStorage();\r\n","size_bytes":1747},"src/lib/storage/SettingsStorage.ts":{"content":"import {mainStorage} from './StorageService';\r\n\r\n/**\r\n * Storage keys for settings\r\n */\r\nexport enum SettingsKeys {\r\n  // UI preferences\r\n  PRIMARY_COLOR = 'primaryColor',\r\n  IS_CUSTOM_THEME = 'isCustomTheme',\r\n  SHOW_TAB_BAR_LABELS = 'showTabBarLabels',\r\n  CUSTOM_COLOR = 'customColor',\r\n  // Feedback settings\r\n  HAPTIC_FEEDBACK = 'hapticFeedback',\r\n  NOTIFICATIONS_ENABLED = 'notificationsEnabled',\r\n\r\n  // Update settings\r\n  AUTO_CHECK_UPDATE = 'autoCheckUpdate',\r\n  AUTO_DOWNLOAD = 'autoDownload',\r\n\r\n  // Player settings\r\n  SHOW_MEDIA_CONTROLS = 'showMediaControls',\r\n  SHOW_HAMBURGER_MENU = 'showHamburgerMenu',\r\n  HIDE_SEEK_BUTTONS = 'hideSeekButtons',\r\n  ENABLE_2X_GESTURE = 'enable2xGesture',\r\n  ENABLE_SWIPE_GESTURE = 'enableSwipeGesture',\r\n\r\n  // Quality settings\r\n  EXCLUDED_QUALITIES = 'excludedQualities',\r\n\r\n  // Subtitle settings\r\n  SUBTITLE_FONT_SIZE = 'subtitleFontSize',\r\n  SUBTITLE_OPACITY = 'subtitleOpacity',\r\n  SUBTITLE_BOTTOM_PADDING = 'subtitleBottomPadding',\r\n\r\n  LIST_VIEW_TYPE = 'viewType',\r\n\r\n  // Telemetry (privacy)\r\n  TELEMETRY_OPT_IN = 'telemetryOptIn',\r\n}\r\n\r\n/**\r\n * Settings storage manager\r\n */\r\nexport class SettingsStorage {\r\n  // Theme settings\r\n  getPrimaryColor(): string {\r\n    return mainStorage.getString(SettingsKeys.PRIMARY_COLOR) || '#FF6347';\r\n  }\r\n\r\n  setPrimaryColor(color: string): void {\r\n    mainStorage.setString(SettingsKeys.PRIMARY_COLOR, color);\r\n  }\r\n\r\n  isCustomTheme(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.IS_CUSTOM_THEME);\r\n  }\r\n\r\n  setCustomTheme(isCustom: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.IS_CUSTOM_THEME, isCustom);\r\n  }\r\n\r\n  getCustomColor(): string {\r\n    return mainStorage.getString(SettingsKeys.CUSTOM_COLOR) || '#FF6347';\r\n  }\r\n\r\n  setCustomColor(color: string): void {\r\n    mainStorage.setString(SettingsKeys.CUSTOM_COLOR, color);\r\n  }\r\n\r\n  // UI preferences\r\n  showTabBarLabels(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.SHOW_TAB_BAR_LABELS) === null\r\n      ? false\r\n      : mainStorage.getBool(SettingsKeys.SHOW_TAB_BAR_LABELS);\r\n  }\r\n\r\n  setShowTabBarLabels(show: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.SHOW_TAB_BAR_LABELS, show);\r\n  }\r\n\r\n  isHapticFeedbackEnabled(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.HAPTIC_FEEDBACK) === null\r\n      ? true\r\n      : mainStorage.getBool(SettingsKeys.HAPTIC_FEEDBACK);\r\n  }\r\n  setHapticFeedbackEnabled(enabled: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.HAPTIC_FEEDBACK, enabled);\r\n  }\r\n\r\n  isNotificationsEnabled(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.NOTIFICATIONS_ENABLED) === null\r\n      ? true\r\n      : mainStorage.getBool(SettingsKeys.NOTIFICATIONS_ENABLED);\r\n  }\r\n\r\n  setNotificationsEnabled(enabled: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.NOTIFICATIONS_ENABLED, enabled);\r\n  }\r\n\r\n  // Update settings\r\n  isAutoCheckUpdateEnabled(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.AUTO_CHECK_UPDATE) === null\r\n      ? true\r\n      : mainStorage.getBool(SettingsKeys.AUTO_CHECK_UPDATE);\r\n  }\r\n\r\n  setAutoCheckUpdateEnabled(enabled: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.AUTO_CHECK_UPDATE, enabled);\r\n  }\r\n\r\n  isAutoDownloadEnabled(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.AUTO_DOWNLOAD);\r\n  }\r\n\r\n  setAutoDownloadEnabled(enabled: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.AUTO_DOWNLOAD, enabled);\r\n  }\r\n\r\n  // Player settings\r\n  showMediaControls(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.SHOW_MEDIA_CONTROLS) === null\r\n      ? true\r\n      : mainStorage.getBool(SettingsKeys.SHOW_MEDIA_CONTROLS);\r\n  }\r\n\r\n  setShowMediaControls(show: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.SHOW_MEDIA_CONTROLS, show);\r\n  }\r\n\r\n  showHamburgerMenu(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.SHOW_HAMBURGER_MENU) === null\r\n      ? true\r\n      : mainStorage.getBool(SettingsKeys.SHOW_HAMBURGER_MENU);\r\n  }\r\n\r\n  setShowHamburgerMenu(show: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.SHOW_HAMBURGER_MENU, show);\r\n  }\r\n\r\n  hideSeekButtons(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.HIDE_SEEK_BUTTONS);\r\n  }\r\n\r\n  setHideSeekButtons(hide: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.HIDE_SEEK_BUTTONS, hide);\r\n  }\r\n\r\n  isEnable2xGestureEnabled(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.ENABLE_2X_GESTURE);\r\n  }\r\n\r\n  setEnable2xGesture(enabled: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.ENABLE_2X_GESTURE, enabled);\r\n  }\r\n\r\n  isSwipeGestureEnabled(): boolean {\r\n    return mainStorage.getBool(SettingsKeys.ENABLE_SWIPE_GESTURE, true) === null\r\n      ? true\r\n      : mainStorage.getBool(SettingsKeys.ENABLE_SWIPE_GESTURE, true);\r\n  }\r\n\r\n  setSwipeGestureEnabled(enabled: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.ENABLE_SWIPE_GESTURE, enabled);\r\n  }\r\n\r\n  // Quality settings\r\n  getExcludedQualities(): string[] {\r\n    return mainStorage.getArray<string>(SettingsKeys.EXCLUDED_QUALITIES) || [];\r\n  }\r\n\r\n  setExcludedQualities(qualities: string[]): void {\r\n    mainStorage.setArray(SettingsKeys.EXCLUDED_QUALITIES, qualities);\r\n  }\r\n\r\n  // Subtitle settings\r\n  getSubtitleFontSize(): number {\r\n    return mainStorage.getNumber(SettingsKeys.SUBTITLE_FONT_SIZE) || 16;\r\n  }\r\n\r\n  setSubtitleFontSize(size: number): void {\r\n    mainStorage.setNumber(SettingsKeys.SUBTITLE_FONT_SIZE, size);\r\n  }\r\n\r\n  getSubtitleOpacity(): number {\r\n    const opacityStr = mainStorage.getString(SettingsKeys.SUBTITLE_OPACITY);\r\n    return opacityStr ? parseFloat(opacityStr) : 1;\r\n  }\r\n\r\n  setSubtitleOpacity(opacity: number): void {\r\n    mainStorage.setString(SettingsKeys.SUBTITLE_OPACITY, opacity.toString());\r\n  }\r\n\r\n  getSubtitleBottomPadding(): number {\r\n    return mainStorage.getNumber(SettingsKeys.SUBTITLE_BOTTOM_PADDING) || 10;\r\n  }\r\n\r\n  setSubtitleBottomPadding(padding: number): void {\r\n    mainStorage.setNumber(SettingsKeys.SUBTITLE_BOTTOM_PADDING, padding);\r\n  }\r\n\r\n  getListViewType(): number {\r\n    return parseInt(\r\n      mainStorage.getString(SettingsKeys.LIST_VIEW_TYPE) || '1',\r\n      10,\r\n    );\r\n  }\r\n\r\n  setListViewType(type: number): void {\r\n    mainStorage.setString(SettingsKeys.LIST_VIEW_TYPE, type.toString());\r\n  }\r\n\r\n  // Telemetry / Privacy\r\n  isTelemetryOptIn(): boolean {\r\n    const val = mainStorage.getBool(SettingsKeys.TELEMETRY_OPT_IN);\r\n    // Default to true (opted in) unless explicitly disabled\r\n    return val === null ? true : (val as boolean);\r\n  }\r\n\r\n  setTelemetryOptIn(enabled: boolean): void {\r\n    mainStorage.setBool(SettingsKeys.TELEMETRY_OPT_IN, enabled);\r\n  }\r\n\r\n  // Generic get/set methods for settings not covered by specific methods\r\n  getBool(key: string, defaultValue = false): boolean {\r\n    return mainStorage.getBool(key, defaultValue);\r\n  }\r\n\r\n  setBool(key: string, value: boolean): void {\r\n    mainStorage.setBool(key, value);\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const settingsStorage = new SettingsStorage();\r\n","size_bytes":6973},"src/lib/storage/StorageService.ts":{"content":"import {MMKVLoader} from 'react-native-mmkv-storage';\r\n\r\n/**\r\n * Interface for the StorageService class\r\n */\r\nexport interface IStorageService {\r\n  getString(key: string): string | undefined;\r\n  setString(key: string, value: string): void;\r\n  getBool(key: string, defaultValue?: boolean): boolean;\r\n  setBool(key: string, value: boolean): void;\r\n  getNumber(key: string): number | undefined;\r\n  setNumber(key: string, value: number): void;\r\n  getObject<T>(key: string): T | undefined;\r\n  setObject<T>(key: string, value: T): void;\r\n  getArray<T>(key: string): T[] | undefined;\r\n  setArray<T>(key: string, value: T[]): void;\r\n  delete(key: string): void;\r\n  contains(key: string): boolean;\r\n  clearAll(): void;\r\n}\r\n\r\n/**\r\n * Base storage service that wraps MMKV operations\r\n */\r\nexport class StorageService implements IStorageService {\r\n  // Define storage variable with proper typing\r\n  private storage;\r\n\r\n  constructor(instanceId?: string) {\r\n    const loader = new MMKVLoader();\r\n    this.storage = instanceId\r\n      ? loader.withInstanceID(instanceId).initialize()\r\n      : loader.initialize();\r\n  }\r\n\r\n  // String operations\r\n  getString(key: string): string | undefined {\r\n    return this.storage.getString(key);\r\n  }\r\n\r\n  setString(key: string, value: string): void {\r\n    this.storage.setString(key, value);\r\n  }\r\n\r\n  // Boolean operations\r\n  getBool(key: string, defaultValue?: boolean): boolean {\r\n    const value = this.storage.getBool(key);\r\n    return value === undefined ? defaultValue || false : value;\r\n  }\r\n\r\n  setBool(key: string, value: boolean): void {\r\n    this.storage.setBool(key, value);\r\n  }\r\n\r\n  // Number operations\r\n  getNumber(key: string): number | undefined {\r\n    // Use getInt or getFloat equivalent methods which exist in MMKV\r\n    return this.storage.getInt(key);\r\n  }\r\n\r\n  setNumber(key: string, value: number): void {\r\n    // Use setInt for number values\r\n    this.storage.setInt(key, value);\r\n  }\r\n\r\n  // Object operations\r\n  getObject<T>(key: string): T | undefined {\r\n    const json = this.storage.getString(key);\r\n    if (!json) {\r\n      return undefined;\r\n    }\r\n    try {\r\n      return JSON.parse(json) as T;\r\n    } catch (e) {\r\n      console.error(`Failed to parse stored object for key ${key}:`, e);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  setObject<T>(key: string, value: T): void {\r\n    this.storage.setString(key, JSON.stringify(value));\r\n  }\r\n\r\n  // Array operations\r\n  getArray<T>(key: string): T[] | undefined {\r\n    return this.getObject<T[]>(key);\r\n  }\r\n\r\n  setArray<T>(key: string, value: T[]): void {\r\n    this.setObject(key, value);\r\n  }\r\n\r\n  // Delete operations\r\n  delete(key: string): void {\r\n    this.storage.removeItem(key);\r\n  }\r\n\r\n  // Check if key exists\r\n  contains(key: string): boolean {\r\n    // Check if key exists by attempting to get the value\r\n    return (\r\n      this.storage.getString(key) !== undefined ||\r\n      this.storage.getBool(key) !== undefined ||\r\n      this.storage.getInt(key) !== undefined\r\n    );\r\n  }\r\n\r\n  // Clear all storage\r\n  clearAll(): void {\r\n    this.storage.clearStore();\r\n  }\r\n}\r\n\r\n// Create and export default instances\r\nexport const mainStorage: IStorageService = new StorageService();\r\nexport const cacheStorage: IStorageService = new StorageService('cache');\r\n","size_bytes":3264},"src/lib/storage/WatchHistoryStorage.ts":{"content":"import {mainStorage} from './StorageService';\r\n\r\n/**\r\n * Storage keys for watch history\r\n */\r\nexport enum WatchHistoryKeys {\r\n  WATCH_HISTORY = 'watchHistory',\r\n  SERIES_EPISODES = 'seriesEpisodes',\r\n}\r\n\r\n/**\r\n * Interface for watch history item\r\n */\r\nexport interface WatchHistoryItem {\r\n  id: string;\r\n  title: string;\r\n  poster?: string;\r\n  provider?: string;\r\n  link: string;\r\n  timestamp?: number;\r\n  duration?: number;\r\n  progress?: number;\r\n  isSeries?: boolean;\r\n  lastPlayed?: number;\r\n  currentTime?: number;\r\n  playbackRate?: number;\r\n  episodeTitle?: string;\r\n  cachedInfoData?: any; // Add cached info data\r\n}\r\n\r\n/**\r\n * Interface for series episode\r\n */\r\nexport interface SeriesEpisode {\r\n  uri: string;\r\n  size: number;\r\n  thumbnail?: string;\r\n}\r\n\r\n/**\r\n * Watch history storage manager\r\n */\r\nexport class WatchHistoryStorage {\r\n  /**\r\n   * Get all watch history items\r\n   */\r\n  getWatchHistory(): WatchHistoryItem[] {\r\n    return (\r\n      mainStorage.getArray<WatchHistoryItem>(WatchHistoryKeys.WATCH_HISTORY) ||\r\n      []\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Add or update an item in watch history\r\n   */\r\n  addToWatchHistory(item: WatchHistoryItem): void {\r\n    const history = this.getWatchHistory();\r\n\r\n    // Check if the item already exists\r\n    const existingIndex = history.findIndex(i => i.id === item.id);\r\n\r\n    if (existingIndex !== -1) {\r\n      // Update existing item\r\n      history[existingIndex] = {\r\n        ...history[existingIndex],\r\n        ...item,\r\n        timestamp: Date.now(), // Always update timestamp\r\n      };\r\n    } else {\r\n      // Add new item\r\n      history.unshift({\r\n        ...item,\r\n        timestamp: Date.now(),\r\n      });\r\n    }\r\n\r\n    // Limit history to 100 items\r\n    const limitedHistory = history.slice(0, 100);\r\n\r\n    mainStorage.setArray(WatchHistoryKeys.WATCH_HISTORY, limitedHistory);\r\n  }\r\n\r\n  /**\r\n   * Remove an item from watch history\r\n   */\r\n  removeFromWatchHistory(id: string): void {\r\n    const history = this.getWatchHistory();\r\n    const filteredHistory = history.filter(item => item.id !== id);\r\n    mainStorage.setArray(WatchHistoryKeys.WATCH_HISTORY, filteredHistory);\r\n  }\r\n\r\n  /**\r\n   * Clear all watch history\r\n   */\r\n  clearWatchHistory(): void {\r\n    mainStorage.setArray(WatchHistoryKeys.WATCH_HISTORY, []);\r\n  }\r\n\r\n  /**\r\n   * Update progress for a specific item\r\n   */\r\n  updateProgress(id: string, progress: number, duration?: number): void {\r\n    const history = this.getWatchHistory();\r\n    const existingIndex = history.findIndex(i => i.id === id);\r\n\r\n    if (existingIndex !== -1) {\r\n      history[existingIndex] = {\r\n        ...history[existingIndex],\r\n        progress,\r\n        duration,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      mainStorage.setArray(WatchHistoryKeys.WATCH_HISTORY, history);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get series episodes\r\n   */\r\n  getSeriesEpisodes(seriesId: string): Record<string, SeriesEpisode> {\r\n    const allSeries =\r\n      mainStorage.getObject<Record<string, Record<string, SeriesEpisode>>>(\r\n        WatchHistoryKeys.SERIES_EPISODES,\r\n      ) || {};\r\n\r\n    return allSeries[seriesId] || {};\r\n  }\r\n\r\n  /**\r\n   * Add or update series episodes\r\n   */\r\n  addSeriesEpisodes(\r\n    seriesId: string,\r\n    episodes: Record<string, SeriesEpisode>,\r\n  ): void {\r\n    const allSeries =\r\n      mainStorage.getObject<Record<string, Record<string, SeriesEpisode>>>(\r\n        WatchHistoryKeys.SERIES_EPISODES,\r\n      ) || {};\r\n\r\n    allSeries[seriesId] = {\r\n      ...allSeries[seriesId],\r\n      ...episodes,\r\n    };\r\n\r\n    mainStorage.setObject(WatchHistoryKeys.SERIES_EPISODES, allSeries);\r\n  }\r\n\r\n  /**\r\n   * Remove series episodes\r\n   */\r\n  removeSeriesEpisodes(seriesId: string): void {\r\n    const allSeries =\r\n      mainStorage.getObject<Record<string, Record<string, SeriesEpisode>>>(\r\n        WatchHistoryKeys.SERIES_EPISODES,\r\n      ) || {};\r\n\r\n    delete allSeries[seriesId];\r\n\r\n    mainStorage.setObject(WatchHistoryKeys.SERIES_EPISODES, allSeries);\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const watchHistoryStorage = new WatchHistoryStorage();\r\n","size_bytes":4073},"src/lib/storage/WatchListStorage.ts":{"content":"import {mainStorage} from './StorageService';\r\n\r\n/**\r\n * Storage key for watchlist\r\n */\r\nexport enum WatchListKeys {\r\n  WATCH_LIST = 'watchlist',\r\n}\r\n\r\n/**\r\n * Interface for watchlist item\r\n */\r\nexport interface WatchListItem {\r\n  title: string;\r\n  poster: string;\r\n  link: string;\r\n  provider: string;\r\n}\r\n\r\n/**\r\n * Watchlist storage manager\r\n */\r\nexport class WatchListStorage {\r\n  /**\r\n   * Get all watchlist items\r\n   */\r\n  getWatchList(): WatchListItem[] {\r\n    return mainStorage.getArray<WatchListItem>(WatchListKeys.WATCH_LIST) || [];\r\n  }\r\n\r\n  /**\r\n   * Add an item to the watchlist\r\n   */\r\n  addToWatchList(item: WatchListItem): WatchListItem[] {\r\n    const watchList = this.getWatchList();\r\n\r\n    // Filter out any existing item with the same link\r\n    const newWatchList = watchList.filter(i => i.link !== item.link);\r\n\r\n    // Add the new item to the end\r\n    newWatchList.push(item);\r\n\r\n    // Save the updated watchlist\r\n    mainStorage.setArray(WatchListKeys.WATCH_LIST, newWatchList);\r\n\r\n    return newWatchList;\r\n  }\r\n\r\n  /**\r\n   * Remove an item from the watchlist\r\n   */\r\n  removeFromWatchList(link: string): WatchListItem[] {\r\n    const watchList = this.getWatchList();\r\n    const newWatchList = watchList.filter(item => item.link !== link);\r\n\r\n    mainStorage.setArray(WatchListKeys.WATCH_LIST, newWatchList);\r\n\r\n    return newWatchList;\r\n  }\r\n\r\n  /**\r\n   * Clear all items from the watchlist\r\n   */\r\n  clearWatchList(): WatchListItem[] {\r\n    const emptyList: WatchListItem[] = [];\r\n    mainStorage.setArray(WatchListKeys.WATCH_LIST, emptyList);\r\n    return emptyList;\r\n  }\r\n\r\n  /**\r\n   * Check if an item exists in the watchlist\r\n   */\r\n  isInWatchList(link: string): boolean {\r\n    const watchList = this.getWatchList();\r\n    return watchList.some(item => item.link === link);\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const watchListStorage = new WatchListStorage();\r\n","size_bytes":1902},"src/lib/storage/extensionStorage.ts":{"content":"import {mainStorage} from './StorageService';\r\n\r\n/**\r\n * Provider extension metadata\r\n */\r\nexport interface ProviderExtension {\r\n  value: string;\r\n  display_name: string;\r\n  version: string;\r\n  icon: string;\r\n  disabled: boolean;\r\n  type: 'global' | 'english' | 'india' | 'italy' | 'anime' | 'drama';\r\n  installed: boolean;\r\n  installedAt?: number;\r\n  lastUpdated?: number;\r\n}\r\n\r\n/**\r\n * Provider module cache\r\n */\r\nexport interface ProviderModule {\r\n  value: string;\r\n  version: string;\r\n  modules: {\r\n    posts?: string;\r\n    meta?: string;\r\n    stream?: string;\r\n    catalog?: string;\r\n    episodes?: string;\r\n  };\r\n  cachedAt: number;\r\n}\r\n\r\n/**\r\n * Storage keys for extensions\r\n */\r\nexport enum ExtensionKeys {\r\n  INSTALLED_PROVIDERS = 'installedProviders',\r\n  AVAILABLE_PROVIDERS = 'availableProviders',\r\n  PROVIDER_MODULES = 'providerModules',\r\n  MANIFEST_CACHE = 'manifestCache',\r\n  LAST_MANIFEST_FETCH = 'lastManifestFetch',\r\n}\r\n\r\n/**\r\n * Extension storage manager\r\n */\r\nexport class ExtensionStorage {\r\n  /**\r\n   * Get installed providers\r\n   */\r\n  getInstalledProviders(): ProviderExtension[] {\r\n    return (\r\n      mainStorage.getArray<ProviderExtension>(\r\n        ExtensionKeys.INSTALLED_PROVIDERS,\r\n      ) || []\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set installed providers\r\n   */\r\n  setInstalledProviders(providers: ProviderExtension[]): void {\r\n    mainStorage.setArray(ExtensionKeys.INSTALLED_PROVIDERS, providers);\r\n  }\r\n\r\n  /**\r\n   * Get available providers\r\n   */\r\n  getAvailableProviders(): ProviderExtension[] {\r\n    return (\r\n      mainStorage.getArray<ProviderExtension>(\r\n        ExtensionKeys.AVAILABLE_PROVIDERS,\r\n      ) || []\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set available providers\r\n   */\r\n  setAvailableProviders(providers: ProviderExtension[]): void {\r\n    mainStorage.setArray(ExtensionKeys.AVAILABLE_PROVIDERS, providers);\r\n  }\r\n\r\n  /**\r\n   * Install a provider\r\n   */\r\n  installProvider(provider: ProviderExtension): void {\r\n    const installed = this.getInstalledProviders();\r\n    const existing = installed.find(p => p.value === provider.value);\r\n\r\n    if (existing) {\r\n      // Update existing provider\r\n      existing.version = provider.version;\r\n      existing.lastUpdated = Date.now();\r\n    } else {\r\n      // Add new provider\r\n      installed.push({\r\n        ...provider,\r\n        installed: true,\r\n        installedAt: Date.now(),\r\n      });\r\n    }\r\n\r\n    this.setInstalledProviders(installed);\r\n  }\r\n\r\n  /**\r\n   * Uninstall a provider\r\n   */\r\n  uninstallProvider(providerValue: string): void {\r\n    const installed = this.getInstalledProviders();\r\n    const filtered = installed.filter(p => p.value !== providerValue);\r\n    this.setInstalledProviders(filtered);\r\n\r\n    // Also remove cached modules\r\n    this.removeProviderModules(providerValue);\r\n  }\r\n\r\n  /**\r\n   * Check if provider is installed\r\n   */\r\n  isProviderInstalled(providerValue: string): boolean {\r\n    const installed = this.getInstalledProviders();\r\n    return installed.some(p => p.value === providerValue);\r\n  }\r\n\r\n  /**\r\n   * Get provider modules cache\r\n   */\r\n  getProviderModules(providerValue: string): ProviderModule | undefined {\r\n    const allModules =\r\n      mainStorage.getArray<ProviderModule>(ExtensionKeys.PROVIDER_MODULES) ||\r\n      [];\r\n    return allModules.find(m => m.value === providerValue);\r\n  }\r\n\r\n  /**\r\n   * Cache provider modules\r\n   */\r\n  cacheProviderModules(modules: ProviderModule): void {\r\n    const allModules =\r\n      mainStorage.getArray<ProviderModule>(ExtensionKeys.PROVIDER_MODULES) ||\r\n      [];\r\n\r\n    const existingIndex = allModules.findIndex(m => m.value === modules.value);\r\n\r\n    if (existingIndex >= 0) {\r\n      allModules[existingIndex] = modules;\r\n    } else {\r\n      allModules.push(modules);\r\n    }\r\n\r\n    mainStorage.setArray(ExtensionKeys.PROVIDER_MODULES, allModules);\r\n  }\r\n\r\n  /**\r\n   * Remove provider modules from cache\r\n   */\r\n  removeProviderModules(providerValue: string): void {\r\n    const allModules =\r\n      mainStorage.getArray<ProviderModule>(ExtensionKeys.PROVIDER_MODULES) ||\r\n      [];\r\n\r\n    const filtered = allModules.filter(m => m.value !== providerValue);\r\n    mainStorage.setArray(ExtensionKeys.PROVIDER_MODULES, filtered);\r\n  }\r\n\r\n  /**\r\n   * Get manifest cache\r\n   */\r\n  getManifestCache(): ProviderExtension[] {\r\n    return (\r\n      mainStorage.getArray<ProviderExtension>(ExtensionKeys.MANIFEST_CACHE) ||\r\n      []\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set manifest cache\r\n   */\r\n  setManifestCache(manifest: ProviderExtension[]): void {\r\n    mainStorage.setArray(ExtensionKeys.MANIFEST_CACHE, manifest);\r\n    mainStorage.setNumber(ExtensionKeys.LAST_MANIFEST_FETCH, Date.now());\r\n  }\r\n\r\n  /**\r\n   * Get last manifest fetch time\r\n   */\r\n  getLastManifestFetch(): number {\r\n    return mainStorage.getNumber(ExtensionKeys.LAST_MANIFEST_FETCH) || 0;\r\n  }\r\n\r\n  /**\r\n   * Check if manifest cache is expired (24 hours)\r\n   */\r\n  isManifestCacheExpired(): boolean {\r\n    const lastFetch = this.getLastManifestFetch();\r\n    const now = Date.now();\r\n    const twentyFourHours = 24 * 60 * 60 * 1000;\r\n    return now - lastFetch > twentyFourHours;\r\n  }\r\n\r\n  /**\r\n   * Get providers that need updates\r\n   */\r\n  getProvidersNeedingUpdate(): ProviderExtension[] {\r\n    const installed = this.getInstalledProviders();\r\n    const available = this.getAvailableProviders();\r\n\r\n    return installed.filter(installedProvider => {\r\n      const availableProvider = available.find(\r\n        p => p.value === installedProvider.value,\r\n      );\r\n      return (\r\n        availableProvider &&\r\n        availableProvider.version !== installedProvider.version\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear all extension data\r\n   */\r\n  clearAll(): void {\r\n    mainStorage.delete(ExtensionKeys.INSTALLED_PROVIDERS);\r\n    mainStorage.delete(ExtensionKeys.AVAILABLE_PROVIDERS);\r\n    mainStorage.delete(ExtensionKeys.PROVIDER_MODULES);\r\n    mainStorage.delete(ExtensionKeys.MANIFEST_CACHE);\r\n    mainStorage.delete(ExtensionKeys.LAST_MANIFEST_FETCH);\r\n  }\r\n}\r\n\r\n/**\r\n * Global extension storage instance\r\n */\r\nexport const extensionStorage = new ExtensionStorage();\r\n","size_bytes":6094},"src/lib/storage/index.ts":{"content":"// Export StorageService\r\nexport {StorageService, mainStorage, cacheStorage} from './StorageService';\r\n\r\n// Export SettingsStorage\r\nexport {SettingsStorage, settingsStorage} from './SettingsStorage';\r\nexport type {SettingsKeys} from './SettingsStorage';\r\n\r\n// Export WatchHistoryStorage\r\nexport {WatchHistoryStorage, watchHistoryStorage} from './WatchHistoryStorage';\r\nexport type {\r\n  WatchHistoryKeys,\r\n  WatchHistoryItem,\r\n  SeriesEpisode,\r\n} from './WatchHistoryStorage';\r\n\r\n// Export WatchListStorage\r\nexport {WatchListStorage, watchListStorage} from './WatchListStorage';\r\nexport type {WatchListKeys, WatchListItem} from './WatchListStorage';\r\n\r\n// Export CacheStorage\r\nexport {CacheStorage, cacheStorageService} from './CacheStorage';\r\n\r\n// Export ProvidersStorage\r\nexport {ProvidersStorage, providersStorage} from './ProvidersStorage';\r\nexport type {ProvidersKeys} from './ProvidersStorage';\r\n\r\n// Export DownloadsStorage\r\nexport {DownloadsStorage, downloadsStorage} from './DownloadsStorage';\r\nexport type {DownloadsKeys} from './DownloadsStorage';\r\n\r\n// Export ExtensionStorage\r\nexport {ExtensionStorage, extensionStorage} from './extensionStorage';\r\nexport type {\r\n  ExtensionKeys,\r\n  ProviderExtension,\r\n  ProviderModule,\r\n} from './extensionStorage';\r\n","size_bytes":1265},"src/lib/utils/firebaseSafe.ts":{"content":"// Safe, optional accessors for react-native-firebase modules.\r\n// They return null when the native modules aren't available (e.g., google-services.json missing).\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const getAnalytics = (): any | null => {\r\n  try {\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    return require('@react-native-firebase/analytics').default;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const getCrashlytics = (): any | null => {\r\n  try {\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    return require('@react-native-firebase/crashlytics').default;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n","size_bytes":760},"src/lib/utils/helpers.ts":{"content":"export const formatName = (name: string): string => {\r\n  // Replace special characters with an underscore\r\n  return name.replaceAll(/[^a-zA-Z0-9]/g, '_');\r\n};\r\n","size_bytes":160},"src/lib/zustand/contentStore.ts":{"content":"import {create} from 'zustand';\r\nimport {persist, createJSONStorage} from 'zustand/middleware';\r\nimport {MMKVLoader} from 'react-native-mmkv-storage';\r\n// import {ProvidersList, providersList} from '../constants';\r\nimport {extensionStorage, ProviderExtension} from '../storage/extensionStorage';\r\n\r\nconst storage = new MMKVLoader().initialize();\r\n\r\nexport interface Content {\r\n  provider: ProviderExtension;\r\n  setProvider: (type: ProviderExtension) => void;\r\n  // Extension-based provider management\r\n  installedProviders: ProviderExtension[];\r\n  availableProviders: ProviderExtension[];\r\n  setInstalledProviders: (providers: ProviderExtension[]) => void;\r\n  setAvailableProviders: (providers: ProviderExtension[]) => void;\r\n  activeExtensionProvider: ProviderExtension | null;\r\n  setActiveExtensionProvider: (provider: ProviderExtension | null) => void;\r\n}\r\n\r\nconst useContentStore = create<Content>()(\r\n  persist(\r\n    (set, _get) => ({\r\n      provider: {\r\n        value: '',\r\n        display_name: '',\r\n        type: 'global',\r\n        installed: false,\r\n        disabled: false,\r\n        version: '0.0.1',\r\n        icon: '',\r\n        installedAt: 0,\r\n        lastUpdated: 0,\r\n      },\r\n      installedProviders: extensionStorage\r\n        .getInstalledProviders()\r\n        .sort((a, b) => a.display_name.localeCompare(b.display_name)),\r\n      availableProviders: [],\r\n      activeExtensionProvider: null,\r\n\r\n      setProvider: (provider: ProviderExtension) => set({provider}),\r\n\r\n      setInstalledProviders: (providers: ProviderExtension[]) =>\r\n        set({\r\n          installedProviders: providers.sort((a, b) =>\r\n            a.display_name.localeCompare(b.display_name),\r\n          ),\r\n        }),\r\n\r\n      setAvailableProviders: (providers: ProviderExtension[]) =>\r\n        set({availableProviders: providers}),\r\n\r\n      setActiveExtensionProvider: (provider: ProviderExtension | null) =>\r\n        set({activeExtensionProvider: provider}),\r\n    }),\r\n    {\r\n      name: 'content-storage',\r\n      storage: createJSONStorage(() => storage as any), // Only persist certain fields\r\n      partialize: state => ({\r\n        provider: state.provider,\r\n        activeExtensionProvider: state.activeExtensionProvider,\r\n      }),\r\n    },\r\n  ),\r\n);\r\n\r\nexport default useContentStore;\r\n","size_bytes":2281},"src/lib/zustand/downloadsStore.ts":{"content":"","size_bytes":0},"src/lib/zustand/herostore.ts":{"content":"import {create} from 'zustand';\r\nimport {Post} from '../providers/types';\r\n\r\nexport interface Hero {\r\n  hero: Post;\r\n  setHero: (hero: Hero['hero']) => void;\r\n}\r\n\r\nconst useHeroStore = create<Hero>(set => ({\r\n  hero: {title: '', link: '', image: ''},\r\n  setHero: hero => set({hero}),\r\n}));\r\n\r\nexport default useHeroStore;\r\n","size_bytes":323},"src/lib/zustand/themeStore.ts":{"content":"import {create} from 'zustand';\r\nimport {persist, createJSONStorage} from 'zustand/middleware';\r\nimport {MMKVLoader} from 'react-native-mmkv-storage';\r\nimport {settingsStorage} from '../storage';\r\n\r\nconst storage = new MMKVLoader().initialize();\r\n\r\nexport interface Theme {\r\n  primary: string;\r\n  isCustom: boolean;\r\n  setPrimary: (type: Theme['primary']) => void;\r\n  setCustom: (isCustom: boolean) => void;\r\n}\r\n\r\nconst useThemeStore = create<Theme>()(\r\n  persist(\r\n    set => ({\r\n      primary: settingsStorage.getPrimaryColor(),\r\n      isCustom: settingsStorage.isCustomTheme(),\r\n\r\n      setPrimary: (primary: Theme['primary']) => {\r\n        set({primary});\r\n        settingsStorage.setPrimaryColor(primary);\r\n      },\r\n      setCustom: (isCustom: Theme['isCustom']) => {\r\n        set({isCustom});\r\n        settingsStorage.setCustomTheme(isCustom);\r\n      },\r\n    }),\r\n    {\r\n      name: 'content-storage',\r\n      //@ts-expect-error\r\n      storage: createJSONStorage(() => storage),\r\n    },\r\n  ),\r\n);\r\n\r\nexport default useThemeStore;\r\n","size_bytes":1037},"src/lib/zustand/watchHistrory.ts":{"content":"import {create} from 'zustand';\r\nimport {WatchHistoryItem, watchHistoryStorage} from '../storage';\r\n\r\nexport interface History {\r\n  history: WatchHistoryItem[];\r\n  addItem: (item: WatchHistoryItem) => void;\r\n  updatePlaybackInfo: (\r\n    link: string,\r\n    playbackInfo: Partial<WatchHistoryItem>,\r\n  ) => void;\r\n  clearHistory: () => void;\r\n  updateItemWithInfo: (link: string, infoData: any) => void;\r\n  removeItem: (item: WatchHistoryItem) => void;\r\n}\r\n\r\n// Helper function to convert between our storage format and zustand format\r\nconst convertStorageToZustand = (items: any[]): WatchHistoryItem[] => {\r\n  return items.map(item => ({\r\n    ...item,\r\n    lastPlayed: item.timestamp,\r\n    currentTime: item.progress || 0,\r\n  }));\r\n};\r\n\r\nconst useWatchHistoryStore = create<History>(set => ({\r\n  // Initialize from our storage service\r\n  history: convertStorageToZustand(watchHistoryStorage.getWatchHistory()),\r\n\r\n  addItem: item => {\r\n    try {\r\n      // Format item for our storage service\r\n      const storageItem: WatchHistoryItem = {\r\n        id: item.link || item.title,\r\n        title: item.title,\r\n        poster: item.poster,\r\n        provider: item.provider,\r\n        link: item.link,\r\n        timestamp: Date.now(),\r\n        duration: item.duration,\r\n        progress: item.currentTime,\r\n        episodeTitle: item.episodeTitle,\r\n        cachedInfoData: item.cachedInfoData,\r\n      };\r\n\r\n      // Add to storage\r\n      watchHistoryStorage.addToWatchHistory(storageItem);\r\n\r\n      // Update UI state\r\n      set({\r\n        history: convertStorageToZustand(watchHistoryStorage.getWatchHistory()),\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error:', error);\r\n    }\r\n  },\r\n\r\n  updatePlaybackInfo: (link, playbackInfo) => {\r\n    try {\r\n      const history = watchHistoryStorage.getWatchHistory();\r\n      const existingItem = history.find(item => item.link === link);\r\n\r\n      if (existingItem) {\r\n        const updatedItem = {\r\n          ...existingItem,\r\n          progress: playbackInfo.currentTime,\r\n          duration: playbackInfo.duration || existingItem.duration,\r\n          timestamp: Date.now(),\r\n        };\r\n\r\n        watchHistoryStorage.addToWatchHistory(updatedItem);\r\n      }\r\n\r\n      set({\r\n        history: convertStorageToZustand(watchHistoryStorage.getWatchHistory()),\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error updating watch history:', error);\r\n    }\r\n  },\r\n\r\n  removeItem: item => {\r\n    watchHistoryStorage.removeFromWatchHistory(item.link);\r\n    set({\r\n      history: convertStorageToZustand(watchHistoryStorage.getWatchHistory()),\r\n    });\r\n  },\r\n\r\n  clearHistory: () => {\r\n    watchHistoryStorage.clearWatchHistory();\r\n    set({history: []});\r\n  },\r\n\r\n  updateItemWithInfo: (link, infoData) => {\r\n    try {\r\n      const history = watchHistoryStorage.getWatchHistory();\r\n      const existingItem = history.find(item => item.link === link);\r\n\r\n      if (existingItem) {\r\n        const updatedItem = {\r\n          ...existingItem,\r\n          cachedInfoData: infoData,\r\n        };\r\n\r\n        watchHistoryStorage.addToWatchHistory(updatedItem);\r\n      }\r\n\r\n      set({\r\n        history: convertStorageToZustand(watchHistoryStorage.getWatchHistory()),\r\n      });\r\n    } catch (error) {\r\n      console.error('❌ Error caching info data:', error);\r\n    }\r\n  },\r\n}));\r\n\r\nexport default useWatchHistoryStore;\r\n","size_bytes":3368},"src/lib/zustand/watchListStore.ts":{"content":"import {create} from 'zustand';\r\nimport {watchListStorage, WatchListItem} from '../storage';\r\n\r\n// Reuse the WatchListItem interface from our storage\r\nexport type WatchList = WatchListItem;\r\n\r\ninterface WatchListStore {\r\n  watchList: WatchList[];\r\n  removeItem: (link: string) => void;\r\n  addItem: (item: WatchList) => void;\r\n  // clearWatchList: () => void;\r\n}\r\n\r\nconst useWatchListStore = create<WatchListStore>()(set => ({\r\n  // Initialize from storage\r\n  watchList: watchListStorage.getWatchList(),\r\n\r\n  // Remove item using storage service\r\n  removeItem: link => {\r\n    const newWatchList = watchListStorage.removeFromWatchList(link);\r\n    set({watchList: newWatchList});\r\n  },\r\n\r\n  // Add item using storage service\r\n  addItem: item => {\r\n    const newWatchList = watchListStorage.addToWatchList(item);\r\n    set({watchList: newWatchList});\r\n  },\r\n\r\n  // Clear watchlist - commented out but updated to use storage service\r\n  // clearWatchList: () => {\r\n  //   const emptyList = watchListStorage.clearWatchList();\r\n  //   set({watchList: emptyList});\r\n  // },\r\n}));\r\n\r\nexport default useWatchListStore;\r\n","size_bytes":1108},"src/screens/home/Home.tsx":{"content":"import {\r\n  SafeAreaView,\r\n  ScrollView,\r\n  RefreshControl,\r\n  View,\r\n  Text,\r\n} from 'react-native';\r\nimport Slider from '../../components/Slider';\r\nimport React, {useCallback, useMemo, useRef, useState} from 'react';\r\nimport HeroOptimized from '../../components/Hero';\r\nimport {mainStorage} from '../../lib/storage';\r\nimport useContentStore from '../../lib/zustand/contentStore';\r\nimport useHeroStore from '../../lib/zustand/herostore';\r\nimport {\r\n  useHomePageData,\r\n  getRandomHeroPost,\r\n} from '../../lib/hooks/useHomePageData';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport ProviderDrawer from '../../components/ProviderDrawer';\r\nimport {NativeStackScreenProps} from '@react-navigation/native-stack';\r\nimport {HomeStackParamList} from '../../App';\r\nimport DrawerLayout from 'react-native-gesture-handler/DrawerLayout';\r\nimport {GestureHandlerRootView} from 'react-native-gesture-handler';\r\nimport ContinueWatching from '../../components/ContinueWatching';\r\nimport {providerManager} from '../../lib/services/ProviderManager';\r\nimport Tutorial from '../../components/Touturial';\r\nimport {QueryErrorBoundary} from '../../components/ErrorBoundary';\r\nimport {StatusBar} from 'expo-status-bar';\r\n\r\ntype Props = NativeStackScreenProps<HomeStackParamList, 'Home'>;\r\n\r\nconst Home = ({}: Props) => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const [backgroundColor, setBackgroundColor] = useState('transparent');\r\n  const drawer = useRef<DrawerLayout>(null);\r\n  const [isDrawerOpen] = useState(false);\r\n\r\n  // Memoize static values\r\n  const disableDrawer = useMemo(\r\n    () => mainStorage.getBool('disableDrawer') || false,\r\n    [],\r\n  );\r\n\r\n  const {provider, installedProviders} = useContentStore(state => state);\r\n  const {setHero} = useHeroStore(state => state);\r\n\r\n  // React Query for home page data with better error handling\r\n  const {\r\n    data: homeData = [],\r\n    isLoading,\r\n    error,\r\n    refetch,\r\n    isRefetching,\r\n    // isStale,\r\n  } = useHomePageData({\r\n    provider,\r\n    enabled: !!(installedProviders?.length && provider?.value),\r\n  });\r\n\r\n  // Memoized scroll handler\r\n  const handleScroll = useCallback((event: any) => {\r\n    const newBackgroundColor =\r\n      event.nativeEvent.contentOffset.y > 0 ? 'black' : 'transparent';\r\n    setBackgroundColor(newBackgroundColor);\r\n  }, []);\r\n\r\n  // Stable hero post calculation\r\n  const heroPost = useMemo(() => {\r\n    if (!homeData || homeData.length === 0) {\r\n      return null;\r\n    }\r\n    return getRandomHeroPost(homeData);\r\n  }, [homeData]);\r\n\r\n  // Update hero only when hero post actually changes\r\n  React.useEffect(() => {\r\n    if (heroPost) {\r\n      setHero(heroPost);\r\n    } else {\r\n      setHero({link: '', image: '', title: ''});\r\n    }\r\n  }, [heroPost, setHero]);\r\n\r\n  // Optimized refresh handler\r\n  const handleRefresh = useCallback(async () => {\r\n    try {\r\n      await refetch();\r\n    } catch (refreshError) {\r\n      console.error('Error refreshing home data:', refreshError);\r\n    }\r\n  }, [refetch]);\r\n\r\n  // Memoized loading skeleton\r\n  const loadingSliders = useMemo(() => {\r\n    if (!provider?.value) {\r\n      return [];\r\n    }\r\n\r\n    return providerManager\r\n      .getCatalog({providerValue: provider.value})\r\n      .map((item, index) => (\r\n        <Slider\r\n          isLoading={true}\r\n          key={`loading-${item.filter}-${index}`}\r\n          title={item.title}\r\n          posts={[]}\r\n          filter={item.filter}\r\n        />\r\n      ));\r\n  }, [provider?.value]);\r\n\r\n  // Memoized content sliders\r\n  const contentSliders = useMemo(() => {\r\n    return homeData.map((item, index) => (\r\n      <Slider\r\n        isLoading={false}\r\n        key={`content-${item.filter}-${index}`}\r\n        title={item.title}\r\n        posts={item.Posts}\r\n        filter={item.filter}\r\n      />\r\n    ));\r\n  }, [homeData]);\r\n\r\n  // Memoized error message\r\n  const errorComponent = useMemo(() => {\r\n    if (!error && (isLoading || homeData.length > 0)) {\r\n      return null;\r\n    }\r\n\r\n    return (\r\n      <View className=\"p-4 m-4 bg-red-500/20 rounded-lg min-h-64 flex-1 justify-center items-center\">\r\n        <Text className=\"text-red-400 text-center font-medium\">\r\n          {error?.message || 'Failed to load content'}\r\n        </Text>\r\n        <Text className=\"text-gray-400 text-center text-sm mt-1\">\r\n          Pull to refresh and try again\r\n        </Text>\r\n      </View>\r\n    );\r\n  }, [error, isLoading, homeData.length]);\r\n\r\n  // Early return for no providers\r\n  if (\r\n    !installedProviders ||\r\n    installedProviders.length === 0 ||\r\n    !provider?.value\r\n  ) {\r\n    return <Tutorial />;\r\n  }\r\n\r\n  return (\r\n    <QueryErrorBoundary>\r\n      <GestureHandlerRootView style={{flex: 1}}>\r\n        <SafeAreaView className=\"bg-black flex-1\">\r\n          <DrawerLayout\r\n            drawerPosition=\"left\"\r\n            drawerWidth={200}\r\n            drawerLockMode={disableDrawer ? 'locked-closed' : 'unlocked'}\r\n            drawerType=\"front\"\r\n            edgeWidth={70}\r\n            useNativeAnimations={false}\r\n            ref={drawer}\r\n            drawerBackgroundColor=\"transparent\"\r\n            renderNavigationView={() =>\r\n              !disableDrawer && <ProviderDrawer drawerRef={drawer} />\r\n            }>\r\n            <StatusBar\r\n              style=\"auto\"\r\n              animated={true}\r\n              translucent={true}\r\n              backgroundColor={backgroundColor}\r\n            />\r\n\r\n            <ScrollView\r\n              onScroll={handleScroll}\r\n              scrollEventThrottle={16} // Optimize scroll performance\r\n              showsVerticalScrollIndicator={false}\r\n              className=\"bg-black\"\r\n              refreshControl={\r\n                <RefreshControl\r\n                  colors={[primary]}\r\n                  tintColor={primary}\r\n                  progressBackgroundColor=\"black\"\r\n                  refreshing={isRefetching}\r\n                  onRefresh={handleRefresh}\r\n                />\r\n              }>\r\n              <HeroOptimized drawerRef={drawer} isDrawerOpen={isDrawerOpen} />\r\n\r\n              <ContinueWatching />\r\n\r\n              <View className=\"-mt-6 relative z-20\">\r\n                {isLoading ? loadingSliders : contentSliders}\r\n                {errorComponent}\r\n              </View>\r\n\r\n              <View className=\"h-16\" />\r\n            </ScrollView>\r\n          </DrawerLayout>\r\n        </SafeAreaView>\r\n      </GestureHandlerRootView>\r\n    </QueryErrorBoundary>\r\n  );\r\n};\r\n\r\nexport default React.memo(Home);\r\n","size_bytes":6464},"src/screens/home/Info.tsx":{"content":"import {\r\n  Image,\r\n  Text,\r\n  View,\r\n  StatusBar,\r\n  RefreshControl,\r\n  FlatList,\r\n  Linking,\r\n  TouchableOpacity,\r\n  Modal,\r\n  Pressable,\r\n} from 'react-native';\r\nimport React, {useCallback, useMemo, useRef, useState} from 'react';\r\nimport {\r\n  NativeStackNavigationProp,\r\n  NativeStackScreenProps,\r\n} from '@react-navigation/native-stack';\r\nimport {HomeStackParamList, TabStackParamList} from '../../App';\r\nimport LinearGradient from 'react-native-linear-gradient';\r\nimport SeasonList from '../../components/SeasonList';\r\nimport {Skeleton} from 'moti/skeleton';\r\nimport Ionicons from '@expo/vector-icons/Ionicons';\r\nimport {settingsStorage, watchListStorage} from '../../lib/storage';\r\nimport ReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport useContentStore from '../../lib/zustand/contentStore';\r\nimport {MaterialCommunityIcons} from '@expo/vector-icons';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport useWatchListStore from '../../lib/zustand/watchListStore';\r\nimport {useContentDetails} from '../../lib/hooks/useContentInfo';\r\nimport {QueryErrorBoundary} from '../../components/ErrorBoundary';\r\n// import {BlurView} from 'expo-blur';\r\n\r\ntype Props = NativeStackScreenProps<HomeStackParamList, 'Info'>;\r\nexport default function Info({route, navigation}: Props): React.JSX.Element {\r\n  const searchNavigation =\r\n    useNavigation<NativeStackNavigationProp<TabStackParamList>>();\r\n  const {primary} = useThemeStore(state => state);\r\n  const {addItem, removeItem} = useWatchListStore(state => state);\r\n  const {provider} = useContentStore(state => state);\r\n\r\n  // React Query for optimized data fetching\r\n  const {\r\n    info,\r\n    meta,\r\n    isLoading: infoLoading,\r\n    error,\r\n    refetch,\r\n  } = useContentDetails(\r\n    route.params.link,\r\n    route.params.provider || provider.value,\r\n  );\r\n\r\n  // UI state\r\n  const [threeDotsMenuOpen, setThreeDotsMenuOpen] = useState(false);\r\n  const [readMore, setReadMore] = useState(false);\r\n  const [menuPosition, setMenuPosition] = useState({top: -1000, right: 0});\r\n  const [backgroundColor, setBackgroundColor] = useState('transparent');\r\n  const [logoError, setLogoError] = useState(false);\r\n\r\n  const threeDotsRef = useRef<any>();\r\n\r\n  // Memoized values\r\n  const [inLibrary, setInLibrary] = useState(() =>\r\n    watchListStorage.isInWatchList(route.params.link),\r\n  );\r\n\r\n  // Memoized handlers\r\n  const openThreeDotsMenu = useCallback(() => {\r\n    if (threeDotsRef.current) {\r\n      threeDotsRef.current.measure(\r\n        (\r\n          x: number,\r\n          y: number,\r\n          width: number,\r\n          height: number,\r\n          pageX: number,\r\n          pageY: number,\r\n        ) => {\r\n          setMenuPosition({top: pageY - 35, right: 35});\r\n          setThreeDotsMenuOpen(true);\r\n        },\r\n      );\r\n    }\r\n  }, []);\r\n\r\n  const handleScroll = useCallback((event: any) => {\r\n    setBackgroundColor(\r\n      event.nativeEvent.contentOffset.y > 150 ? 'black' : 'transparent',\r\n    );\r\n  }, []);\r\n  // Optimized library management\r\n  const addLibrary = useCallback(() => {\r\n    ReactNativeHapticFeedback.trigger('effectClick', {\r\n      enableVibrateFallback: true,\r\n      ignoreAndroidSystemSettings: false,\r\n    });\r\n    addItem({\r\n      title: meta?.name || info?.title,\r\n      poster: meta?.poster || route.params.poster || info?.image,\r\n      link: route.params.link,\r\n      provider: route.params.provider || provider.value,\r\n    });\r\n    setInLibrary(true);\r\n  }, [meta, info, route.params, provider.value, addItem]);\r\n\r\n  const removeLibrary = useCallback(() => {\r\n    if (settingsStorage.isHapticFeedbackEnabled()) {\r\n      ReactNativeHapticFeedback.trigger('effectClick', {\r\n        enableVibrateFallback: true,\r\n        ignoreAndroidSystemSettings: false,\r\n      });\r\n    }\r\n    removeItem(route.params.link);\r\n    setInLibrary(false);\r\n  }, [route.params.link, removeItem]);\r\n\r\n  // Memoized computed values\r\n  const synopsis = useMemo(() => {\r\n    return meta?.description || info?.synopsis || 'No synopsis available';\r\n  }, [meta?.description, info?.synopsis]);\r\n\r\n  const displayTitle = useMemo(() => {\r\n    return meta?.name || info?.title;\r\n  }, [meta?.name, info?.title]);\r\n\r\n  const posterImage = useMemo(() => {\r\n    return (\r\n      meta?.poster ||\r\n      route.params.poster ||\r\n      info?.image ||\r\n      'https://placehold.jp/24/363636/ffffff/500x500.png?text=Vega'\r\n    );\r\n  }, [meta?.poster, route.params.poster, info?.image]);\r\n\r\n  const backgroundImage = useMemo(() => {\r\n    return (\r\n      meta?.background ||\r\n      info?.image ||\r\n      'https://placehold.jp/24/363636/ffffff/500x500.png?text=Vega'\r\n    );\r\n  }, [meta?.background, info?.image]);\r\n  const filteredLinkList = useMemo(() => {\r\n    if (!info?.linkList) {\r\n      return [];\r\n    }\r\n\r\n    const excludedQualities = settingsStorage.getExcludedQualities();\r\n    const filtered = info.linkList.filter(\r\n      (item: any) =>\r\n        !item.quality || !excludedQualities.includes(item.quality as string),\r\n    );\r\n\r\n    return filtered.length > 0 ? filtered : info.linkList;\r\n  }, [info?.linkList]);\r\n\r\n  // Optimized refresh handler\r\n  const handleRefresh = useCallback(async () => {\r\n    try {\r\n      await refetch();\r\n    } catch (refreshError) {\r\n      console.error('Error refreshing content:', refreshError);\r\n      // Could show a toast or alert here if needed\r\n    }\r\n  }, [refetch]);\r\n\r\n  // Error handling - show error UI instead of throwing\r\n  if (error) {\r\n    return (\r\n      <View className=\"h-full w-full bg-black justify-center items-center p-4\">\r\n        <StatusBar\r\n          showHideTransition={'slide'}\r\n          animated={true}\r\n          translucent={true}\r\n          backgroundColor=\"black\"\r\n        />\r\n        <Text className=\"text-red-400 text-lg font-bold mb-4 text-center\">\r\n          Failed to load content\r\n        </Text>\r\n        <Text className=\"text-gray-400 text-sm mb-6 text-center\">\r\n          {error.message ||\r\n            'An unexpected error occurred while loading the content'}\r\n        </Text>\r\n        <TouchableOpacity\r\n          onPress={handleRefresh}\r\n          className=\"bg-red-600 px-6 py-3 rounded-lg mb-4\">\r\n          <Text className=\"text-white font-semibold\">Try Again</Text>\r\n        </TouchableOpacity>\r\n        <TouchableOpacity\r\n          onPress={() => navigation.goBack()}\r\n          className=\"bg-gray-600 px-6 py-3 rounded-lg\">\r\n          <Text className=\"text-white font-semibold\">Go Back</Text>\r\n        </TouchableOpacity>\r\n      </View>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <QueryErrorBoundary>\r\n      <View className=\"h-full w-full\">\r\n        <StatusBar\r\n          showHideTransition={'slide'}\r\n          animated={true}\r\n          translucent={true}\r\n          backgroundColor={backgroundColor}\r\n        />\r\n        <View>\r\n          <View className=\"absolute w-full h-[256px]\">\r\n            <Skeleton\r\n              show={infoLoading}\r\n              colorMode=\"dark\"\r\n              height={'100%'}\r\n              width={'100%'}>\r\n              <Image\r\n                source={{uri: backgroundImage}}\r\n                className=\" h-[256] w-full\"\r\n                onError={e => {\r\n                  console.warn('Background image failed to load:', e);\r\n                }}\r\n              />\r\n            </Skeleton>\r\n          </View>\r\n\r\n          {\r\n            // manifest[route.params.provider || provider.value].blurImage && (\r\n            //   <BlurView\r\n            //     intensity={4}\r\n            //     blurReductionFactor={1}\r\n            //     experimentalBlurMethod=\"dimezisBlurView\"\r\n            //     tint=\"default\"\r\n            //     style={{\r\n            //       position: 'absolute',\r\n            //       top: 0,\r\n            //       left: 0,\r\n            //       right: 0,\r\n            //       bottom: 0,\r\n            //       height: 256,\r\n            //       width: '100%',\r\n            //     }}\r\n            //   />\r\n            // )\r\n          }\r\n          <FlatList\r\n            data={[]}\r\n            keyExtractor={(_, i) => i.toString()}\r\n            renderItem={() => <View />}\r\n            ListHeaderComponent={\r\n              <>\r\n                <View className=\"relative w-full h-[256px]\">\r\n                  <LinearGradient\r\n                    colors={['transparent', 'black']}\r\n                    className=\"absolute h-full w-full\"\r\n                  />\r\n                  <View className=\"absolute bottom-0 right-0 w-screen flex-row justify-between items-baseline px-2\">\r\n                    {(meta?.logo && !logoError) || infoLoading ? (\r\n                      <Image\r\n                        onError={() => setLogoError(true)}\r\n                        source={{uri: meta?.logo}}\r\n                        style={{width: 200, height: 100, resizeMode: 'contain'}}\r\n                      />\r\n                    ) : (\r\n                      <Text className=\"text-white text-2xl mt-3 capitalize font-semibold w-3/4 truncate\">\r\n                        {displayTitle}\r\n                      </Text>\r\n                    )}\r\n                    {/* rating */}\r\n                    {(meta?.imdbRating || info?.rating) && (\r\n                      <Text className=\"text-white text-2xl font-semibold\">\r\n                        {meta?.imdbRating || info?.rating}\r\n                        <Text className=\"text-white text-lg\">/10</Text>\r\n                      </Text>\r\n                    )}\r\n                  </View>\r\n                </View>\r\n                <View className=\"p-4 bg-black\">\r\n                  <View className=\"flex-row gap-x-3 gap-y-1 flex-wrap items-center mb-4\">\r\n                    {/* badges */}\r\n                    {meta?.year && (\r\n                      <Text className=\"text-white text-lg bg-tertiary px-2 rounded-md\">\r\n                        {meta?.year}\r\n                      </Text>\r\n                    )}\r\n                    {meta?.runtime && (\r\n                      <Text className=\"text-white text-lg bg-tertiary px-2 rounded-md\">\r\n                        {meta?.runtime}\r\n                      </Text>\r\n                    )}\r\n                    {meta?.genres?.slice(0, 2).map((genre: string) => (\r\n                      <Text\r\n                        key={genre}\r\n                        className=\"text-white text-lg bg-tertiary px-2 rounded-md\">\r\n                        {genre}\r\n                      </Text>\r\n                    ))}\r\n                    {info?.tags?.slice(0, 3)?.map((tag: string) => (\r\n                      <Text\r\n                        key={tag}\r\n                        className=\"text-white text-lg bg-tertiary px-2 rounded-md\">\r\n                        {tag}\r\n                      </Text>\r\n                    ))}\r\n                  </View>\r\n                  {/* Awards */}\r\n                  {meta?.awards && (\r\n                    <View className=\"mb-2 w-full flex-row items-baseline gap-2\">\r\n                      <Text className=\"text-white text- font-semibold\">\r\n                        Awards:\r\n                      </Text>\r\n                      <Text className=\"text-white text-xs px-1 bg-tertiary rounded-sm\">\r\n                        {meta?.awards?.length > 50\r\n                          ? meta?.awards.slice(0, 50) + '...'\r\n                          : meta?.awards}\r\n                      </Text>\r\n                    </View>\r\n                  )}\r\n                  {/* cast  */}\r\n                  {(meta?.cast?.length! > 0 || info?.cast?.length! > 0) && (\r\n                    <View className=\"mb-2 w-full flex-row items-start gap-2\">\r\n                      <Text className=\"text-white text-lg font-semibold pt-[0.9px]\">\r\n                        Cast\r\n                      </Text>\r\n                      <View className=\"flex-row gap-1 flex-wrap\">\r\n                        {meta?.cast\r\n                          ?.slice(0, 3)\r\n                          .map((actor: string, index: number) => (\r\n                            <Text\r\n                              key={actor}\r\n                              className={`text-xs bg-tertiary p-1 px-2 rounded-md ${\r\n                                index % 3 === 0\r\n                                  ? 'text-red-500'\r\n                                  : index % 3 === 1\r\n                                  ? 'text-blue-500'\r\n                                  : 'text-green-500'\r\n                              }`}>\r\n                              {actor}\r\n                            </Text>\r\n                          ))}\r\n                        {info?.cast\r\n                          ?.slice(0, 3)\r\n                          .map((actor: string, index: number) => (\r\n                            <Text\r\n                              key={actor}\r\n                              className={`text-xs bg-tertiary p-1 px-2 rounded-md ${\r\n                                index % 3 === 0\r\n                                  ? 'text-red-500'\r\n                                  : index % 3 === 1\r\n                                  ? 'text-blue-500'\r\n                                  : 'text-green-500'\r\n                              }`}>\r\n                              {actor}\r\n                            </Text>\r\n                          ))}\r\n                      </View>\r\n                    </View>\r\n                  )}\r\n                  {/* synopsis */}\r\n                  <View className=\"mb-2 w-full flex-row items-center justify-between\">\r\n                    <Skeleton show={infoLoading} colorMode=\"dark\" width={180}>\r\n                      <View className=\"flex-row items-center gap-2\">\r\n                        <Text className=\"text-white text-lg font-semibold\">\r\n                          Synopsis\r\n                        </Text>\r\n                        <Text className=\"text-white text-xs bg-tertiary p-1 px-2 rounded-md\">\r\n                          {route.params.provider || provider.value}\r\n                        </Text>\r\n                      </View>\r\n                    </Skeleton>\r\n                    <View className=\"flex-row items-center gap-4 mb-1\">\r\n                      {meta?.trailers && meta?.trailers.length > 0 && (\r\n                        <MaterialCommunityIcons\r\n                          name=\"movie-open\"\r\n                          size={25}\r\n                          color=\"rgb(156 163 175)\"\r\n                          onPress={() =>\r\n                            Linking.openURL(\r\n                              'https://www.youtube.com/watch?v=' +\r\n                                meta?.trailers?.[0]?.source,\r\n                            )\r\n                          }\r\n                        />\r\n                      )}\r\n                      {inLibrary ? (\r\n                        <Ionicons\r\n                          name=\"bookmark\"\r\n                          size={30}\r\n                          color={primary}\r\n                          onPress={() => removeLibrary()}\r\n                        />\r\n                      ) : (\r\n                        <Ionicons\r\n                          name=\"bookmark-outline\"\r\n                          size={30}\r\n                          color={primary}\r\n                          onPress={() => addLibrary()}\r\n                        />\r\n                      )}\r\n                      <TouchableOpacity\r\n                        onPress={() => openThreeDotsMenu()}\r\n                        ref={threeDotsRef}>\r\n                        <MaterialCommunityIcons\r\n                          name=\"dots-vertical\"\r\n                          size={25}\r\n                          color=\"rgb(156 163 175)\"\r\n                        />\r\n                      </TouchableOpacity>\r\n                      {\r\n                        <Modal\r\n                          animationType=\"none\"\r\n                          transparent={true}\r\n                          visible={threeDotsMenuOpen}\r\n                          onRequestClose={() => {\r\n                            setThreeDotsMenuOpen(false);\r\n                          }}>\r\n                          <Pressable\r\n                            onPress={() => setThreeDotsMenuOpen(false)}\r\n                            className=\"flex-1 bg-opacity-50\">\r\n                            <View\r\n                              className=\"rounded-md p-2 w-48 bg-quaternary absolute right-10 top-[330px]\"\r\n                              style={{\r\n                                top: menuPosition.top,\r\n                                right: menuPosition.right,\r\n                              }}>\r\n                              {/* open in web  */}\r\n                              <TouchableOpacity\r\n                                className=\"flex-row items-center gap-2\"\r\n                                onPress={async () => {\r\n                                  setThreeDotsMenuOpen(false);\r\n                                  navigation.navigate('Webview', {\r\n                                    link: route.params.link,\r\n                                  });\r\n                                }}>\r\n                                <MaterialCommunityIcons\r\n                                  name=\"web\"\r\n                                  size={21}\r\n                                  color=\"rgb(156 163 175)\"\r\n                                />\r\n                                <Text className=\"text-white text-base\">\r\n                                  Open in Web\r\n                                </Text>\r\n                              </TouchableOpacity>\r\n                              {/* search */}\r\n                              <TouchableOpacity\r\n                                className=\"flex-row items-center gap-2 mt-1\"\r\n                                onPress={async () => {\r\n                                  setThreeDotsMenuOpen(false);\r\n                                  //@ts-ignore\r\n                                  searchNavigation.navigate('SearchStack', {\r\n                                    screen: 'SearchResults',\r\n                                    params: {\r\n                                      filter: displayTitle,\r\n                                    },\r\n                                  });\r\n                                }}>\r\n                                <Ionicons\r\n                                  name=\"search\"\r\n                                  size={21}\r\n                                  color=\"rgb(156 163 175)\"\r\n                                />\r\n                                <Text className=\"text-white text-base\">\r\n                                  Search Title\r\n                                </Text>\r\n                              </TouchableOpacity>\r\n                            </View>\r\n                          </Pressable>\r\n                        </Modal>\r\n                      }\r\n                    </View>\r\n                  </View>\r\n                  <Skeleton show={infoLoading} colorMode=\"dark\" height={85}>\r\n                    <Text className=\"text-gray-200 text-sm px-2 py-1 bg-tertiary rounded-md\">\r\n                      {synopsis.length > 180 && !readMore\r\n                        ? synopsis.slice(0, 180) + '... '\r\n                        : synopsis}\r\n                      {synopsis.length > 180 && !readMore && (\r\n                        <Text\r\n                          onPress={() => setReadMore(!readMore)}\r\n                          className=\"text-white font-extrabold text-xs px-2 bg-tertiary rounded-md\">\r\n                          read more\r\n                        </Text>\r\n                      )}\r\n                    </Text>\r\n                  </Skeleton>\r\n                  {/* cast */}\r\n                </View>\r\n                <View className=\"p-4 bg-black\">\r\n                  {infoLoading ? (\r\n                    <View className=\"gap-y-3 items-start mb-4 p-3\">\r\n                      <Skeleton\r\n                        show={true}\r\n                        colorMode=\"dark\"\r\n                        height={30}\r\n                        width={80}\r\n                      />\r\n                      {[...Array(1)].map((_, i) => (\r\n                        <View\r\n                          className=\"bg-tertiary p-1 rounded-md gap-3 mt-3\"\r\n                          key={i}>\r\n                          <Skeleton\r\n                            show={true}\r\n                            colorMode=\"dark\"\r\n                            height={20}\r\n                            width={'100%'}\r\n                          />\r\n                        </View>\r\n                      ))}\r\n                    </View>\r\n                  ) : (\r\n                    <SeasonList\r\n                      refreshing={false}\r\n                      providerValue={route.params.provider || provider.value}\r\n                      LinkList={filteredLinkList}\r\n                      poster={{\r\n                        logo: meta?.logo,\r\n                        poster: posterImage,\r\n                        background: backgroundImage,\r\n                      }}\r\n                      type={info?.type || 'series'}\r\n                      metaTitle={displayTitle}\r\n                      routeParams={route.params}\r\n                    />\r\n                  )}\r\n                </View>\r\n              </>\r\n            }\r\n            ListFooterComponent={<View className=\"h-16\" />}\r\n            showsHorizontalScrollIndicator={false}\r\n            showsVerticalScrollIndicator={false}\r\n            onScroll={handleScroll}\r\n            scrollEventThrottle={16} // Optimize scroll performance\r\n            refreshControl={\r\n              <RefreshControl\r\n                colors={[primary]}\r\n                tintColor={primary}\r\n                progressBackgroundColor={'black'}\r\n                refreshing={false}\r\n                onRefresh={handleRefresh}\r\n              />\r\n            }\r\n          />\r\n        </View>\r\n      </View>\r\n    </QueryErrorBoundary>\r\n  );\r\n}\r\n","size_bytes":21804},"src/screens/home/Player.tsx":{"content":"import React, {useEffect, useState, useRef, useCallback, useMemo} from 'react';\r\nimport {\r\n  ScrollView,\r\n  Text,\r\n  ToastAndroid,\r\n  TouchableOpacity,\r\n  View,\r\n  StatusBar,\r\n  Platform,\r\n  TouchableNativeFeedback,\r\n} from 'react-native';\r\nimport Animated, {\r\n  useSharedValue,\r\n  useAnimatedStyle,\r\n  withTiming,\r\n  withRepeat,\r\n  withSequence,\r\n  withDelay,\r\n} from 'react-native-reanimated';\r\nimport {NativeStackScreenProps} from '@react-navigation/native-stack';\r\nimport {RootStackParamList} from '../../App';\r\nimport {cacheStorage, settingsStorage} from '../../lib/storage';\r\nimport {OrientationLocker, LANDSCAPE} from 'react-native-orientation-locker';\r\nimport VideoPlayer from '@8man/react-native-media-console';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport MaterialIcons from '@expo/vector-icons/MaterialIcons';\r\nimport {\r\n  VideoRef,\r\n  SelectedVideoTrack,\r\n  SelectedVideoTrackType,\r\n  ResizeMode,\r\n  SelectedTrack,\r\n  SelectedTrackType,\r\n} from 'react-native-video';\r\nimport useContentStore from '../../lib/zustand/contentStore';\r\n// import {CastButton, useRemoteMediaClient} from 'react-native-google-cast';\r\nimport {SafeAreaView} from 'react-native-safe-area-context';\r\n// import GoogleCast from 'react-native-google-cast';\r\nimport * as DocumentPicker from 'expo-document-picker';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport {FlashList} from '@shopify/flash-list';\r\nimport SearchSubtitles from '../../components/SearchSubtitles';\r\nimport FullScreenChz from 'react-native-fullscreen-chz';\r\nimport useWatchHistoryStore from '../../lib/zustand/watchHistrory';\r\nimport {useStream, useVideoSettings} from '../../lib/hooks/useStream';\r\nimport {\r\n  usePlayerProgress,\r\n  usePlayerSettings,\r\n} from '../../lib/hooks/usePlayerSettings';\r\n\r\ntype Props = NativeStackScreenProps<RootStackParamList, 'Player'>;\r\n\r\nconst Player = ({route}: Props): React.JSX.Element => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const {provider} = useContentStore();\r\n  const navigation = useNavigation();\r\n  const {addItem, updatePlaybackInfo, updateItemWithInfo} =\r\n    useWatchHistoryStore();\r\n\r\n  // Player ref\r\n  const playerRef: React.RefObject<VideoRef> = useRef(null);\r\n  const hasSetInitialTracksRef = useRef(false);\r\n\r\n  // Shared values for animations\r\n  const loadingOpacity = useSharedValue(0);\r\n  const loadingScale = useSharedValue(0.8);\r\n  const loadingRotation = useSharedValue(0);\r\n  const lockButtonTranslateY = useSharedValue(-150);\r\n  const lockButtonOpacity = useSharedValue(0);\r\n  const textVisibility = useSharedValue(0);\r\n  const speedIconOpacity = useSharedValue(1);\r\n  const controlsTranslateY = useSharedValue(150);\r\n  const controlsOpacity = useSharedValue(0);\r\n  const toastOpacity = useSharedValue(0);\r\n  const settingsTranslateY = useSharedValue(10000);\r\n  const settingsOpacity = useSharedValue(0);\r\n\r\n  // Animated styles\r\n  const loadingContainerStyle = useAnimatedStyle(() => ({\r\n    opacity: loadingOpacity.value,\r\n    transform: [{scale: loadingScale.value}],\r\n  }));\r\n\r\n  const loadingIconStyle = useAnimatedStyle(() => ({\r\n    transform: [{rotate: `${loadingRotation.value}deg`}],\r\n  }));\r\n\r\n  const lockButtonStyle = useAnimatedStyle(() => ({\r\n    transform: [{translateY: lockButtonTranslateY.value}],\r\n    opacity: lockButtonOpacity.value,\r\n  }));\r\n\r\n  const controlsStyle = useAnimatedStyle(() => ({\r\n    transform: [{translateY: controlsTranslateY.value}],\r\n    opacity: controlsOpacity.value,\r\n  }));\r\n\r\n  const toastStyle = useAnimatedStyle(() => ({\r\n    opacity: toastOpacity.value,\r\n  }));\r\n\r\n  const settingsStyle = useAnimatedStyle(() => ({\r\n    transform: [{translateY: settingsTranslateY.value}],\r\n\r\n    opacity: settingsOpacity.value,\r\n  }));\r\n\r\n  // Active episode state\r\n  const [activeEpisode, setActiveEpisode] = useState(\r\n    route.params?.episodeList?.[route.params.linkIndex],\r\n  );\r\n\r\n  // Search subtitles state\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  // Custom hooks for stream management\r\n  const {\r\n    streamData,\r\n    selectedStream,\r\n    setSelectedStream,\r\n    externalSubs,\r\n    setExternalSubs,\r\n    isLoading: streamLoading,\r\n    error: streamError,\r\n    switchToNextStream,\r\n  } = useStream({\r\n    activeEpisode,\r\n    routeParams: route.params,\r\n    provider: provider.value,\r\n  });\r\n\r\n  // Custom hooks for video settings\r\n  const {\r\n    audioTracks,\r\n    textTracks,\r\n    videoTracks,\r\n    selectedAudioTrackIndex,\r\n    selectedTextTrackIndex,\r\n    selectedQualityIndex,\r\n    setSelectedAudioTrackIndex,\r\n    setSelectedTextTrackIndex,\r\n    setSelectedQualityIndex,\r\n    setTextTracks,\r\n    processAudioTracks,\r\n    processVideoTracks,\r\n  } = useVideoSettings();\r\n\r\n  // Custom hooks for player settings\r\n  const {\r\n    showControls,\r\n    setShowControls,\r\n    showSettings,\r\n    setShowSettings,\r\n    activeTab,\r\n    setActiveTab,\r\n    resizeMode,\r\n    playbackRate,\r\n    setPlaybackRate,\r\n    isPlayerLocked,\r\n    showUnlockButton,\r\n    toastMessage,\r\n    showToast,\r\n    isTextVisible,\r\n    handleResizeMode,\r\n    togglePlayerLock,\r\n    handleLockedScreenTap,\r\n    unlockButtonTimerRef,\r\n  } = usePlayerSettings();\r\n\r\n  // Custom hook for progress handling\r\n  const {videoPositionRef, handleProgress} = usePlayerProgress({\r\n    activeEpisode,\r\n    routeParams: route.params,\r\n    playbackRate,\r\n    updatePlaybackInfo,\r\n  });\r\n\r\n  // Memoized values\r\n  const playbacks = useMemo(\r\n    () => [0.25, 0.5, 1.0, 1.25, 1.35, 1.5, 1.75, 2],\r\n    [],\r\n  );\r\n  const hideSeekButtons = useMemo(\r\n    () => settingsStorage.hideSeekButtons() || false,\r\n    [],\r\n  );\r\n\r\n  const enableSwipeGesture = useMemo(\r\n    () => settingsStorage.isSwipeGestureEnabled(),\r\n    [],\r\n  );\r\n  const showMediaControls = useMemo(\r\n    () => settingsStorage.showMediaControls(),\r\n    [],\r\n  );\r\n\r\n  // Memoized watched duration\r\n  const watchedDuration = useMemo(() => {\r\n    const cached = cacheStorage.getString(activeEpisode?.link);\r\n    return cached ? JSON.parse(cached).position : 0;\r\n  }, [activeEpisode?.link]);\r\n\r\n  // Memoized selected tracks\r\n  const [selectedAudioTrack, setSelectedAudioTrack] = useState<SelectedTrack>({\r\n    type: SelectedTrackType.INDEX,\r\n    value: 0,\r\n  });\r\n\r\n  const [selectedTextTrack, setSelectedTextTrack] = useState<SelectedTrack>({\r\n    type: SelectedTrackType.DISABLED,\r\n  });\r\n\r\n  const [selectedVideoTrack, setSelectedVideoTrack] =\r\n    useState<SelectedVideoTrack>({\r\n      type: SelectedVideoTrackType.AUTO,\r\n    });\r\n\r\n  // Remote media client for casting\r\n  // const remoteMediaClient = Platform.isTV ? null : useRemoteMediaClient();\r\n\r\n  // Memoized format quality function\r\n  const formatQuality = useCallback((quality: string) => {\r\n    if (quality === 'auto') {\r\n      return quality;\r\n    }\r\n    const num = Number(quality);\r\n    if (num > 1080) {\r\n      return '4K';\r\n    }\r\n    if (num > 720) {\r\n      return '1080p';\r\n    }\r\n    if (num > 480) {\r\n      return '720p';\r\n    }\r\n    if (num > 360) {\r\n      return '480p';\r\n    }\r\n    if (num > 240) {\r\n      return '360p';\r\n    }\r\n    if (num > 144) {\r\n      return '240p';\r\n    }\r\n    return quality;\r\n  }, []);\r\n\r\n  // Memoized next episode handler\r\n  const handleNextEpisode = useCallback(() => {\r\n    const currentIndex = route.params?.episodeList?.indexOf(activeEpisode);\r\n    if (\r\n      currentIndex !== undefined &&\r\n      currentIndex < route.params?.episodeList?.length - 1\r\n    ) {\r\n      setActiveEpisode(route.params?.episodeList[currentIndex + 1]);\r\n      hasSetInitialTracksRef.current = false;\r\n    } else {\r\n      ToastAndroid.show('No more episodes', ToastAndroid.SHORT);\r\n    }\r\n  }, [activeEpisode, route.params?.episodeList]);\r\n\r\n  // Memoized error handler\r\n  const handleVideoError = useCallback(\r\n    (e: any) => {\r\n      console.log('PlayerError', e);\r\n      if (!switchToNextStream()) {\r\n        ToastAndroid.show(\r\n          'Video could not be played, try again later',\r\n          ToastAndroid.SHORT,\r\n        );\r\n        navigation.goBack();\r\n      }\r\n      setShowControls(true);\r\n    },\r\n    [switchToNextStream, navigation, setShowControls],\r\n  );\r\n\r\n  // Memoized cast effect\r\n  // useEffect(() => {\r\n  //   if (remoteMediaClient && !Platform.isTV && selectedStream?.link) {\r\n  //     remoteMediaClient.loadMedia({\r\n  //       startTime: watchedDuration,\r\n  //       playbackRate: playbackRate,\r\n  //       autoplay: true,\r\n  //       mediaInfo: {\r\n  //         contentUrl: selectedStream.link,\r\n  //         contentType: 'video/x-matroska',\r\n  //         metadata: {\r\n  //           title: route.params?.primaryTitle,\r\n  //           subtitle: route.params?.secondaryTitle,\r\n  //           type: 'movie',\r\n  //           images: [\r\n  //             {\r\n  //               url: route.params?.poster?.poster || '',\r\n  //             },\r\n  //           ],\r\n  //         },\r\n  //       },\r\n  //     });\r\n  //     playerRef?.current?.pause();\r\n  //     GoogleCast.showExpandedControls();\r\n  //   }\r\n  //   return () => {\r\n  //     if (remoteMediaClient) {\r\n  //       remoteMediaClient?.stop();\r\n  //     }\r\n  //   };\r\n  // }, [\r\n  //   remoteMediaClient,\r\n  //   selectedStream,\r\n  //   watchedDuration,\r\n  //   playbackRate,\r\n  //   route.params,\r\n  // ]);\r\n\r\n  // Exit fullscreen on back\r\n  useEffect(() => {\r\n    FullScreenChz.enable();\r\n    const unsubscribe = navigation.addListener('beforeRemove', () => {\r\n      FullScreenChz.disable();\r\n    });\r\n    return unsubscribe;\r\n  }, [navigation]);\r\n\r\n  // Reset track selections when stream changes\r\n  useEffect(() => {\r\n    setSelectedAudioTrackIndex(0);\r\n    setSelectedTextTrackIndex(1000);\r\n    setSelectedQualityIndex(1000);\r\n  }, [\r\n    selectedStream,\r\n    setSelectedAudioTrackIndex,\r\n    setSelectedTextTrackIndex,\r\n    setSelectedQualityIndex,\r\n  ]);\r\n\r\n  // Initialize search query\r\n  useEffect(() => {\r\n    setSearchQuery(route.params?.primaryTitle || '');\r\n  }, [route.params?.primaryTitle]);\r\n\r\n  // Add to watch history\r\n  useEffect(() => {\r\n    if (route.params?.primaryTitle) {\r\n      addItem({\r\n        id: route.params.infoUrl || activeEpisode.link,\r\n        title: route.params.primaryTitle,\r\n        poster:\r\n          route.params.poster?.poster || route.params.poster?.background || '',\r\n        link: route.params.infoUrl || '',\r\n        provider: route.params?.providerValue || provider.value,\r\n        lastPlayed: Date.now(),\r\n        duration: 0,\r\n        currentTime: 0,\r\n        playbackRate: 1,\r\n        episodeTitle: route.params?.secondaryTitle,\r\n      });\r\n\r\n      updateItemWithInfo(\r\n        route.params.episodeList[route.params.linkIndex].link,\r\n        {\r\n          ...route.params,\r\n          cachedAt: Date.now(),\r\n        },\r\n      );\r\n    }\r\n  }, [\r\n    route.params?.primaryTitle,\r\n    activeEpisode.link,\r\n    addItem,\r\n    updateItemWithInfo,\r\n    route.params,\r\n    provider.value,\r\n  ]);\r\n\r\n  // Set last selected audio and subtitle tracks\r\n  useEffect(() => {\r\n    if (hasSetInitialTracksRef.current) {\r\n      return;\r\n    }\r\n\r\n    const lastAudioTrack = cacheStorage.getString('lastAudioTrack') || 'auto';\r\n    const lastTextTrack = cacheStorage.getString('lastTextTrack') || 'auto';\r\n\r\n    const audioTrackIndex = audioTracks.findIndex(\r\n      track => track.language === lastAudioTrack,\r\n    );\r\n    const textTrackIndex = textTracks.findIndex(\r\n      track => track.language === lastTextTrack,\r\n    );\r\n\r\n    if (audioTrackIndex !== -1) {\r\n      setSelectedAudioTrack({\r\n        type: SelectedTrackType.INDEX,\r\n        value: audioTrackIndex,\r\n      });\r\n      setSelectedAudioTrackIndex(audioTrackIndex);\r\n    }\r\n\r\n    if (textTrackIndex !== -1) {\r\n      setSelectedTextTrack({\r\n        type: SelectedTrackType.INDEX,\r\n        value: textTrackIndex,\r\n      });\r\n      setSelectedTextTrackIndex(textTrackIndex);\r\n    }\r\n\r\n    if (audioTracks.length > 0 && textTracks.length > 0) {\r\n      hasSetInitialTracksRef.current = true;\r\n    }\r\n  }, [\r\n    textTracks,\r\n    audioTracks,\r\n    setSelectedAudioTrackIndex,\r\n    setSelectedTextTrackIndex,\r\n  ]);\r\n\r\n  // Cleanup timer on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (unlockButtonTimerRef.current) {\r\n        clearTimeout(unlockButtonTimerRef.current);\r\n      }\r\n    };\r\n  }, [unlockButtonTimerRef]);\r\n\r\n  // Animation effects\r\n  useEffect(() => {\r\n    // Loading animations\r\n    if (streamLoading) {\r\n      loadingOpacity.value = withTiming(1, {duration: 800});\r\n      loadingScale.value = withTiming(1, {duration: 800});\r\n      loadingRotation.value = withRepeat(\r\n        withSequence(\r\n          withDelay(500, withTiming(180, {duration: 900})),\r\n          withTiming(180, {duration: 600}),\r\n          withTiming(360, {duration: 900}),\r\n          withTiming(360, {duration: 600}),\r\n        ),\r\n        -1,\r\n      );\r\n    }\r\n  }, [streamLoading]);\r\n\r\n  useEffect(() => {\r\n    // Lock button animations\r\n    const shouldShow =\r\n      (isPlayerLocked && showUnlockButton) || (!isPlayerLocked && showControls);\r\n    lockButtonTranslateY.value = withTiming(shouldShow ? 0 : -150, {\r\n      duration: 250,\r\n    });\r\n    lockButtonOpacity.value = withTiming(shouldShow ? 1 : 0, {\r\n      duration: 250,\r\n    });\r\n  }, [isPlayerLocked, showUnlockButton, showControls]);\r\n\r\n  useEffect(() => {\r\n    // 2x speed text visibility\r\n    textVisibility.value = withTiming(isTextVisible ? 1 : 0, {duration: 250});\r\n\r\n    // Speed icon blinking animation\r\n    if (isTextVisible) {\r\n      speedIconOpacity.value = withRepeat(\r\n        withSequence(\r\n          withTiming(1, {duration: 250}),\r\n          withTiming(0, {duration: 150}),\r\n          withTiming(1, {duration: 150}),\r\n        ),\r\n        -1,\r\n      );\r\n    } else {\r\n      speedIconOpacity.value = withTiming(1, {duration: 150});\r\n    }\r\n  }, [isTextVisible]);\r\n\r\n  useEffect(() => {\r\n    // Controls visibility\r\n    controlsTranslateY.value = withTiming(showControls ? 0 : 150, {\r\n      duration: 250,\r\n    });\r\n    controlsOpacity.value = withTiming(showControls ? 1 : 0, {\r\n      duration: 250,\r\n    });\r\n  }, [showControls]);\r\n\r\n  useEffect(() => {\r\n    // Toast visibility\r\n    toastOpacity.value = withTiming(showToast ? 1 : 0, {duration: 250});\r\n  }, [showToast]);\r\n\r\n  useEffect(() => {\r\n    // Settings modal visibility\r\n    settingsTranslateY.value = withTiming(showSettings ? 0 : 5000, {\r\n      duration: 250,\r\n    });\r\n    settingsOpacity.value = withTiming(showSettings ? 1 : 0, {\r\n      duration: 250,\r\n    });\r\n  }, [showSettings]);\r\n\r\n  // Memoized video player props\r\n  const videoPlayerProps = useMemo(\r\n    () => ({\r\n      disableGesture: isPlayerLocked || !enableSwipeGesture,\r\n      doubleTapTime: 200,\r\n      disableSeekButtons: isPlayerLocked || hideSeekButtons,\r\n      showOnStart: !isPlayerLocked,\r\n      source: {\r\n        textTracks: externalSubs,\r\n        uri: selectedStream?.link || '',\r\n        bufferConfig: {backBufferDurationMs: 30000},\r\n        shouldCache: true,\r\n        ...(selectedStream?.type === 'm3u8' && {type: 'm3u8'}),\r\n        headers: selectedStream?.headers,\r\n        metadata: {\r\n          title: route.params?.primaryTitle,\r\n          subtitle: activeEpisode?.title,\r\n          artist: activeEpisode?.title,\r\n          description: activeEpisode?.title,\r\n          imageUri: route.params?.poster?.poster,\r\n        },\r\n      },\r\n      onProgress: handleProgress,\r\n      onLoad: () => {\r\n        playerRef?.current?.seek(watchedDuration);\r\n        playerRef?.current?.resume();\r\n        setPlaybackRate(1.0);\r\n      },\r\n      videoRef: playerRef,\r\n      rate: playbackRate,\r\n      poster: route.params?.poster?.logo || '',\r\n      subtitleStyle: {\r\n        fontSize: settingsStorage.getSubtitleFontSize() || 16,\r\n        opacity: settingsStorage.getSubtitleOpacity() || 1,\r\n        paddingBottom: settingsStorage.getSubtitleBottomPadding() || 10,\r\n        subtitlesFollowVideo: false,\r\n      },\r\n      title: {\r\n        primary:\r\n          route.params?.primaryTitle && route.params?.primaryTitle?.length > 70\r\n            ? route.params?.primaryTitle.slice(0, 70) + '...'\r\n            : route.params?.primaryTitle || '',\r\n        secondary: activeEpisode?.title,\r\n      },\r\n      navigator: navigation,\r\n      seekColor: primary,\r\n      showDuration: true,\r\n      toggleResizeModeOnFullscreen: false,\r\n      fullscreenOrientation: 'landscape' as const,\r\n      fullscreenAutorotate: true,\r\n      onShowControls: () => setShowControls(true),\r\n      onHideControls: () => setShowControls(false),\r\n      rewindTime: 10,\r\n      isFullscreen: true,\r\n      disableFullscreen: true,\r\n      disableVolume: true,\r\n      showHours: true,\r\n      progressUpdateInterval: 1000,\r\n      showNotificationControls: showMediaControls,\r\n      onError: handleVideoError,\r\n      resizeMode,\r\n      selectedAudioTrack,\r\n      onAudioTracks: (e: any) => processAudioTracks(e.audioTracks),\r\n      selectedTextTrack,\r\n      onTextTracks: (e: any) => setTextTracks(e.textTracks),\r\n      onVideoTracks: (e: any) => processVideoTracks(e.videoTracks),\r\n      selectedVideoTrack,\r\n      style: {flex: 1, zIndex: 100},\r\n      controlAnimationTiming: 357,\r\n      controlTimeoutDelay: 10000,\r\n      hideAllControlls: isPlayerLocked,\r\n    }),\r\n    [\r\n      isPlayerLocked,\r\n      enableSwipeGesture,\r\n      hideSeekButtons,\r\n      externalSubs,\r\n      selectedStream,\r\n      route.params,\r\n      activeEpisode,\r\n      handleProgress,\r\n      watchedDuration,\r\n      playbackRate,\r\n      setPlaybackRate,\r\n      primary,\r\n      navigation,\r\n      setShowControls,\r\n      showMediaControls,\r\n      handleVideoError,\r\n      resizeMode,\r\n      selectedAudioTrack,\r\n      selectedTextTrack,\r\n      selectedVideoTrack,\r\n      processAudioTracks,\r\n      processVideoTracks,\r\n    ],\r\n  );\r\n\r\n  // Show loading state\r\n  if (streamLoading) {\r\n    return (\r\n      <SafeAreaView\r\n        edges={{right: 'off', top: 'off', left: 'off', bottom: 'off'}}\r\n        className=\"bg-black flex-1 justify-center items-center\">\r\n        <StatusBar translucent={true} hidden={true} />\r\n        <OrientationLocker orientation={LANDSCAPE} />\r\n        {/* create ripple effect */}\r\n        <TouchableNativeFeedback\r\n          background={TouchableNativeFeedback.Ripple(\r\n            'rgba(255,255,255,0.15)',\r\n            false, // ripple shows at tap location\r\n          )}>\r\n          <View className=\"w-full h-full justify-center items-center\">\r\n            <Animated.View\r\n              style={[loadingContainerStyle]}\r\n              className=\"justify-center items-center\">\r\n              <Animated.View style={[loadingIconStyle]} className=\"mb-2\">\r\n                <MaterialIcons name=\"hourglass-empty\" size={60} color=\"white\" />\r\n              </Animated.View>\r\n              <Text className=\"text-white text-lg mt-4\">Loading stream...</Text>\r\n            </Animated.View>\r\n          </View>\r\n        </TouchableNativeFeedback>\r\n      </SafeAreaView>\r\n    );\r\n  }\r\n\r\n  // Show error state\r\n  if (streamError) {\r\n    return (\r\n      <SafeAreaView className=\"bg-black flex-1 justify-center items-center\">\r\n        <StatusBar translucent={true} hidden={true} />\r\n        <OrientationLocker orientation={LANDSCAPE} />\r\n        <Text className=\"text-red-500 text-lg text-center mb-4\">\r\n          Failed to load stream. Please try again.\r\n        </Text>\r\n        <TouchableOpacity\r\n          className=\"bg-red-600 px-4 py-2 rounded-md\"\r\n          onPress={() => navigation.goBack()}>\r\n          <Text className=\"text-white\">Go Back</Text>\r\n        </TouchableOpacity>\r\n      </SafeAreaView>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <SafeAreaView\r\n      edges={{\r\n        right: 'off',\r\n        top: 'off',\r\n        left: 'off',\r\n        bottom: 'off',\r\n      }}\r\n      className=\"bg-black flex-1 relative\">\r\n      <StatusBar translucent={true} hidden={true} />\r\n      <OrientationLocker orientation={LANDSCAPE} />\r\n\r\n      {/* Video Player */}\r\n      <VideoPlayer {...videoPlayerProps} />\r\n\r\n      {/* Full-screen overlay to detect taps when locked */}\r\n      {isPlayerLocked && (\r\n        <TouchableOpacity\r\n          activeOpacity={1}\r\n          onPress={handleLockedScreenTap}\r\n          className=\"absolute top-0 left-0 right-0 bottom-0 z-40 bg-transparent\"\r\n        />\r\n      )}\r\n\r\n      {/* Lock/Unlock button */}\r\n      {!streamLoading && !Platform.isTV && (\r\n        <Animated.View\r\n          style={[lockButtonStyle]}\r\n          className=\"absolute top-5 right-5 flex-row items-center gap-2 z-50\">\r\n          <TouchableOpacity\r\n            onPress={togglePlayerLock}\r\n            className=\"opacity-70 p-2 rounded-full\">\r\n            <MaterialIcons\r\n              name={isPlayerLocked ? 'lock' : 'lock-open'}\r\n              color={'hsl(0, 0%, 70%)'}\r\n              size={24}\r\n            />\r\n          </TouchableOpacity>\r\n          {/* {!isPlayerLocked && (\r\n            <CastButton\r\n              style={{width: 40, height: 40, opacity: 0.5, tintColor: 'white'}}\r\n            />\r\n          )} */}\r\n        </Animated.View>\r\n      )}\r\n\r\n      {/* Bottom controls */}\r\n      {!isPlayerLocked && (\r\n        <Animated.View\r\n          style={[controlsStyle]}\r\n          className=\"absolute bottom-3 right-6 flex flex-row justify-center w-full gap-x-16\">\r\n          {/* Audio controls */}\r\n          <TouchableOpacity\r\n            onPress={() => {\r\n              setActiveTab('audio');\r\n              setShowSettings(!showSettings);\r\n            }}\r\n            className=\"flex flex-row gap-x-1 items-center\">\r\n            <MaterialIcons\r\n              style={{opacity: 0.7}}\r\n              name={'multitrack-audio'}\r\n              size={26}\r\n              color=\"white\"\r\n            />\r\n            <Text className=\"capitalize text-xs text-white opacity-70\">\r\n              {audioTracks[selectedAudioTrackIndex]?.language || 'auto'}\r\n            </Text>\r\n          </TouchableOpacity>\r\n\r\n          {/* Subtitle controls */}\r\n          <TouchableOpacity\r\n            onPress={() => {\r\n              setActiveTab('subtitle');\r\n              setShowSettings(!showSettings);\r\n            }}\r\n            className=\"flex flex-row gap-x-1 items-center\">\r\n            <MaterialIcons\r\n              style={{opacity: 0.6}}\r\n              name={'subtitles'}\r\n              size={24}\r\n              color=\"white\"\r\n            />\r\n            <Text className=\"text-xs capitalize text-white opacity-70\">\r\n              {selectedTextTrackIndex === 1000\r\n                ? 'none'\r\n                : textTracks[selectedTextTrackIndex]?.language}\r\n            </Text>\r\n          </TouchableOpacity>\r\n\r\n          {/* Speed controls */}\r\n          <TouchableOpacity\r\n            className=\"flex-row gap-1 items-center opacity-60\"\r\n            onPress={() => {\r\n              setActiveTab('speed');\r\n              setShowSettings(!showSettings);\r\n            }}>\r\n            <MaterialIcons name=\"speed\" size={26} color=\"white\" />\r\n            <Text className=\"text-white text-sm\">\r\n              {playbackRate === 1 ? '1.0' : playbackRate}\r\n            </Text>\r\n          </TouchableOpacity>\r\n\r\n          {/* PIP */}\r\n          {!Platform.isTV && (\r\n            <TouchableOpacity\r\n              className=\"flex-row gap-1 items-center opacity-60\"\r\n              onPress={() => {\r\n                playerRef?.current?.enterPictureInPicture();\r\n              }}>\r\n              <MaterialIcons\r\n                name=\"picture-in-picture\"\r\n                size={24}\r\n                color=\"white\"\r\n              />\r\n              <Text className=\"text-white text-xs\">PIP</Text>\r\n            </TouchableOpacity>\r\n          )}\r\n\r\n          {/* Server & Quality */}\r\n          <TouchableOpacity\r\n            className=\"flex-row gap-1 items-center opacity-60\"\r\n            onPress={() => {\r\n              setActiveTab('server');\r\n              setShowSettings(!showSettings);\r\n            }}>\r\n            <MaterialIcons name=\"video-settings\" size={25} color=\"white\" />\r\n            <Text className=\"text-xs text-white capitalize\">\r\n              {videoTracks?.length === 1\r\n                ? formatQuality(videoTracks[0]?.height?.toString() || 'auto')\r\n                : formatQuality(\r\n                    videoTracks?.[selectedQualityIndex]?.height?.toString() ||\r\n                      'auto',\r\n                  )}\r\n            </Text>\r\n          </TouchableOpacity>\r\n\r\n          {/* Resize button */}\r\n          <TouchableOpacity\r\n            className=\"flex-row gap-1 items-center opacity-60\"\r\n            onPress={handleResizeMode}>\r\n            <MaterialIcons name=\"fullscreen\" size={28} color=\"white\" />\r\n            <Text className=\"text-white text-sm min-w-[38px]\">\r\n              {resizeMode === ResizeMode.NONE\r\n                ? 'Fit'\r\n                : resizeMode === ResizeMode.COVER\r\n                ? 'Cover'\r\n                : resizeMode === ResizeMode.STRETCH\r\n                ? 'Stretch'\r\n                : 'Contain'}\r\n            </Text>\r\n          </TouchableOpacity>\r\n\r\n          {/* Next episode button */}\r\n          {route.params?.episodeList?.indexOf(activeEpisode) <\r\n            route.params?.episodeList?.length - 1 &&\r\n            videoPositionRef.current.position /\r\n              videoPositionRef.current.duration >\r\n              0.8 && (\r\n              <TouchableOpacity\r\n                className=\"flex-row items-center opacity-60\"\r\n                onPress={handleNextEpisode}>\r\n                <Text className=\"text-white text-base\">Next</Text>\r\n                <MaterialIcons name=\"skip-next\" size={28} color=\"white\" />\r\n              </TouchableOpacity>\r\n            )}\r\n        </Animated.View>\r\n      )}\r\n\r\n      {/* Toast message */}\r\n      <Animated.View\r\n        style={[toastStyle]}\r\n        pointerEvents=\"none\"\r\n        className=\"absolute w-full top-12 justify-center items-center px-2\">\r\n        <Text className=\"text-white bg-black/50 p-2 rounded-full text-base\">\r\n          {toastMessage}\r\n        </Text>\r\n      </Animated.View>\r\n\r\n      {/* Settings Modal */}\r\n      {!streamLoading && !isPlayerLocked && showSettings && (\r\n        <Animated.View\r\n          style={[settingsStyle]}\r\n          className=\"absolute opacity-0 top-0 left-0 w-full h-full bg-black/20 justify-end items-center\"\r\n          onTouchEnd={() => setShowSettings(false)}>\r\n          <View\r\n            className=\"bg-black p-3 w-[600px] h-72 rounded-t-lg flex-row justify-start items-center\"\r\n            onTouchEnd={e => e.stopPropagation()}>\r\n            {/* Audio Tab */}\r\n            {activeTab === 'audio' && (\r\n              <ScrollView className=\"w-full h-full p-1 px-4\">\r\n                <Text className=\"text-lg font-bold text-center text-white\">\r\n                  Audio\r\n                </Text>\r\n                {audioTracks.length === 0 && (\r\n                  <View className=\"flex justify-center items-center\">\r\n                    <Text className=\"text-white text-xs\">\r\n                      Loading audio tracks...\r\n                    </Text>\r\n                  </View>\r\n                )}\r\n                {audioTracks.map((track, i) => (\r\n                  <TouchableOpacity\r\n                    className=\"flex-row gap-3 items-center rounded-md my-1 overflow-hidden ml-2\"\r\n                    key={i}\r\n                    onPress={() => {\r\n                      setSelectedAudioTrack({\r\n                        type: SelectedTrackType.LANGUAGE,\r\n                        value: track.language,\r\n                      });\r\n                      cacheStorage.setString(\r\n                        'lastAudioTrack',\r\n                        track.language || '',\r\n                      );\r\n                      setSelectedAudioTrackIndex(i);\r\n                      setShowSettings(false);\r\n                    }}>\r\n                    <Text\r\n                      className={'text-lg font-semibold'}\r\n                      style={{\r\n                        color:\r\n                          selectedAudioTrackIndex === i ? primary : 'white',\r\n                      }}>\r\n                      {track.language}\r\n                    </Text>\r\n                    <Text\r\n                      className={'text-base italic'}\r\n                      style={{\r\n                        color:\r\n                          selectedAudioTrackIndex === i ? primary : 'white',\r\n                      }}>\r\n                      {track.type}\r\n                    </Text>\r\n                    <Text\r\n                      className={'text-sm italic'}\r\n                      style={{\r\n                        color:\r\n                          selectedAudioTrackIndex === i ? primary : 'white',\r\n                      }}>\r\n                      {track.title}\r\n                    </Text>\r\n                    {selectedAudioTrackIndex === i && (\r\n                      <MaterialIcons name=\"check\" size={20} color=\"white\" />\r\n                    )}\r\n                  </TouchableOpacity>\r\n                ))}\r\n              </ScrollView>\r\n            )}\r\n\r\n            {/* Subtitle Tab */}\r\n            {activeTab === 'subtitle' && (\r\n              <FlashList\r\n                estimatedItemSize={70}\r\n                data={textTracks}\r\n                ListHeaderComponent={\r\n                  <View>\r\n                    <Text className=\"text-lg font-bold text-center text-white\">\r\n                      Subtitle\r\n                    </Text>\r\n                    <TouchableOpacity\r\n                      className=\"flex-row gap-3 items-center rounded-md my-1 overflow-hidden ml-3\"\r\n                      onPress={() => {\r\n                        setSelectedTextTrack({\r\n                          type: SelectedTrackType.DISABLED,\r\n                        });\r\n                        setSelectedTextTrackIndex(1000);\r\n                        cacheStorage.setString('lastTextTrack', '');\r\n                        setShowSettings(false);\r\n                      }}>\r\n                      <Text\r\n                        className=\"text-base font-semibold\"\r\n                        style={{\r\n                          color:\r\n                            selectedTextTrackIndex === 1000 ? primary : 'white',\r\n                        }}>\r\n                        Disabled\r\n                      </Text>\r\n                    </TouchableOpacity>\r\n                  </View>\r\n                }\r\n                ListFooterComponent={\r\n                  <>\r\n                    <TouchableOpacity\r\n                      className=\"flex-row gap-3 items-center rounded-md my-1 overflow-hidden ml-2\"\r\n                      onPress={async () => {\r\n                        try {\r\n                          const res = await DocumentPicker.getDocumentAsync({\r\n                            type: [\r\n                              'text/vtt',\r\n                              'application/x-subrip',\r\n                              'text/srt',\r\n                              'application/ttml+xml',\r\n                            ],\r\n                            multiple: false,\r\n                          });\r\n\r\n                          if (!res.canceled && res.assets?.[0]) {\r\n                            const asset = res.assets[0];\r\n                            const track = {\r\n                              type: asset.mimeType as any,\r\n                              title:\r\n                                asset.name && asset.name.length > 20\r\n                                  ? asset.name.slice(0, 20) + '...'\r\n                                  : asset.name || 'undefined',\r\n                              language: 'und',\r\n                              uri: asset.uri,\r\n                            };\r\n                            setExternalSubs((prev: any) => [track, ...prev]);\r\n                          }\r\n                        } catch (err) {\r\n                          console.log(err);\r\n                        }\r\n                      }}>\r\n                      <MaterialIcons name=\"add\" size={20} color=\"white\" />\r\n                      <Text className=\"text-base font-semibold text-white\">\r\n                        Add external file\r\n                      </Text>\r\n                    </TouchableOpacity>\r\n                    <SearchSubtitles\r\n                      searchQuery={searchQuery}\r\n                      setSearchQuery={setSearchQuery}\r\n                      setExternalSubs={setExternalSubs}\r\n                    />\r\n                  </>\r\n                }\r\n                renderItem={({item: track}) => (\r\n                  <TouchableOpacity\r\n                    className=\"flex-row gap-3 items-center rounded-md my-1 overflow-hidden ml-2\"\r\n                    onPress={() => {\r\n                      setSelectedTextTrack({\r\n                        type: SelectedTrackType.INDEX,\r\n                        value: track.index,\r\n                      });\r\n                      setSelectedTextTrackIndex(track.index);\r\n                      cacheStorage.setString(\r\n                        'lastTextTrack',\r\n                        track.language || '',\r\n                      );\r\n                      setShowSettings(false);\r\n                    }}>\r\n                    <Text\r\n                      className={'text-base font-semibold'}\r\n                      style={{\r\n                        color:\r\n                          selectedTextTrackIndex === track.index\r\n                            ? primary\r\n                            : 'white',\r\n                      }}>\r\n                      {track.language}\r\n                    </Text>\r\n                    <Text\r\n                      className={'text-sm italic'}\r\n                      style={{\r\n                        color:\r\n                          selectedTextTrackIndex === track.index\r\n                            ? primary\r\n                            : 'white',\r\n                      }}>\r\n                      {track.type}\r\n                    </Text>\r\n                    <Text\r\n                      className={'text-sm italic text-white'}\r\n                      style={{\r\n                        color:\r\n                          selectedTextTrackIndex === track.index\r\n                            ? primary\r\n                            : 'white',\r\n                      }}>\r\n                      {track.title}\r\n                    </Text>\r\n                    {selectedTextTrackIndex === track.index && (\r\n                      <MaterialIcons name=\"check\" size={20} color=\"white\" />\r\n                    )}\r\n                  </TouchableOpacity>\r\n                )}\r\n              />\r\n            )}\r\n\r\n            {/* Server Tab */}\r\n            {activeTab === 'server' && (\r\n              <View className=\"flex flex-row w-full h-full p-1 px-4\">\r\n                <ScrollView className=\"border-r border-white/50\">\r\n                  <Text className=\"w-full text-center text-white text-lg font-extrabold\">\r\n                    Server\r\n                  </Text>\r\n                  {streamData?.length > 0 &&\r\n                    streamData?.map((track, i) => (\r\n                      <TouchableOpacity\r\n                        className=\"flex-row gap-3 items-center rounded-md my-1 overflow-hidden ml-2\"\r\n                        key={i}\r\n                        onPress={() => {\r\n                          setSelectedStream(track);\r\n                          setShowSettings(false);\r\n                          playerRef?.current?.resume();\r\n                        }}>\r\n                        <Text\r\n                          className={'text-base capitalize font-semibold'}\r\n                          style={{\r\n                            color:\r\n                              track.link === selectedStream.link\r\n                                ? primary\r\n                                : 'white',\r\n                          }}>\r\n                          {track.server}\r\n                        </Text>\r\n                        {track.link === selectedStream.link && (\r\n                          <MaterialIcons name=\"check\" size={20} color=\"white\" />\r\n                        )}\r\n                      </TouchableOpacity>\r\n                    ))}\r\n                </ScrollView>\r\n\r\n                <ScrollView>\r\n                  <Text className=\"w-full text-center text-white text-lg font-extrabold\">\r\n                    Quality\r\n                  </Text>\r\n                  {videoTracks &&\r\n                    videoTracks.map((track: any, i: any) => (\r\n                      <TouchableOpacity\r\n                        className=\"flex-row gap-3 items-center rounded-md my-1 overflow-hidden ml-2\"\r\n                        key={i}\r\n                        onPress={() => {\r\n                          setSelectedVideoTrack({\r\n                            type: SelectedVideoTrackType.INDEX,\r\n                            value: track.index,\r\n                          });\r\n                          setSelectedQualityIndex(i);\r\n                        }}>\r\n                        <Text\r\n                          className={'text-base font-semibold'}\r\n                          style={{\r\n                            color:\r\n                              selectedQualityIndex === i ? primary : 'white',\r\n                          }}>\r\n                          {track.height + 'p'}\r\n                        </Text>\r\n                        <Text\r\n                          className={'text-sm italic'}\r\n                          style={{\r\n                            color:\r\n                              selectedQualityIndex === i ? primary : 'white',\r\n                          }}>\r\n                          {'Bitrate-' +\r\n                            track.bitrate +\r\n                            ' | Codec-' +\r\n                            (track?.codecs || 'unknown')}\r\n                        </Text>\r\n                        {selectedQualityIndex === i && (\r\n                          <MaterialIcons name=\"check\" size={20} color=\"white\" />\r\n                        )}\r\n                      </TouchableOpacity>\r\n                    ))}\r\n                </ScrollView>\r\n              </View>\r\n            )}\r\n\r\n            {/* Speed Tab */}\r\n            {activeTab === 'speed' && (\r\n              <ScrollView className=\"w-full h-full p-1 px-4\">\r\n                <Text className=\"text-lg font-bold text-center text-white\">\r\n                  Playback Speed\r\n                </Text>\r\n                {playbacks.map((rate, i) => (\r\n                  <TouchableOpacity\r\n                    className=\"flex-row gap-3 items-center rounded-md my-1 overflow-hidden ml-2\"\r\n                    key={i}\r\n                    onPress={() => {\r\n                      setPlaybackRate(rate);\r\n                      setShowSettings(false);\r\n                    }}>\r\n                    <Text\r\n                      className={'text-lg font-semibold'}\r\n                      style={{\r\n                        color: playbackRate === rate ? primary : 'white',\r\n                      }}>\r\n                      {rate}x\r\n                    </Text>\r\n                    {playbackRate === rate && (\r\n                      <MaterialIcons name=\"check\" size={20} color=\"white\" />\r\n                    )}\r\n                  </TouchableOpacity>\r\n                ))}\r\n              </ScrollView>\r\n            )}\r\n          </View>\r\n        </Animated.View>\r\n      )}\r\n    </SafeAreaView>\r\n  );\r\n};\r\n\r\nexport default Player;\r\n","size_bytes":39109},"src/screens/settings/About.tsx":{"content":"import {\r\n  View,\r\n  Text,\r\n  TouchableNativeFeedback,\r\n  ToastAndroid,\r\n  Linking,\r\n  Alert,\r\n  Switch,\r\n} from 'react-native';\r\n// import pkg from '../../../package.json';\r\nimport React, {useState} from 'react';\r\nimport {Feather} from '@expo/vector-icons';\r\nimport {settingsStorage} from '../../lib/storage';\r\nimport * as RNFS from '@dr.pogodin/react-native-fs';\r\nimport {MaterialCommunityIcons} from '@expo/vector-icons';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport * as Application from 'expo-application';\r\nimport {notificationService} from '../../lib/services/Notification';\r\n\r\n// download update\r\nconst downloadUpdate = async (url: string, name: string) => {\r\n  console.log('downloading', url, name);\r\n  await notificationService.requestPermission();\r\n\r\n  try {\r\n    if (await RNFS.exists(`${RNFS.DownloadDirectoryPath}/${name}`)) {\r\n      await notificationService.displayUpdateNotification({\r\n        id: 'downloadComplete',\r\n        title: 'Download Completed',\r\n        body: 'Tap to install',\r\n        data: {name: `${name}`, action: 'install'},\r\n      });\r\n      return;\r\n    }\r\n  } catch (error) {}\r\n  const {promise} = RNFS.downloadFile({\r\n    fromUrl: url,\r\n    background: true,\r\n    progressInterval: 1000,\r\n    progressDivider: 1,\r\n    toFile: `${RNFS.DownloadDirectoryPath}/${name}`,\r\n    begin: res => {\r\n      console.log('begin', res.jobId, res.statusCode, res.headers);\r\n    },\r\n    progress: res => {\r\n      console.log('progress', res.bytesWritten, res.contentLength);\r\n      notificationService.showUpdateProgress(\r\n        'Downloading Update',\r\n        `Version ${Application.nativeApplicationVersion} -> ${name}`,\r\n        {\r\n          current: res.bytesWritten,\r\n          max: res.contentLength,\r\n          indeterminate: false,\r\n        },\r\n      );\r\n    },\r\n  });\r\n  promise.then(async res => {\r\n    if (res.statusCode === 200) {\r\n      await notificationService.cancelNotification('updateProgress');\r\n      await notificationService.displayUpdateNotification({\r\n        id: 'downloadComplete',\r\n        title: 'Download Complete',\r\n        body: 'Tap to install',\r\n        data: {name, action: 'install'},\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\n// handle check for update\r\nexport const checkForUpdate = async (\r\n  setUpdateLoading: React.Dispatch<React.SetStateAction<boolean>>,\r\n  autoDownload: boolean,\r\n  showToast: boolean = true,\r\n) => {\r\n  setUpdateLoading(true);\r\n  try {\r\n    const res = await fetch(\r\n      'https://api.github.com/repos/Zenda-Cross/vega-app/releases/latest',\r\n    );\r\n    const data = await res.json();\r\n    const localVersion = Application.nativeApplicationVersion;\r\n    const remoteVersion = Number(\r\n      data.tag_name.replace('v', '')?.split('.').join(''),\r\n    );\r\n    if (compareVersions(localVersion || '', data.tag_name.replace('v', ''))) {\r\n      ToastAndroid.show('New update available', ToastAndroid.SHORT);\r\n      Alert.alert(`Update v${localVersion} -> ${data.tag_name}`, data.body, [\r\n        {text: 'Cancel'},\r\n        {\r\n          text: 'Update',\r\n          onPress: () =>\r\n            autoDownload\r\n              ? downloadUpdate(\r\n                  data?.assets?.[2]?.browser_download_url,\r\n                  data.assets?.[2]?.name,\r\n                )\r\n              : Linking.openURL(data.html_url),\r\n        },\r\n      ]);\r\n      console.log(\r\n        'local version',\r\n        localVersion,\r\n        'remote version',\r\n        remoteVersion,\r\n      );\r\n    } else {\r\n      showToast && ToastAndroid.show('App is up to date', ToastAndroid.SHORT);\r\n      console.log(\r\n        'local version',\r\n        localVersion,\r\n        'remote version',\r\n        remoteVersion,\r\n      );\r\n    }\r\n  } catch (error) {\r\n    ToastAndroid.show('Failed to check for update', ToastAndroid.SHORT);\r\n    console.log('Update error', error);\r\n  }\r\n  setUpdateLoading(false);\r\n};\r\n\r\nconst About = () => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const [updateLoading, setUpdateLoading] = useState(false);\r\n  const [autoDownload, setAutoDownload] = useState(\r\n    settingsStorage.isAutoDownloadEnabled(),\r\n  );\r\n  const [autoCheckUpdate, setAutoCheckUpdate] = useState<boolean>(\r\n    settingsStorage.isAutoCheckUpdateEnabled(),\r\n  );\r\n\r\n  return (\r\n    <View className=\"flex-1 bg-black mt-8\">\r\n      <View className=\"px-4 py-3 border-b border-white/10\">\r\n        <Text className=\"text-2xl font-bold text-white\">About</Text>\r\n        <Text className=\"text-gray-400 mt-1 text-sm\">\r\n          App information and updates\r\n        </Text>\r\n      </View>\r\n\r\n      <View className=\"p-4 space-y-4 pb-24\">\r\n        {/* Version */}\r\n        <View className=\"bg-white/10 p-4 rounded-lg flex-row justify-between items-center\">\r\n          <Text className=\"text-white text-base\">Version</Text>\r\n          <Text className=\"text-white/70\">\r\n            v{Application.nativeApplicationVersion}\r\n          </Text>\r\n        </View>\r\n\r\n        {/* Auto Install Updates */}\r\n        <View className=\"bg-white/10 p-4 rounded-lg flex-row justify-between items-center\">\r\n          <Text className=\"text-white text-base\">Auto Install Updates</Text>\r\n          <Switch\r\n            value={autoDownload}\r\n            onValueChange={() => {\r\n              setAutoDownload(!autoDownload);\r\n              settingsStorage.setAutoDownloadEnabled(!autoDownload);\r\n            }}\r\n            thumbColor={autoDownload ? primary : 'gray'}\r\n          />\r\n        </View>\r\n\r\n        {/* Auto Check Updates */}\r\n        <View className=\"bg-white/10 p-3 rounded-lg flex-row justify-between items-center\">\r\n          <View className=\"flex-1 mr-2\">\r\n            <Text className=\"text-white text-base\">Check Updates on Start</Text>\r\n            <Text className=\"text-gray-400 text-sm\">\r\n              Automatically check for updates when app starts\r\n            </Text>\r\n          </View>\r\n          <Switch\r\n            value={autoCheckUpdate}\r\n            onValueChange={() => {\r\n              setAutoCheckUpdate(!autoCheckUpdate);\r\n              settingsStorage.setAutoCheckUpdateEnabled(!autoCheckUpdate);\r\n            }}\r\n            thumbColor={autoCheckUpdate ? primary : 'gray'}\r\n          />\r\n        </View>\r\n\r\n        {/* Check Updates Button */}\r\n        <TouchableNativeFeedback\r\n          onPress={() => checkForUpdate(setUpdateLoading, autoDownload, true)}\r\n          disabled={updateLoading}\r\n          background={TouchableNativeFeedback.Ripple('#ffffff20', false)}>\r\n          <View className=\"bg-white/10 p-4 rounded-lg flex-row justify-between items-center mt-4\">\r\n            <View className=\"flex-row items-center space-x-3\">\r\n              <MaterialCommunityIcons name=\"update\" size={22} color=\"white\" />\r\n              <Text className=\"text-white text-base\">Check for Updates</Text>\r\n            </View>\r\n            <Feather name=\"chevron-right\" size={20} color=\"white\" />\r\n          </View>\r\n        </TouchableNativeFeedback>\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default About;\r\n\r\nfunction compareVersions(localVersion: string, remoteVersion: string): boolean {\r\n  try {\r\n    // Split versions into arrays and convert to numbers\r\n    const local = localVersion.split('.').map(Number);\r\n    const remote = remoteVersion.split('.').map(Number);\r\n\r\n    // Compare major version\r\n    if (remote[0] > local[0]) {\r\n      return true;\r\n    }\r\n    if (remote[0] < local[0]) {\r\n      return false;\r\n    }\r\n\r\n    // Compare minor version\r\n    if (remote[1] > local[1]) {\r\n      return true;\r\n    }\r\n    if (remote[1] < local[1]) {\r\n      return false;\r\n    }\r\n\r\n    // Compare patch version\r\n    if (remote[2] > local[2]) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  } catch (error) {\r\n    console.error('Invalid version format');\r\n    return false;\r\n  }\r\n}\r\n","size_bytes":7741},"src/screens/settings/DisableProviders.tsx":{"content":"import {\r\n  View,\r\n  Text,\r\n  ScrollView,\r\n  StatusBar,\r\n  Switch,\r\n  TouchableOpacity,\r\n} from 'react-native';\r\nimport React, {useState} from 'react';\r\nimport {providersStorage} from '../../lib/storage';\r\nimport {providersList} from '../../lib/constants';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport {SvgUri} from 'react-native-svg';\r\n\r\nconst DisableProviders = () => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const [disabledProviders, setDisabledProviders] = useState<string[]>(\r\n    providersStorage.getDisabledProviders(),\r\n  );\r\n\r\n  const toggleProvider = (providerId: string) => {\r\n    const newDisabled = providersStorage.toggleProvider(providerId);\r\n    setDisabledProviders(newDisabled);\r\n  };\r\n\r\n  const enableAll = () => {\r\n    providersStorage.enableAllProviders();\r\n    setDisabledProviders([]);\r\n  };\r\n\r\n  return (\r\n    <ScrollView\r\n      className=\"w-full h-full bg-black\"\r\n      contentContainerStyle={{\r\n        paddingTop: StatusBar.currentHeight || 0,\r\n      }}>\r\n      <View className=\"p-5\">\r\n        <View className=\"flex-row items-center justify-between mb-6\">\r\n          <Text className=\"text-2xl font-bold text-white\">\r\n            Disable Providers\r\n          </Text>\r\n          <TouchableOpacity\r\n            onPress={enableAll}\r\n            className=\"bg-[#262626] px-4 py-2 rounded-lg\">\r\n            <Text className=\"text-white text-xs\">Enable All</Text>\r\n          </TouchableOpacity>\r\n        </View>\r\n\r\n        <Text className=\"text-gray-400 text-sm mb-3\">\r\n          Disabled providers won't appear in search results\r\n        </Text>\r\n\r\n        <View className=\"bg-[#1A1A1A] rounded-xl overflow-hidden\">\r\n          {providersList.map((provider, index) => (\r\n            <View\r\n              key={provider.value}\r\n              className={`flex-row items-center justify-between p-4 ${\r\n                index !== providersList.length - 1\r\n                  ? 'border-b border-[#262626]'\r\n                  : ''\r\n              }`}>\r\n              <View className=\"flex-row items-center\">\r\n                <View className=\"bg-[#262626] p-2 rounded-lg mr-3\">\r\n                  <SvgUri width={24} height={24} uri={provider.flag} />\r\n                </View>\r\n                <View>\r\n                  <Text className=\"text-white text-base\">{provider.name}</Text>\r\n                  <Text className=\"text-gray-400 text-xs\">\r\n                    {provider.type || 'Content Provider'}\r\n                  </Text>\r\n                </View>\r\n              </View>\r\n              <Switch\r\n                thumbColor={\r\n                  !disabledProviders.includes(provider.value) ? primary : 'gray'\r\n                }\r\n                value={!disabledProviders.includes(provider.value)}\r\n                onValueChange={() => toggleProvider(provider.value)}\r\n              />\r\n            </View>\r\n          ))}\r\n        </View>\r\n\r\n        <Text className=\"text-gray-400 text-xs text-center mt-4\">\r\n          Changes will apply to new searches\r\n        </Text>\r\n      </View>\r\n    </ScrollView>\r\n  );\r\n};\r\n\r\nexport default DisableProviders;\r\n","size_bytes":3098},"src/screens/settings/Downloads.tsx":{"content":"import {View, Text, Image, Platform, TouchableOpacity} from 'react-native';\r\nimport requestStoragePermission from '../../lib/file/getStoragePermission';\r\nimport * as FileSystem from 'expo-file-system';\r\nimport {downloadFolder} from '../../lib/constants';\r\nimport * as VideoThumbnails from 'expo-video-thumbnails';\r\nimport React, {useState, useEffect} from 'react';\r\nimport {settingsStorage, downloadsStorage} from '../../lib/storage';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport * as RNFS from '@dr.pogodin/react-native-fs';\r\nimport MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport {NativeStackNavigationProp} from '@react-navigation/native-stack';\r\nimport {RootStackParamList} from '../../App';\r\nimport RNReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport {FlashList} from '@shopify/flash-list';\r\n\r\n// Define supported video extensions\r\nconst VIDEO_EXTENSIONS = [\r\n  '.mp4',\r\n  '.mov',\r\n  '.avi',\r\n  '.mkv',\r\n  '.wmv',\r\n  '.flv',\r\n  '.webm',\r\n  '.m4v',\r\n];\r\n\r\nconst isVideoFile = (filename: string): boolean => {\r\n  const extension = filename.toLowerCase().slice(filename.lastIndexOf('.'));\r\n  return VIDEO_EXTENSIONS.includes(extension);\r\n};\r\n\r\n// Add this interface after the existing imports\r\ninterface MediaGroup {\r\n  title: string;\r\n  episodes: FileSystem.FileInfo[];\r\n  thumbnail?: string;\r\n  isMovie: boolean;\r\n}\r\n\r\nconst normalizeString = (str: string): string => {\r\n  return str\r\n    .toLowerCase()\r\n    .replace(/[\\s.-]+/g, ' ') // normalize spaces, dots, and hyphens\r\n    .replace(/[^\\w\\s]/g, '') // remove special characters\r\n    .trim();\r\n};\r\n\r\nconst getBaseName = (fileName: string): string => {\r\n  let baseName = fileName\r\n    .replace(/\\.(mp4|mkv|avi|mov)$/i, '') // remove extension\r\n    .replace(/(?:480p|720p|1080p|2160p|HEVC|x264|BluRay|WEB-DL|HDRip).*$/i, '') // remove quality tags\r\n    .replace(/\\[.*?\\]/g, '') // remove bracketed text\r\n    .replace(/\\(.*?\\)/g, '') // remove parenthesized text\r\n    .replace(/(?:episode|ep)[\\s-]*\\d+/gi, '') // remove episode indicators\r\n    .replace(/s\\d{1,2}e\\d{1,2}/gi, '') // remove SxxExx format\r\n    .replace(/season[\\s-]*\\d+/gi, '') // remove season indicators\r\n    .replace(/\\s*-\\s*\\d+/, '') // remove trailing numbers\r\n    .replace(/\\s*\\d+\\s*$/, '') // remove ending numbers\r\n    .trim();\r\n\r\n  // Remove any remaining numbers at the end that might be episode numbers\r\n  baseName = baseName.replace(/[\\s.-]*\\d+$/, '');\r\n\r\n  return baseName;\r\n};\r\n\r\nconst getEpisodeInfo = (\r\n  fileName: string,\r\n): {season: number; episode: number} => {\r\n  // Try to match SxxExx format first\r\n  let match = fileName.match(/s(\\d{1,2})e(\\d{1,2})/i);\r\n  if (match) {\r\n    return {season: parseInt(match[1], 10), episode: parseInt(match[2], 10)};\r\n  }\r\n\r\n  // Try to match \"Season X Episode Y\" format\r\n  match = fileName.match(/season[\\s.-]*(\\d{1,2}).*?episode[\\s.-]*(\\d{1,2})/i);\r\n  if (match) {\r\n    return {season: parseInt(match[1], 10), episode: parseInt(match[2], 10)};\r\n  }\r\n\r\n  // Try to match episode number only\r\n  match =\r\n    fileName.match(/(?:episode|ep)[\\s.-]*(\\d{1,2})/i) ||\r\n    fileName.match(/[\\s.-](\\d{1,2})(?:\\s*$|\\s*\\.)/);\r\n\r\n  if (match) {\r\n    return {season: 1, episode: parseInt(match[1], 10)};\r\n  }\r\n\r\n  // Default case\r\n  return {season: 1, episode: 0};\r\n};\r\n\r\nconst Downloads = () => {\r\n  const [files, setFiles] = useState<FileSystem.FileInfo[]>([]);\r\n  const [thumbnails, setThumbnails] = useState<Record<string, string>>({});\r\n  const [loading, setLoading] = useState(true);\r\n\r\n  const {primary} = useThemeStore(state => state);\r\n\r\n  const [groupSelected, setGroupSelected] = useState<string[]>([]);\r\n  const [isSelecting, setIsSelecting] = useState(false);\r\n\r\n  const navigation =\r\n    useNavigation<NativeStackNavigationProp<RootStackParamList>>();\r\n\r\n  // Load files from the download folder on initial render\r\n  useEffect(() => {\r\n    const getFiles = async () => {\r\n      setLoading(true);\r\n      const granted = await requestStoragePermission();\r\n      if (granted) {\r\n        try {\r\n          const properPath =\r\n            Platform.OS === 'android'\r\n              ? `file://${downloadFolder}`\r\n              : downloadFolder;\r\n\r\n          const allFiles = await FileSystem.readDirectoryAsync(properPath);\r\n\r\n          // Filter video files\r\n          const videoFiles = allFiles.filter(file => isVideoFile(file));\r\n\r\n          const filesInfo = await Promise.all(\r\n            videoFiles.map(async file => {\r\n              const filePath =\r\n                Platform.OS === 'android'\r\n                  ? `file://${downloadFolder}/${file}`\r\n                  : `${downloadFolder}/${file}`;\r\n\r\n              const fileInfo = await FileSystem.getInfoAsync(filePath);\r\n              return fileInfo;\r\n            }),\r\n          );\r\n\r\n          // Save files info to storage\r\n          downloadsStorage.saveFilesInfo(filesInfo);\r\n          setFiles(filesInfo);\r\n          setLoading(false);\r\n        } catch (error) {\r\n          console.error('Error reading files:', error);\r\n          setLoading(false);\r\n        }\r\n      }\r\n    };\r\n    getFiles();\r\n  }, []);\r\n\r\n  async function getThumbnail(file: FileSystem.FileInfo) {\r\n    try {\r\n      // Verify it's a video file before attempting to generate thumbnail\r\n      const fileName = file.uri.split('/').pop();\r\n      if (!fileName || !isVideoFile(fileName)) {\r\n        return null;\r\n      }\r\n\r\n      const {uri} = await VideoThumbnails.getThumbnailAsync(file.uri, {\r\n        time: 100000,\r\n      });\r\n      return uri;\r\n    } catch (error) {\r\n      console.log('error in getThumbnail:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Generate thumbnails for each file\r\n  useEffect(() => {\r\n    const getThumbnails = async () => {\r\n      try {\r\n        const thumbnailPromises = files.map(async file => {\r\n          const thumbnail = await getThumbnail(file);\r\n          if (thumbnail) {\r\n            return {[file.uri]: thumbnail};\r\n          }\r\n          return null;\r\n        });\r\n\r\n        const thumbnailResults = await Promise.all(thumbnailPromises);\r\n        const newThumbnails = thumbnailResults.reduce((acc, curr) => {\r\n          return curr ? {...acc, ...curr} : acc;\r\n        }, {});\r\n\r\n        // Save thumbnails to storage and fix the type error by ensuring non-null\r\n        if (newThumbnails) {\r\n          downloadsStorage.saveThumbnails(newThumbnails);\r\n        }\r\n        setThumbnails(newThumbnails || {});\r\n      } catch (error) {\r\n        console.error('Error generating thumbnails:', error);\r\n      }\r\n    };\r\n\r\n    if (files.length > 0) {\r\n      getThumbnails();\r\n    }\r\n  }, [files]);\r\n\r\n  // Load files and thumbnails from storage on initial render\r\n  useEffect(() => {\r\n    const cachedFiles = downloadsStorage.getFilesInfo();\r\n    if (cachedFiles) {\r\n      setFiles(cachedFiles);\r\n    }\r\n\r\n    const cachedThumbnails = downloadsStorage.getThumbnails();\r\n    if (cachedThumbnails) {\r\n      setThumbnails(cachedThumbnails);\r\n    }\r\n  }, []);\r\n\r\n  const deleteFiles = async () => {\r\n    try {\r\n      // Process each file\r\n      await Promise.all(\r\n        groupSelected.map(async fileUri => {\r\n          try {\r\n            // Remove the 'file://' prefix for Android\r\n            const path =\r\n              Platform.OS === 'android'\r\n                ? fileUri.replace('file://', '')\r\n                : fileUri;\r\n\r\n            const fileInfo = await FileSystem.getInfoAsync(fileUri);\r\n            if (fileInfo.exists) {\r\n              await RNFS.unlink(path);\r\n            }\r\n          } catch (error) {\r\n            console.error(`Error deleting file ${fileUri}:`, error);\r\n            throw error; // Re-throw to be caught by the outer try-catch\r\n          }\r\n        }),\r\n      );\r\n\r\n      // Update state after successful deletion\r\n      const newFiles = files.filter(file => !groupSelected.includes(file.uri));\r\n      setFiles(newFiles);\r\n      setGroupSelected([]);\r\n      setIsSelecting(false);\r\n\r\n      // Optional: Show success message\r\n    } catch (error) {\r\n      console.error('Error deleting files:', error);\r\n    }\r\n  };\r\n\r\n  // Add this function to group files by series name\r\n  const groupMediaFiles = (): MediaGroup[] => {\r\n    const groups: Record<string, MediaGroup> = {};\r\n\r\n    // First pass: Group by normalized base name\r\n    files.forEach(file => {\r\n      const fileName = file.uri.split('/').pop() || '';\r\n      const baseName = getBaseName(fileName);\r\n      const normalizedBaseName = normalizeString(baseName);\r\n\r\n      if (!groups[normalizedBaseName]) {\r\n        groups[normalizedBaseName] = {\r\n          title: baseName,\r\n          episodes: [],\r\n          thumbnail: thumbnails[file.uri],\r\n          isMovie: true,\r\n        };\r\n      }\r\n      groups[normalizedBaseName].episodes.push(file);\r\n    });\r\n\r\n    // Second pass: Determine if each group is a movie or series\r\n    Object.values(groups).forEach(group => {\r\n      const hasEpisodeIndicators = group.episodes.some(file => {\r\n        const fileName = file.uri.split('/').pop() || '';\r\n        return getEpisodeInfo(fileName).episode > 0;\r\n      });\r\n\r\n      group.isMovie = !(group.episodes.length > 1 || hasEpisodeIndicators);\r\n\r\n      // Sort episodes by season and episode number if it's a series\r\n      if (!group.isMovie) {\r\n        group.episodes.sort((a, b) => {\r\n          const aName = a.uri.split('/').pop() || '';\r\n          const bName = b.uri.split('/').pop() || '';\r\n          const aInfo = getEpisodeInfo(aName);\r\n          const bInfo = getEpisodeInfo(bName);\r\n\r\n          if (aInfo.season !== bInfo.season) {\r\n            return aInfo.season - bInfo.season;\r\n          }\r\n          return aInfo.episode - bInfo.episode;\r\n        });\r\n      }\r\n    });\r\n\r\n    return Object.values(groups);\r\n  };\r\n\r\n  return (\r\n    <View className=\"mt-14 px-2 w-full h-full\">\r\n      <View className=\"flex-row justify-between items-center mb-4\">\r\n        <Text className=\"text-2xl\">Downloads</Text>\r\n        <View className=\"flex-row gap-x-7 items-center\">\r\n          {isSelecting && (\r\n            <MaterialCommunityIcons\r\n              name=\"close\"\r\n              size={28}\r\n              color={primary}\r\n              onPress={() => {\r\n                setGroupSelected([]);\r\n                setIsSelecting(false);\r\n              }}\r\n            />\r\n          )}\r\n          {isSelecting && groupSelected.length > 0 && (\r\n            <MaterialCommunityIcons\r\n              name=\"delete-outline\"\r\n              size={28}\r\n              color={primary}\r\n              onPress={deleteFiles}\r\n            />\r\n          )}\r\n        </View>\r\n      </View>\r\n\r\n      <FlashList\r\n        data={groupMediaFiles()}\r\n        numColumns={3}\r\n        estimatedItemSize={150}\r\n        ListEmptyComponent={() =>\r\n          !loading && (\r\n            <View className=\"flex-1 justify-center items-center mt-10\">\r\n              <Text className=\"text-center text-lg\">Looks Empty Here!</Text>\r\n            </View>\r\n          )\r\n        }\r\n        renderItem={({item}) => (\r\n          <TouchableOpacity\r\n            className={`flex-1 m-0.5 rounded-lg overflow-hidden ${\r\n              isSelecting && groupSelected.includes(item.episodes[0].uri)\r\n                ? 'bg-quaternary'\r\n                : 'bg-tertiary'\r\n            }`}\r\n            onLongPress={() => {\r\n              if (settingsStorage.isHapticFeedbackEnabled()) {\r\n                RNReactNativeHapticFeedback.trigger('effectTick', {\r\n                  enableVibrateFallback: true,\r\n                  ignoreAndroidSystemSettings: false,\r\n                });\r\n              }\r\n              setGroupSelected(item.episodes.map(ep => ep.uri));\r\n              setIsSelecting(true);\r\n            }}\r\n            onPress={() => {\r\n              if (isSelecting) {\r\n                if (settingsStorage.isHapticFeedbackEnabled()) {\r\n                  RNReactNativeHapticFeedback.trigger('effectTick', {\r\n                    enableVibrateFallback: true,\r\n                    ignoreAndroidSystemSettings: false,\r\n                  });\r\n                }\r\n                if (groupSelected.includes(item.episodes[0].uri)) {\r\n                  setGroupSelected(\r\n                    groupSelected.filter(f => f !== item.episodes[0].uri),\r\n                  );\r\n                } else {\r\n                  setGroupSelected([...groupSelected, item.episodes[0].uri]);\r\n                }\r\n                if (\r\n                  groupSelected.length === 1 &&\r\n                  groupSelected[0] === item.episodes[0].uri\r\n                ) {\r\n                  setIsSelecting(false);\r\n                  setGroupSelected([]);\r\n                }\r\n              } else {\r\n                // Direct play for movies, navigate to episodes for series\r\n                if (item.isMovie) {\r\n                  const file = item.episodes[0];\r\n                  const fileName = file.uri.split('/').pop() || '';\r\n                  navigation.navigate('Player', {\r\n                    episodeList: [{title: fileName, link: file.uri}],\r\n                    linkIndex: 0,\r\n                    type: '',\r\n                    directUrl: file.uri,\r\n                    primaryTitle: item.title,\r\n                    poster: {},\r\n                    providerValue: 'vega',\r\n                  });\r\n                } else {\r\n                  navigation.navigate('TabStack', {\r\n                    screen: 'SettingsStack',\r\n                    params: {\r\n                      screen: 'WatchHistoryStack',\r\n                      params: {\r\n                        screen: 'SeriesEpisodes',\r\n                        params: {\r\n                          episodes: item.episodes as any,\r\n                          series: item.title,\r\n                          thumbnails: thumbnails,\r\n                        },\r\n                      },\r\n                    },\r\n                  });\r\n                }\r\n              }\r\n            }}>\r\n            <View className=\"relative aspect-[2/3]\">\r\n              {item.thumbnail ? (\r\n                <Image\r\n                  source={{uri: item.thumbnail}}\r\n                  className=\"w-full h-full rounded-t-lg\"\r\n                  resizeMode=\"cover\"\r\n                />\r\n              ) : (\r\n                <View className=\"w-full h-full bg-quaternary rounded-t-lg\" />\r\n              )}\r\n              <View className=\"absolute bottom-0 left-0 right-0 bg-black/50 p-1\">\r\n                <Text className=\"text-white text-xs\" numberOfLines={1}>\r\n                  {item.title}\r\n                </Text>\r\n                {!item.isMovie && (\r\n                  <Text className=\"text-white text-xs opacity-70\">\r\n                    {item.episodes.length} episodes\r\n                  </Text>\r\n                )}\r\n              </View>\r\n            </View>\r\n          </TouchableOpacity>\r\n        )}\r\n      />\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default Downloads;\r\n","size_bytes":14876},"src/screens/settings/Extensions.tsx":{"content":"import React, {useState, useEffect} from 'react';\r\nimport {\r\n  View,\r\n  Text,\r\n  TouchableOpacity,\r\n  StatusBar,\r\n  FlatList,\r\n  ActivityIndicator,\r\n  Alert,\r\n  RefreshControl,\r\n  Image,\r\n} from 'react-native';\r\nimport {NativeStackScreenProps} from '@react-navigation/native-stack';\r\nimport {SettingsStackParamList} from '../../App';\r\nimport {\r\n  MaterialCommunityIcons,\r\n  MaterialIcons,\r\n  Feather,\r\n  AntDesign,\r\n} from '@expo/vector-icons';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport useContentStore from '../../lib/zustand/contentStore';\r\nimport {\r\n  extensionStorage,\r\n  ProviderExtension,\r\n} from '../../lib/storage/extensionStorage';\r\nimport {extensionManager} from '../../lib/services/ExtensionManager';\r\nimport {\r\n  updateProvidersService,\r\n  UpdateInfo,\r\n} from '../../lib/services/UpdateProviders';\r\nimport ReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport {settingsStorage} from '../../lib/storage';\r\nimport RenderProviderFlagIcon from '../../components/RenderProviderFLagIcon';\r\n\r\ntype Props = NativeStackScreenProps<SettingsStackParamList, 'Extensions'>;\r\n\r\ntype TabType = 'installed' | 'available';\r\n\r\nconst Extensions = ({navigation}: Props) => {\r\n  const {primary} = useThemeStore(state => state);\r\n  const {\r\n    provider: activeExtensionProvider,\r\n    setProvider: setActiveExtensionProvider,\r\n    installedProviders,\r\n    availableProviders,\r\n    setInstalledProviders,\r\n    setAvailableProviders,\r\n  } = useContentStore(state => state);\r\n  const [activeTab, setActiveTab] = useState<TabType>(\r\n    installedProviders?.length > 0 ? 'installed' : 'available',\r\n  );\r\n  const [installingProvider, setInstallingProvider] = useState<string | null>(\r\n    null,\r\n  );\r\n  const [updatingProvider, setUpdatingProvider] = useState<string | null>(null);\r\n  const [updateInfos, setUpdateInfos] = useState<UpdateInfo[]>([]);\r\n  const [refreshing, setRefreshing] = useState(false);\r\n  // Load providers on component mount\r\n  useEffect(() => {\r\n    const initializeExtensions = async () => {\r\n      try {\r\n        await extensionManager.initialize();\r\n        loadProviders();\r\n        await checkForUpdates();\r\n\r\n        // Try to fetch latest providers if we don't have any\r\n        if (!availableProviders || availableProviders.length === 0) {\r\n          await handleRefresh();\r\n        }\r\n      } catch (error) {\r\n        // Still try to load from cache if initialization fails\r\n        loadProviders();\r\n      }\r\n    };\r\n\r\n    initializeExtensions();\r\n  }, []);\r\n  const loadProviders = () => {\r\n    const installed = extensionStorage.getInstalledProviders() || [];\r\n    const available = extensionStorage.getAvailableProviders() || [];\r\n    setInstalledProviders(installed);\r\n    setAvailableProviders(available.filter(item => item && !item.disabled));\r\n  };\r\n  const checkForUpdates = async () => {\r\n    try {\r\n      const updates = await updateProvidersService.checkForUpdatesManual();\r\n      setUpdateInfos(updates);\r\n    } catch (error) {\r\n      console.error('Error checking for updates:', error);\r\n    }\r\n  };\r\n\r\n  const handleUpdateProvider = async (provider: ProviderExtension) => {\r\n    if (!provider || !provider.value) {\r\n      Alert.alert('Error', 'Invalid provider data');\r\n      return;\r\n    }\r\n\r\n    if (settingsStorage.isHapticFeedbackEnabled()) {\r\n      ReactNativeHapticFeedback.trigger('effectClick', {\r\n        enableVibrateFallback: true,\r\n        ignoreAndroidSystemSettings: false,\r\n      });\r\n    }\r\n\r\n    setUpdatingProvider(provider.value);\r\n    try {\r\n      const success = await updateProvidersService.updateProvider(provider);\r\n      if (success) {\r\n        loadProviders();\r\n        await checkForUpdates();\r\n\r\n        Alert.alert(\r\n          'Success',\r\n          `${provider.display_name} has been updated successfully!`,\r\n        );\r\n\r\n        // Update the active provider if it was the one being updated\r\n        if (activeExtensionProvider?.value === provider.value) {\r\n          setActiveExtensionProvider(provider);\r\n        }\r\n      } else {\r\n        Alert.alert('Error', 'Failed to update provider. Please try again.');\r\n      }\r\n    } catch (error) {\r\n      console.error('Update error:', error);\r\n      Alert.alert('Error', 'Failed to update provider. Please try again.');\r\n    } finally {\r\n      setUpdatingProvider(null);\r\n    }\r\n  };\r\n\r\n  const handleTabChange = (tab: TabType) => {\r\n    if (settingsStorage.isHapticFeedbackEnabled()) {\r\n      ReactNativeHapticFeedback.trigger('effectTick', {\r\n        enableVibrateFallback: true,\r\n        ignoreAndroidSystemSettings: false,\r\n      });\r\n    }\r\n    setActiveTab(tab);\r\n  };\r\n  const handleInstallProvider = async (provider: ProviderExtension) => {\r\n    if (!provider || !provider.value) {\r\n      Alert.alert('Error', 'Invalid provider data');\r\n      return;\r\n    }\r\n\r\n    if (settingsStorage.isHapticFeedbackEnabled()) {\r\n      ReactNativeHapticFeedback.trigger('effectClick', {\r\n        enableVibrateFallback: true,\r\n        ignoreAndroidSystemSettings: false,\r\n      });\r\n    }\r\n\r\n    setInstallingProvider(provider.value);\r\n    try {\r\n      await extensionManager.installProvider(provider);\r\n      loadProviders();\r\n\r\n      Alert.alert(\r\n        'Success',\r\n        `${provider.display_name} has been installed successfully!`,\r\n      );\r\n      setInstalledProviders(extensionStorage.getInstalledProviders() || []);\r\n      if (\r\n        !activeExtensionProvider ||\r\n        activeExtensionProvider.value !== provider.value\r\n      ) {\r\n        setActiveExtensionProvider(provider);\r\n      }\r\n    } catch (error) {\r\n      console.error('Installation error:', error);\r\n      Alert.alert('Error', 'Failed to install provider. Please try again.');\r\n    } finally {\r\n      setInstallingProvider(null);\r\n    }\r\n  };\r\n  const handleUninstallProvider = (provider: ProviderExtension) => {\r\n    if (!provider || !provider.value) {\r\n      Alert.alert('Error', 'Invalid provider data');\r\n      return;\r\n    }\r\n\r\n    Alert.alert(\r\n      'Uninstall Provider',\r\n      `Are you sure you want to uninstall ${\r\n        provider.display_name || 'this provider'\r\n      }?`,\r\n      [\r\n        {text: 'Cancel', style: 'cancel'},\r\n        {\r\n          text: 'Uninstall',\r\n          style: 'destructive',\r\n          onPress: () => {\r\n            extensionStorage.uninstallProvider(provider.value);\r\n            loadProviders();\r\n            setInstalledProviders(\r\n              extensionStorage.getInstalledProviders() || [],\r\n            );\r\n\r\n            // If this was the active provider, clear it\r\n            if (activeExtensionProvider?.value === provider?.value) {\r\n              setActiveExtensionProvider(\r\n                extensionStorage.getInstalledProviders()[0] || {\r\n                  value: '',\r\n                  display_name: '',\r\n                  type: '',\r\n                  version: '',\r\n                },\r\n              );\r\n            }\r\n          },\r\n        },\r\n      ],\r\n    );\r\n  };\r\n  const handleSetActiveProvider = (provider: ProviderExtension) => {\r\n    if (!provider || !provider.value) {\r\n      Alert.alert('Error', 'Invalid provider data');\r\n      return;\r\n    }\r\n\r\n    if (settingsStorage.isHapticFeedbackEnabled()) {\r\n      ReactNativeHapticFeedback.trigger('effectClick', {\r\n        enableVibrateFallback: true,\r\n        ignoreAndroidSystemSettings: false,\r\n      });\r\n    }\r\n    setActiveExtensionProvider(provider);\r\n  };\r\n  const handleRefresh = async () => {\r\n    setRefreshing(true);\r\n    try {\r\n      const providers = await extensionManager.fetchManifest(true);\r\n\r\n      // Update available providers in storage and state\r\n      extensionStorage.setAvailableProviders(providers);\r\n      setAvailableProviders(providers);\r\n\r\n      loadProviders();\r\n      await checkForUpdates();\r\n    } catch (error) {\r\n      console.error('Refresh error:', error);\r\n      Alert.alert(\r\n        'Error',\r\n        'Failed to refresh providers list. Please check your internet connection.',\r\n      );\r\n    } finally {\r\n      setRefreshing(false);\r\n    }\r\n  };\r\n  const renderProviderCard = ({item}: {item: ProviderExtension}) => {\r\n    if (!item || !item.value) return null;\r\n    const isActive = activeExtensionProvider?.value === item.value;\r\n    const isInstalled = extensionStorage.isProviderInstalled(item.value);\r\n    const isInstalling = installingProvider === item.value;\r\n    const isUpdating = updatingProvider === item.value;\r\n    const updateInfo = updateInfos.find(\r\n      info => info.provider.value === item.value,\r\n    );\r\n    const hasUpdate = updateInfo?.hasUpdate || false;\r\n\r\n    return (\r\n      <View\r\n        className=\"bg-tertiary rounded-2xl p-5 py-3 mb-4 mx-4 shadow-lg border border-quaternary\"\r\n        style={{elevation: 4}}>\r\n        <View className=\"flex-row items-center mb-4 gap-4 justify-between\">\r\n          {/* Left: Icon */}\r\n          {item.icon ? (\r\n            <Image\r\n              source={{uri: item.icon}}\r\n              className=\"w-12 h-12 rounded-xl border-2 border-primary bg-quaternary\"\r\n              style={{resizeMode: 'cover'}}\r\n            />\r\n          ) : (\r\n            <View className=\"px-3 py-2 bg-quaternary rounded-xl border border-gray-700\">\r\n              <RenderProviderFlagIcon type={item.type} />\r\n            </View>\r\n          )}\r\n          {/* Middle: Info */}\r\n          <View className=\"flex-1 mx-3\">\r\n            <View className=\"flex-row items-center flex-wrap\">\r\n              <Text className=\"text-white text-lg font-bold tracking-wide\">\r\n                {item.display_name || 'Unknown Provider'}\r\n              </Text>\r\n              {hasUpdate && updateInfo && (\r\n                <View\r\n                  style={{backgroundColor: primary}}\r\n                  className=\"px-2 py-0.5 rounded-full ml-1\">\r\n                  <Text className=\"text-xs text-white font-semibold bg-gray-800\">\r\n                    Update\r\n                  </Text>\r\n                </View>\r\n              )}\r\n            </View>\r\n            <Text className=\"text-gray-400 text-sm \">\r\n              Version{' '}\r\n              <Text className=\"text-white font-medium\">\r\n                {item.version || 'Unknown'}\r\n              </Text>{' '}\r\n              • {item.type || 'Unknown'}\r\n            </Text>\r\n          </View>\r\n          {/* Right: Buttons */}\r\n          <View className=\"flex-row gap-3 items-center\">\r\n            {activeTab === 'installed' ? (\r\n              <>\r\n                <TouchableOpacity\r\n                  onPress={() => handleSetActiveProvider(item)}\r\n                  className={`w-9 h-9 rounded-full items-center justify-center ${\r\n                    isActive ? 'bg-green-600' : 'bg-gray-700'\r\n                  }`}\r\n                  style={{opacity: isActive ? 1 : 0.9}}>\r\n                  <MaterialIcons\r\n                    name={isActive ? 'check-circle' : 'radio-button-unchecked'}\r\n                    size={20}\r\n                    color=\"white\"\r\n                  />\r\n                </TouchableOpacity>\r\n                {hasUpdate && (\r\n                  <TouchableOpacity\r\n                    onPress={() => handleUpdateProvider(updateInfo!.provider)}\r\n                    disabled={isUpdating}\r\n                    className=\"w-9 h-9 rounded-full items-center justify-center\"\r\n                    style={{\r\n                      backgroundColor: primary,\r\n                      opacity: isUpdating ? 0.7 : 1,\r\n                    }}>\r\n                    {isUpdating ? (\r\n                      <ActivityIndicator size=\"small\" color=\"white\" />\r\n                    ) : (\r\n                      <MaterialCommunityIcons\r\n                        name=\"update\"\r\n                        size={20}\r\n                        color=\"white\"\r\n                      />\r\n                    )}\r\n                  </TouchableOpacity>\r\n                )}\r\n                <TouchableOpacity\r\n                  onPress={() => handleUninstallProvider(item)}\r\n                  className=\"w-9 h-9 rounded-full items-center justify-center bg-red-600\">\r\n                  <MaterialCommunityIcons\r\n                    name=\"delete\"\r\n                    size={20}\r\n                    color=\"white\"\r\n                  />\r\n                </TouchableOpacity>\r\n              </>\r\n            ) : (\r\n              <TouchableOpacity\r\n                onPress={() => handleInstallProvider(item)}\r\n                disabled={isInstalled || isInstalling}\r\n                className={'w-9 h-9 rounded-full items-center justify-center'}\r\n                style={{\r\n                  opacity: isInstalling ? 0.7 : 1,\r\n                  backgroundColor: isInstalled ? 'gray' : primary,\r\n                }}>\r\n                {isInstalling ? (\r\n                  <ActivityIndicator size=\"small\" color=\"white\" />\r\n                ) : (\r\n                  <MaterialCommunityIcons\r\n                    name={isInstalled ? 'check' : 'download'}\r\n                    size={20}\r\n                    color=\"white\"\r\n                  />\r\n                )}\r\n              </TouchableOpacity>\r\n            )}\r\n          </View>\r\n        </View>\r\n      </View>\r\n    );\r\n  };\r\n  const currentData =\r\n    activeTab === 'installed'\r\n      ? (installedProviders || []).filter(item => item && item.value)\r\n      : (availableProviders || []).filter(item => item && item.value);\r\n\r\n  return (\r\n    <View className=\"flex-1 bg-black pt-10 pb-16\">\r\n      <StatusBar backgroundColor=\"black\" barStyle=\"light-content\" />\r\n      {/* Header */}\r\n      <View className=\"flex-row items-center justify-between p-4 border-b border-gray-800\">\r\n        <TouchableOpacity onPress={() => navigation.navigate('Settings')}>\r\n          <AntDesign name=\"arrowleft\" size={24} color=\"white\" />\r\n        </TouchableOpacity>\r\n        <Text className=\"text-white text-xl font-semibold\">Providers</Text>\r\n        <TouchableOpacity onPress={handleRefresh}>\r\n          <Feather name=\"refresh-cw\" size={24} color={primary} />\r\n        </TouchableOpacity>\r\n      </View>\r\n      {/* Tabs */}\r\n      <View className=\"flex-row bg-quaternary mx-4 mt-4 rounded-xl\">\r\n        <TouchableOpacity\r\n          onPress={() => handleTabChange('installed')}\r\n          className=\"flex-1 py-3 rounded-xl\"\r\n          style={{\r\n            backgroundColor:\r\n              activeTab === 'installed' ? primary : 'transparent',\r\n          }}>\r\n          <Text\r\n            className={`text-center font-medium ${\r\n              activeTab === 'installed' ? 'text-white' : 'text-gray-400'\r\n            }`}>\r\n            Installed ({(installedProviders || []).length})\r\n          </Text>\r\n        </TouchableOpacity>\r\n\r\n        <TouchableOpacity\r\n          onPress={() => handleTabChange('available')}\r\n          className=\"flex-1 py-3 rounded-xl\"\r\n          style={{\r\n            backgroundColor:\r\n              activeTab === 'available' ? primary : 'transparent',\r\n          }}>\r\n          <Text\r\n            className={`text-center font-medium ${\r\n              activeTab === 'available' ? 'text-white' : 'text-gray-400'\r\n            }`}>\r\n            Available ({(availableProviders || []).length})\r\n          </Text>\r\n        </TouchableOpacity>\r\n      </View>\r\n      {/* Provider list */}\r\n      <FlatList\r\n        data={currentData}\r\n        keyExtractor={(item, index) => item?.value || `provider-${index}`}\r\n        renderItem={renderProviderCard}\r\n        className=\"flex-1 mt-4\"\r\n        refreshControl={\r\n          <RefreshControl\r\n            refreshing={refreshing}\r\n            onRefresh={handleRefresh}\r\n            colors={[primary]}\r\n            tintColor={primary}\r\n            progressBackgroundColor=\"black\"\r\n          />\r\n        }\r\n        ListEmptyComponent={\r\n          <View className=\"flex-1 justify-center items-center py-20\">\r\n            <MaterialCommunityIcons\r\n              name=\"package-variant\"\r\n              size={64}\r\n              color=\"gray\"\r\n            />\r\n            <Text className=\"text-gray-400 text-lg mt-4\">\r\n              {activeTab === 'installed'\r\n                ? 'No providers installed'\r\n                : 'No providers available'}\r\n            </Text>\r\n            <Text className=\"text-gray-500 text-sm mt-2 text-center px-8\">\r\n              {activeTab === 'installed'\r\n                ? 'Install providers from the Available tab to get started'\r\n                : 'Pull to refresh to check for available providers'}\r\n            </Text>\r\n          </View>\r\n        }\r\n      />\r\n    </View>\r\n  );\r\n};\r\n\r\nexport default Extensions;\r\n","size_bytes":16436},"src/screens/settings/Preference.tsx":{"content":"import {\r\n  View,\r\n  Text,\r\n  Switch,\r\n  ScrollView,\r\n  TouchableOpacity,\r\n  ToastAndroid,\r\n  StatusBar,\r\n} from 'react-native';\r\nimport React, {useState} from 'react';\r\nimport {settingsStorage} from '../../lib/storage';\r\nimport MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';\r\nimport RNReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport {Dropdown} from 'react-native-element-dropdown';\r\nimport {themes} from '../../lib/constants';\r\nimport {TextInput} from 'react-native';\r\nimport Constants from 'expo-constants';\r\n// Lazy-load Firebase to allow running without google-services.json\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst getAnalytics = (): any | null => {\r\n  try {\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    return require('@react-native-firebase/analytics').default;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst getCrashlytics = (): any | null => {\r\n  try {\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    return require('@react-native-firebase/crashlytics').default;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\nconst Preferences = () => {\r\n  const hasFirebase = Boolean(Constants?.expoConfig?.extra?.hasFirebase);\r\n  const {primary, setPrimary, isCustom, setCustom} = useThemeStore(\r\n    state => state,\r\n  );\r\n  const [showRecentlyWatched, setShowRecentlyWatched] = useState(\r\n    settingsStorage.getBool('showRecentlyWatched') || false,\r\n  );\r\n  const [disableDrawer, setDisableDrawer] = useState(\r\n    settingsStorage.getBool('disableDrawer') || false,\r\n  );\r\n\r\n  const [ExcludedQualities, setExcludedQualities] = useState(\r\n    settingsStorage.getExcludedQualities(),\r\n  );\r\n\r\n  const [customColor, setCustomColor] = useState(\r\n    settingsStorage.getCustomColor(),\r\n  );\r\n\r\n  const [showMediaControls, setShowMediaControls] = useState<boolean>(\r\n    settingsStorage.showMediaControls(),\r\n  );\r\n\r\n  const [showHamburgerMenu, setShowHamburgerMenu] = useState<boolean>(\r\n    settingsStorage.showHamburgerMenu(),\r\n  );\r\n\r\n  const [hideSeekButtons, setHideSeekButtons] = useState<boolean>(\r\n    settingsStorage.hideSeekButtons(),\r\n  );\r\n\r\n  const [_enable2xGesture, _setEnable2xGesture] = useState<boolean>(\r\n    settingsStorage.isEnable2xGestureEnabled(),\r\n  );\r\n\r\n  const [enableSwipeGesture, setEnableSwipeGesture] = useState<boolean>(\r\n    settingsStorage.isSwipeGestureEnabled(),\r\n  );\r\n\r\n  const [showTabBarLables, setShowTabBarLables] = useState<boolean>(\r\n    settingsStorage.showTabBarLabels(),\r\n  );\r\n\r\n  const [OpenExternalPlayer, setOpenExternalPlayer] = useState(\r\n    settingsStorage.getBool('useExternalPlayer', false),\r\n  );\r\n\r\n  const [hapticFeedback, setHapticFeedback] = useState(\r\n    settingsStorage.isHapticFeedbackEnabled(),\r\n  );\r\n\r\n  const [alwaysUseExternalDownload, setAlwaysUseExternalDownload] = useState(\r\n    settingsStorage.getBool('alwaysExternalDownloader') || false,\r\n  );\r\n\r\n  const [telemetryOptIn, setTelemetryOptIn] = useState<boolean>(\r\n    settingsStorage.isTelemetryOptIn(),\r\n  );\r\n\r\n  return (\r\n    <ScrollView\r\n      className=\"w-full h-full bg-black\"\r\n      contentContainerStyle={{\r\n        paddingTop: StatusBar.currentHeight || 0,\r\n      }}>\r\n      <View className=\"p-5\">\r\n        <Text className=\"text-2xl font-bold text-white mb-6\">Preferences</Text>\r\n\r\n        {/* Theme Section */}\r\n        <View className=\"mb-6\">\r\n          <Text className=\"text-gray-400 text-sm mb-3\">Appearance</Text>\r\n          <View className=\"bg-[#1A1A1A] rounded-xl overflow-hidden\">\r\n            {/* Theme Selector */}\r\n            <View className=\"flex-row items-center px-4 justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">Theme</Text>\r\n              <View className=\"w-36\">\r\n                {isCustom ? (\r\n                  <View className=\"flex-row items-center gap-2\">\r\n                    <TextInput\r\n                      style={{\r\n                        color: 'white',\r\n                        backgroundColor: '#262626',\r\n                        borderRadius: 8,\r\n                        paddingHorizontal: 8,\r\n                        paddingVertical: 4,\r\n                        fontSize: 14,\r\n                      }}\r\n                      placeholder=\"Hex Color\"\r\n                      placeholderTextColor=\"gray\"\r\n                      value={customColor}\r\n                      onChangeText={setCustomColor}\r\n                      onSubmitEditing={e => {\r\n                        if (e.nativeEvent.text.length < 7) {\r\n                          ToastAndroid.show(\r\n                            'Invalid Color',\r\n                            ToastAndroid.SHORT,\r\n                          );\r\n                          return;\r\n                        }\r\n                        settingsStorage.setCustomColor(e.nativeEvent.text);\r\n                        setPrimary(e.nativeEvent.text);\r\n                      }}\r\n                    />\r\n                    <TouchableOpacity\r\n                      onPress={() => {\r\n                        setCustom(false);\r\n                        setPrimary('#FF6347');\r\n                      }}>\r\n                      <MaterialCommunityIcons\r\n                        name=\"close\"\r\n                        size={20}\r\n                        color=\"gray\"\r\n                      />\r\n                    </TouchableOpacity>\r\n                  </View>\r\n                ) : (\r\n                  <Dropdown\r\n                    selectedTextStyle={{\r\n                      color: 'white',\r\n                      fontSize: 14,\r\n                      fontWeight: '500',\r\n                    }}\r\n                    containerStyle={{\r\n                      backgroundColor: '#262626',\r\n                      borderRadius: 8,\r\n                      borderWidth: 0,\r\n                      marginTop: 4,\r\n                    }}\r\n                    itemTextStyle={{color: 'white'}}\r\n                    activeColor=\"#3A3A3A\"\r\n                    itemContainerStyle={{\r\n                      backgroundColor: '#262626',\r\n                      borderWidth: 0,\r\n                    }}\r\n                    style={{\r\n                      backgroundColor: '#262626',\r\n                      borderWidth: 0,\r\n                    }}\r\n                    iconStyle={{tintColor: 'white'}}\r\n                    placeholderStyle={{color: 'white'}}\r\n                    labelField=\"name\"\r\n                    valueField=\"color\"\r\n                    data={themes}\r\n                    value={primary}\r\n                    onChange={value => {\r\n                      if (value.name === 'Custom') {\r\n                        setCustom(true);\r\n                        setPrimary(customColor);\r\n                        return;\r\n                      }\r\n                      setPrimary(value.color);\r\n                    }}\r\n                  />\r\n                )}\r\n              </View>\r\n            </View>\r\n\r\n            {/* Haptic Feedback */}\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">Haptic Feedback</Text>\r\n              <Switch\r\n                thumbColor={hapticFeedback ? primary : 'gray'}\r\n                value={hapticFeedback}\r\n                onValueChange={() => {\r\n                  settingsStorage.setHapticFeedbackEnabled(!hapticFeedback);\r\n                  setHapticFeedback(!hapticFeedback);\r\n                }}\r\n              />\r\n            </View>\r\n\r\n            {/* Analytics & Crashlytics Opt-In */}\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">\r\n                Usage & Crash Reports\r\n              </Text>\r\n              <Switch\r\n                thumbColor={telemetryOptIn ? primary : 'gray'}\r\n                value={telemetryOptIn}\r\n                onValueChange={async () => {\r\n                  const next = !telemetryOptIn;\r\n                  setTelemetryOptIn(next);\r\n                  settingsStorage.setTelemetryOptIn(next);\r\n                  if (hasFirebase) {\r\n                    try {\r\n                      const crashlytics = getCrashlytics();\r\n                      crashlytics &&\r\n                        (await crashlytics().setCrashlyticsCollectionEnabled(\r\n                          next,\r\n                        ));\r\n                    } catch {}\r\n                    try {\r\n                      const analytics = getAnalytics();\r\n                      analytics &&\r\n                        (await analytics().setAnalyticsCollectionEnabled(next));\r\n                      // Also update consent for completeness\r\n                      analytics &&\r\n                        (await analytics().setConsent({\r\n                          analytics_storage: next,\r\n                          ad_storage: next,\r\n                          ad_user_data: next,\r\n                          ad_personalization: next,\r\n                        }));\r\n                    } catch {}\r\n                  }\r\n                }}\r\n              />\r\n            </View>\r\n\r\n            {/* Show Tab Bar Labels */}\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">Show Tab Bar Labels</Text>\r\n              <Switch\r\n                thumbColor={showTabBarLables ? primary : 'gray'}\r\n                value={showTabBarLables}\r\n                onValueChange={() => {\r\n                  settingsStorage.setShowTabBarLabels(!showTabBarLables);\r\n                  setShowTabBarLables(!showTabBarLables);\r\n                  ToastAndroid.show(\r\n                    'Restart App to Apply Changes',\r\n                    ToastAndroid.SHORT,\r\n                  );\r\n                }}\r\n              />\r\n            </View>\r\n\r\n            {/* Show Hamburger Menu */}\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">Show Hamburger Menu</Text>\r\n              <Switch\r\n                thumbColor={showHamburgerMenu ? primary : 'gray'}\r\n                value={showHamburgerMenu}\r\n                onValueChange={() => {\r\n                  settingsStorage.setShowHamburgerMenu(!showHamburgerMenu);\r\n                  setShowHamburgerMenu(!showHamburgerMenu);\r\n                }}\r\n              />\r\n            </View>\r\n\r\n            {/* Show Recently Watched */}\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">\r\n                Show Recently Watched\r\n              </Text>\r\n              <Switch\r\n                thumbColor={showRecentlyWatched ? primary : 'gray'}\r\n                value={showRecentlyWatched}\r\n                onValueChange={() => {\r\n                  settingsStorage.setBool(\r\n                    'showRecentlyWatched',\r\n                    !showRecentlyWatched,\r\n                  );\r\n                  setShowRecentlyWatched(!showRecentlyWatched);\r\n                }}\r\n              />\r\n            </View>\r\n\r\n            {/* Disable Drawer */}\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">Disable Drawer</Text>\r\n              <Switch\r\n                thumbColor={disableDrawer ? primary : 'gray'}\r\n                value={disableDrawer}\r\n                onValueChange={() => {\r\n                  settingsStorage.setBool('disableDrawer', !disableDrawer);\r\n                  setDisableDrawer(!disableDrawer);\r\n                }}\r\n              />\r\n            </View>\r\n\r\n            {/* Always Use External Downloader */}\r\n            <View className=\"flex-row items-center justify-between p-4\">\r\n              <Text className=\"text-white text-base\">\r\n                Always Use External Downloader\r\n              </Text>\r\n              <Switch\r\n                thumbColor={alwaysUseExternalDownload ? primary : 'gray'}\r\n                value={alwaysUseExternalDownload}\r\n                onValueChange={() => {\r\n                  settingsStorage.setBool(\r\n                    'alwaysExternalDownloader',\r\n                    !alwaysUseExternalDownload,\r\n                  );\r\n                  setAlwaysUseExternalDownload(!alwaysUseExternalDownload);\r\n                }}\r\n              />\r\n            </View>\r\n          </View>\r\n        </View>\r\n\r\n        {/* Player Settings */}\r\n        <View className=\"mb-6\">\r\n          <Text className=\"text-gray-400 text-sm mb-3\">Player</Text>\r\n          <View className=\"bg-[#1A1A1A] rounded-xl overflow-hidden\">\r\n            {/* External Player */}\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">\r\n                Always Use External Player\r\n              </Text>\r\n              <Switch\r\n                thumbColor={OpenExternalPlayer ? primary : 'gray'}\r\n                value={OpenExternalPlayer}\r\n                onValueChange={val => {\r\n                  settingsStorage.setBool('useExternalPlayer', val);\r\n                  setOpenExternalPlayer(val);\r\n                }}\r\n              />\r\n            </View>\r\n\r\n            {/* Media Controls */}\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">Media Controls</Text>\r\n              <Switch\r\n                thumbColor={showMediaControls ? primary : 'gray'}\r\n                value={showMediaControls}\r\n                onValueChange={() => {\r\n                  settingsStorage.setShowMediaControls(!showMediaControls);\r\n                  setShowMediaControls(!showMediaControls);\r\n                }}\r\n              />\r\n            </View>\r\n\r\n            {/* Hide Seek Buttons */}\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <Text className=\"text-white text-base\">Hide Seek Buttons</Text>\r\n              <Switch\r\n                thumbColor={hideSeekButtons ? primary : 'gray'}\r\n                value={hideSeekButtons}\r\n                onValueChange={() => {\r\n                  settingsStorage.setHideSeekButtons(!hideSeekButtons);\r\n                  setHideSeekButtons(!hideSeekButtons);\r\n                }}\r\n              />\r\n            </View>\r\n\r\n            {/* Swipe Gestures */}\r\n            <View className=\"flex-row items-center justify-between p-4\">\r\n              <Text className=\"text-white text-base\">\r\n                Enable Swipe Gestures\r\n              </Text>\r\n              <Switch\r\n                thumbColor={enableSwipeGesture ? primary : 'gray'}\r\n                value={enableSwipeGesture}\r\n                onValueChange={() => {\r\n                  settingsStorage.setSwipeGestureEnabled(!enableSwipeGesture);\r\n                  setEnableSwipeGesture(!enableSwipeGesture);\r\n                }}\r\n              />\r\n            </View>\r\n          </View>\r\n        </View>\r\n\r\n        {/* Quality Settings */}\r\n        <View className=\"mb-6\">\r\n          <Text className=\"text-gray-400 text-sm mb-3\">Quality</Text>\r\n          <View className=\"bg-[#1A1A1A] rounded-xl p-4\">\r\n            <Text className=\"text-white text-base mb-3\">\r\n              Excluded Qualities\r\n            </Text>\r\n            <View className=\"flex-row flex-wrap gap-2\">\r\n              {['360p', '480p', '720p'].map((quality, index) => (\r\n                <TouchableOpacity\r\n                  key={index}\r\n                  onPress={() => {\r\n                    if (settingsStorage.isHapticFeedbackEnabled()) {\r\n                      RNReactNativeHapticFeedback.trigger('effectTick');\r\n                    }\r\n                    const newExcluded = ExcludedQualities.includes(quality)\r\n                      ? ExcludedQualities.filter(q => q !== quality)\r\n                      : [...ExcludedQualities, quality];\r\n                    setExcludedQualities(newExcluded);\r\n                    settingsStorage.setExcludedQualities(newExcluded);\r\n                  }}\r\n                  style={{\r\n                    backgroundColor: ExcludedQualities.includes(quality)\r\n                      ? primary\r\n                      : '#262626',\r\n                  }}\r\n                  className=\"px-4 py-2 rounded-lg\">\r\n                  <Text className=\"text-white text-sm\">{quality}</Text>\r\n                </TouchableOpacity>\r\n              ))}\r\n            </View>\r\n          </View>\r\n        </View>\r\n\r\n        <View className=\"h-16\" />\r\n      </View>\r\n    </ScrollView>\r\n  );\r\n};\r\n\r\nexport default Preferences;\r\n","size_bytes":16902},"src/screens/settings/SeriesEpisodes.tsx":{"content":"import React from 'react';\nimport {View, Text, Image, TouchableOpacity} from 'react-native';\nimport {FlashList} from '@shopify/flash-list';\nimport {NativeStackScreenProps} from '@react-navigation/native-stack';\nimport MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';\n// import * as FileSystem from 'expo-file-system';\nimport {RootStackParamList} from '../../App';\n\ntype SeriesEpisodesRouteProp = NativeStackScreenProps<\n  RootStackParamList,\n  'SeriesEpisodes'\n>;\n\nconst SeriesEpisodes = ({navigation, route}: SeriesEpisodesRouteProp) => {\n  // const {primary} = useThemeStore(state => state);\n  const {series, episodes, thumbnails} = route.params;\n\n  // Function to extract episode number from filename\n  const getEpisodeNumber = (filename: string): number => {\n    const match =\n      filename.match(/episode[\\s-]*(\\d+)/i) ||\n      filename.match(/episode[_\\s-]*(\\d+)/i) ||\n      filename.match(/ep[\\s-]*(\\d+)/i) ||\n      filename.match(/Episodes[_\\s-]*(\\d+)/i) ||\n      filename.match(/Episode[_\\s-]*(\\d+)/i) ||\n      filename.match(/[^a-zA-Z]E(\\d+)[^a-zA-Z]/i) ||\n      filename.match(/[^\\d](\\d+)[^\\d]/);\n    console.log('match', match);\n\n    return match ? parseInt(match[1], 10) : 0;\n  };\n\n  // Sort episodes by episode number\n  const sortedEpisodes = [...episodes].sort((a, b) => {\n    const aFilename = a.uri.split('/').pop() || '';\n    const bFilename = b.uri.split('/').pop() || '';\n    return getEpisodeNumber(aFilename) - getEpisodeNumber(bFilename);\n  });\n\n  return (\n    <View className=\"w-full h-full bg-black\">\n      {/* Simple Header */}\n      <View className=\"bg-tertiary px-4 pt-14 pb-4\">\n        <View className=\"flex-row items-center\">\n          <TouchableOpacity\n            onPress={() => navigation.goBack()}\n            className=\"bg-quaternary p-2 rounded-full\">\n            <MaterialCommunityIcons name=\"arrow-left\" size={24} color=\"white\" />\n          </TouchableOpacity>\n          <Text\n            className=\"text-xl text-white font-bold ml-4 flex-1\"\n            numberOfLines={1}\n            ellipsizeMode=\"tail\">\n            {series.length > 20 ? series.substring(0, 20) + '...' : series}\n          </Text>\n        </View>\n      </View>\n\n      {/* Episodes list */}\n      <View className=\"flex-1 px-4\">\n        <View className=\"flex-row items-center justify-between py-4\">\n          <Text className=\"text-white text-lg font-bold\">Episodes</Text>\n          <Text className=\"text-gray-400\">{episodes.length} episodes</Text>\n        </View>\n\n        <FlashList\n          data={sortedEpisodes}\n          estimatedItemSize={100}\n          renderItem={({item}) => {\n            const fileName = item.uri.split('/').pop() || '';\n            const episodeNumber = getEpisodeNumber(fileName);\n\n            return (\n              <TouchableOpacity\n                className=\"flex-row bg-tertiary rounded-lg overflow-hidden mb-2 h-24\"\n                onPress={() => {\n                  navigation.navigate('Player', {\n                    episodeList: [{title: fileName || '', link: item.uri}],\n                    linkIndex: 0,\n                    type: '',\n                    directUrl: item.uri,\n                    primaryTitle: fileName,\n                    poster: {},\n                    providerValue: 'vega',\n                  });\n                }}>\n                <View className=\"w-32 h-full relative\">\n                  {thumbnails[item.uri] ? (\n                    <Image\n                      source={{uri: thumbnails[item.uri]}}\n                      className=\"w-full h-full rounded-t-lg\"\n                      resizeMode=\"cover\"\n                    />\n                  ) : (\n                    <View className=\"w-full h-full bg-quaternary rounded-t-lg\" />\n                  )}\n                  <View className=\"absolute bottom-2 right-2 bg-black/80 px-2 py-1 rounded\">\n                    <Text className=\"text-white text-xs\">\n                      EP {episodeNumber}\n                    </Text>\n                  </View>\n                </View>\n                <View className=\"flex-1 p-3 justify-center\">\n                  <Text className=\"text-base text-white font-medium mb-1\">\n                    Episode {episodeNumber}\n                  </Text>\n                  <Text className=\"text-[8px] my-1 text-gray-400\">\n                    {fileName}\n                  </Text>\n                  <Text className=\"text-sm text-gray-400\">\n                    {(item.size / (1024 * 1024)).toFixed(1)} MB\n                  </Text>\n                </View>\n              </TouchableOpacity>\n            );\n          }}\n        />\n      </View>\n    </View>\n  );\n};\n\nexport default SeriesEpisodes;\n","size_bytes":4655},"src/screens/settings/Settings.tsx":{"content":"import {\r\n  View,\r\n  Text,\r\n  Linking,\r\n  TouchableOpacity,\r\n  TouchableNativeFeedback,\r\n  ScrollView,\r\n  Dimensions,\r\n} from 'react-native';\r\nimport React, {useCallback, useMemo} from 'react';\r\nimport {\r\n  settingsStorage,\r\n  cacheStorageService,\r\n  ProviderExtension,\r\n} from '../../lib/storage';\r\nimport ReactNativeHapticFeedback from 'react-native-haptic-feedback';\r\nimport useContentStore from '../../lib/zustand/contentStore';\r\nimport {socialLinks} from '../../lib/constants';\r\nimport {\r\n  NativeStackScreenProps,\r\n  NativeStackNavigationProp,\r\n} from '@react-navigation/native-stack';\r\nimport {SettingsStackParamList, TabStackParamList} from '../../App';\r\nimport {\r\n  MaterialCommunityIcons,\r\n  AntDesign,\r\n  Feather,\r\n  MaterialIcons,\r\n} from '@expo/vector-icons';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport useWatchHistoryStore from '../../lib/zustand/watchHistrory';\r\nimport Animated, {FadeInDown, FadeInUp, Layout} from 'react-native-reanimated';\r\nimport {useNavigation} from '@react-navigation/native';\r\nimport RenderProviderFlagIcon from '../../components/RenderProviderFLagIcon';\r\n\r\ntype Props = NativeStackScreenProps<SettingsStackParamList, 'Settings'>;\r\n\r\nconst Settings = ({navigation}: Props) => {\r\n  const tabNavigation =\r\n    useNavigation<NativeStackNavigationProp<TabStackParamList>>();\r\n  const {primary} = useThemeStore(state => state);\r\n  const {provider, setProvider, installedProviders} = useContentStore(\r\n    state => state,\r\n  );\r\n  const {clearHistory} = useWatchHistoryStore(state => state);\r\n\r\n  const handleProviderSelect = useCallback(\r\n    (item: ProviderExtension) => {\r\n      setProvider(item);\r\n      // Add haptic feedback\r\n      if (settingsStorage.isHapticFeedbackEnabled()) {\r\n        ReactNativeHapticFeedback.trigger('virtualKey', {\r\n          enableVibrateFallback: true,\r\n          ignoreAndroidSystemSettings: false,\r\n        });\r\n      }\r\n      // Navigate to home screen\r\n      tabNavigation.navigate('HomeStack');\r\n    },\r\n    [setProvider, tabNavigation],\r\n  );\r\n\r\n  const renderProviderItem = useCallback(\r\n    (item: ProviderExtension, isSelected: boolean) => (\r\n      <TouchableOpacity\r\n        key={item.value}\r\n        onPress={() => handleProviderSelect(item)}\r\n        className={`mr-3 rounded-lg ${\r\n          isSelected ? 'bg-[#333333]' : 'bg-[#262626]'\r\n        }`}\r\n        style={{\r\n          width: Dimensions.get('window').width * 0.3, // Shows 2.5 items\r\n          height: 65, // Increased height\r\n          borderWidth: 1.5,\r\n          borderColor: isSelected ? primary : '#333333',\r\n        }}>\r\n        <View className=\"flex-col items-center justify-center h-full p-2\">\r\n          <RenderProviderFlagIcon type={item.type} />\r\n          <Text\r\n            numberOfLines={1}\r\n            className=\"text-white text-xs font-medium text-center mt-2\">\r\n            {item.display_name}\r\n          </Text>\r\n          {isSelected && (\r\n            <Text style={{position: 'absolute', top: 6, right: 6}}>\r\n              <MaterialIcons name=\"check-circle\" size={16} color={primary} />\r\n            </Text>\r\n          )}\r\n        </View>\r\n      </TouchableOpacity>\r\n    ),\r\n    [handleProviderSelect, primary],\r\n  );\r\n\r\n  const providersList = useMemo(\r\n    () =>\r\n      installedProviders.map(item =>\r\n        renderProviderItem(item, provider.value === item.value),\r\n      ),\r\n    [installedProviders, provider.value, renderProviderItem],\r\n  );\r\n\r\n  const clearCacheHandler = useCallback(() => {\r\n    if (settingsStorage.isHapticFeedbackEnabled()) {\r\n      ReactNativeHapticFeedback.trigger('virtualKey', {\r\n        enableVibrateFallback: true,\r\n        ignoreAndroidSystemSettings: false,\r\n      });\r\n    }\r\n    cacheStorageService.clearAll();\r\n  }, []);\r\n\r\n  const clearHistoryHandler = useCallback(() => {\r\n    if (settingsStorage.isHapticFeedbackEnabled()) {\r\n      ReactNativeHapticFeedback.trigger('virtualKey', {\r\n        enableVibrateFallback: true,\r\n        ignoreAndroidSystemSettings: false,\r\n      });\r\n    }\r\n    clearHistory();\r\n  }, [clearHistory]);\r\n\r\n  const AnimatedSection = ({\r\n    delay,\r\n    children,\r\n  }: {\r\n    delay: number;\r\n    children: React.ReactNode;\r\n  }) => (\r\n    <Animated.View\r\n      entering={FadeInDown.delay(delay).springify()}\r\n      layout={Layout.springify()}>\r\n      {children}\r\n    </Animated.View>\r\n  );\r\n\r\n  return (\r\n    <Animated.ScrollView\r\n      className=\"w-full h-full bg-black\"\r\n      showsVerticalScrollIndicator={false}\r\n      bounces={true}\r\n      overScrollMode=\"always\"\r\n      entering={FadeInUp.springify()}\r\n      layout={Layout.springify()}\r\n      contentContainerStyle={{\r\n        paddingTop: 15,\r\n        paddingBottom: 24,\r\n        flexGrow: 1,\r\n      }}>\r\n      <View className=\"p-5\">\r\n        <Animated.View entering={FadeInUp.springify()}>\r\n          <Text className=\"text-2xl font-bold text-white mb-6\">Settings</Text>\r\n        </Animated.View>\r\n\r\n        {/* Content provider section */}\r\n        <AnimatedSection delay={100}>\r\n          <View className=\"mb-6 flex-col gap-3\">\r\n            <Text className=\"text-gray-400 text-sm mb-1\">Content Provider</Text>\r\n            <View className=\"bg-[#1A1A1A] rounded-xl py-4\">\r\n              <ScrollView\r\n                horizontal\r\n                showsHorizontalScrollIndicator={false}\r\n                contentContainerStyle={{\r\n                  paddingHorizontal: 10,\r\n                }}>\r\n                {providersList}\r\n                {installedProviders.length === 0 && (\r\n                  <Text className=\"text-gray-500 text-sm\">\r\n                    No providers installed\r\n                  </Text>\r\n                )}\r\n              </ScrollView>\r\n            </View>\r\n            {/* Extensions */}\r\n            <View className=\"bg-[#1A1A1A] rounded-xl overflow-hidden mb-3\">\r\n              <TouchableNativeFeedback\r\n                onPress={() => navigation.navigate('Extensions')}\r\n                background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n                <View className=\"flex-row items-center justify-between p-4\">\r\n                  <View className=\"flex-row items-center\">\r\n                    <MaterialCommunityIcons\r\n                      name=\"puzzle\"\r\n                      size={22}\r\n                      color={primary}\r\n                    />\r\n                    <Text className=\"text-white ml-3 text-base\">\r\n                      Provider Manager\r\n                    </Text>\r\n                  </View>\r\n                  <Feather name=\"chevron-right\" size={20} color=\"gray\" />\r\n                </View>\r\n              </TouchableNativeFeedback>\r\n            </View>\r\n          </View>\r\n        </AnimatedSection>\r\n\r\n        {/* Main options section */}\r\n        <AnimatedSection delay={200}>\r\n          <View className=\"mb-6\">\r\n            <Text className=\"text-gray-400 text-sm mb-3\">Options</Text>\r\n            <View className=\"bg-[#1A1A1A] rounded-xl overflow-hidden\">\r\n              {/* Downloads */}\r\n              <TouchableNativeFeedback\r\n                onPress={() => navigation.navigate('Downloads')}\r\n                background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n                <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n                  <View className=\"flex-row items-center\">\r\n                    <MaterialCommunityIcons\r\n                      name=\"folder-download\"\r\n                      size={22}\r\n                      color={primary}\r\n                    />\r\n                    <Text className=\"text-white ml-3 text-base\">Downloads</Text>\r\n                  </View>\r\n                  <Feather name=\"chevron-right\" size={20} color=\"gray\" />\r\n                </View>\r\n              </TouchableNativeFeedback>\r\n\r\n              {/* Subtitle Style */}\r\n              <TouchableNativeFeedback\r\n                onPress={async () => {\r\n                  navigation.navigate('SubTitlesPreferences');\r\n                }}\r\n                background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n                <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n                  <View className=\"flex-row items-center\">\r\n                    <MaterialCommunityIcons\r\n                      name=\"subtitles\"\r\n                      size={22}\r\n                      color={primary}\r\n                    />\r\n                    <Text className=\"text-white ml-3 text-base\">\r\n                      Subtitle Style\r\n                    </Text>\r\n                  </View>\r\n                  <Feather name=\"chevron-right\" size={20} color=\"gray\" />\r\n                </View>\r\n              </TouchableNativeFeedback>\r\n\r\n              {/* Disable Providers */}\r\n              {/* <TouchableNativeFeedback\r\n                onPress={() => navigation.navigate('DisableProviders')}\r\n                background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n                <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n                  <View className=\"flex-row items-center\">\r\n                    <MaterialIcons name=\"block\" size={22} color={primary} />\r\n                    <Text className=\"text-white ml-3 text-base\">\r\n                      Disable Providers in Search\r\n                    </Text>\r\n                  </View>\r\n                  <Feather name=\"chevron-right\" size={20} color=\"gray\" />\r\n                </View>\r\n              </TouchableNativeFeedback> */}\r\n\r\n              {/* Watch History */}\r\n              <TouchableNativeFeedback\r\n                onPress={() => navigation.navigate('WatchHistoryStack')}\r\n                background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n                <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n                  <View className=\"flex-row items-center\">\r\n                    <MaterialCommunityIcons\r\n                      name=\"history\"\r\n                      size={22}\r\n                      color={primary}\r\n                    />\r\n                    <Text className=\"text-white ml-3 text-base\">\r\n                      Watch History\r\n                    </Text>\r\n                  </View>\r\n                  <Feather name=\"chevron-right\" size={20} color=\"gray\" />\r\n                </View>\r\n              </TouchableNativeFeedback>\r\n\r\n              {/* Preferences */}\r\n              <TouchableNativeFeedback\r\n                onPress={() => navigation.navigate('Preferences')}\r\n                background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n                <View className=\"flex-row items-center justify-between p-4\">\r\n                  <View className=\"flex-row items-center\">\r\n                    <MaterialIcons\r\n                      name=\"room-preferences\"\r\n                      size={22}\r\n                      color={primary}\r\n                    />\r\n                    <Text className=\"text-white ml-3 text-base\">\r\n                      Preferences\r\n                    </Text>\r\n                  </View>\r\n                  <Feather name=\"chevron-right\" size={20} color=\"gray\" />\r\n                </View>\r\n              </TouchableNativeFeedback>\r\n            </View>\r\n          </View>\r\n        </AnimatedSection>\r\n\r\n        {/* Data Management section */}\r\n        <AnimatedSection delay={300}>\r\n          <View className=\"mb-6\">\r\n            <Text className=\"text-gray-400 text-sm mb-3\">Data Management</Text>\r\n            <View className=\"bg-[#1A1A1A] rounded-xl overflow-hidden\">\r\n              {/* Clear Cache */}\r\n              <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n                <Text className=\"text-white text-base\">Clear Cache</Text>\r\n                <TouchableOpacity\r\n                  className=\"bg-[#262626] px-4 py-2 rounded-lg\"\r\n                  onPress={clearCacheHandler}>\r\n                  <MaterialCommunityIcons\r\n                    name=\"delete-outline\"\r\n                    size={20}\r\n                    color={primary}\r\n                  />\r\n                </TouchableOpacity>\r\n              </View>\r\n\r\n              {/* Clear Watch History */}\r\n              <View className=\"flex-row items-center justify-between p-4\">\r\n                <Text className=\"text-white text-base\">\r\n                  Clear Watch History\r\n                </Text>\r\n                <TouchableOpacity\r\n                  className=\"bg-[#262626] px-4 py-2 rounded-lg\"\r\n                  onPress={clearHistoryHandler}>\r\n                  <MaterialCommunityIcons\r\n                    name=\"delete-outline\"\r\n                    size={20}\r\n                    color={primary}\r\n                  />\r\n                </TouchableOpacity>\r\n              </View>\r\n            </View>\r\n          </View>\r\n        </AnimatedSection>\r\n\r\n        {/* About & GitHub section */}\r\n        <AnimatedSection delay={400}>\r\n          <View className=\"mb-6\">\r\n            <Text className=\"text-gray-400 text-sm mb-3\">About</Text>\r\n            <View className=\"bg-[#1A1A1A] rounded-xl overflow-hidden\">\r\n              {/* About */}\r\n              <TouchableNativeFeedback\r\n                onPress={() => navigation.navigate('About')}\r\n                background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n                <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n                  <View className=\"flex-row items-center\">\r\n                    <Feather name=\"info\" size={22} color={primary} />\r\n                    <Text className=\"text-white ml-3 text-base\">About</Text>\r\n                  </View>\r\n                  <Feather name=\"chevron-right\" size={20} color=\"gray\" />\r\n                </View>\r\n              </TouchableNativeFeedback>\r\n\r\n              {/* GitHub */}\r\n              <TouchableNativeFeedback\r\n                onPress={() => Linking.openURL(socialLinks.github)}\r\n                background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n                <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n                  <View className=\"flex-row items-center\">\r\n                    <AntDesign name=\"github\" size={22} color={primary} />\r\n                    <Text className=\"text-white ml-3 text-base\">\r\n                      Give a star ⭐\r\n                    </Text>\r\n                  </View>\r\n                  <Feather name=\"external-link\" size={20} color=\"gray\" />\r\n                </View>\r\n              </TouchableNativeFeedback>\r\n\r\n              {/* sponsore */}\r\n              <TouchableNativeFeedback\r\n                onPress={() => Linking.openURL(socialLinks.sponsor)}\r\n                background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n                <View className=\"flex-row items-center justify-between p-4\">\r\n                  <View className=\"flex-row items-center\">\r\n                    <AntDesign name=\"heart\" size={22} color=\"#ff69b4\" />\r\n                    <Text className=\"text-white ml-3 text-base\">\r\n                      Sponsor Project\r\n                    </Text>\r\n                  </View>\r\n                  <Feather name=\"external-link\" size={20} color=\"gray\" />\r\n                </View>\r\n              </TouchableNativeFeedback>\r\n            </View>\r\n          </View>\r\n        </AnimatedSection>\r\n      </View>\r\n    </Animated.ScrollView>\r\n  );\r\n};\r\n\r\nexport default Settings;\r\n","size_bytes":15430},"src/screens/settings/SubtitleSettings.tsx":{"content":"import {\r\n  View,\r\n  Text,\r\n  StatusBar,\r\n  TouchableOpacity,\r\n  TouchableNativeFeedback,\r\n} from 'react-native';\r\nimport React from 'react';\r\nimport {startActivityAsync, ActivityAction} from 'expo-intent-launcher';\r\nimport {ScrollView} from 'moti';\r\nimport {settingsStorage} from '../../lib/storage';\r\nimport useThemeStore from '../../lib/zustand/themeStore';\r\nimport {Feather, Entypo} from '@expo/vector-icons';\r\n\r\nconst SubtitlePreference = () => {\r\n  const [fontSize, setFontSize] = React.useState(\r\n    settingsStorage.getSubtitleFontSize(),\r\n  );\r\n  const [opacity, setOpacity] = React.useState(\r\n    settingsStorage.getSubtitleOpacity(),\r\n  );\r\n  const [bottomElevation, setBottomElevation] = React.useState(\r\n    settingsStorage.getSubtitleBottomPadding(),\r\n  );\r\n  const {primary} = useThemeStore();\r\n\r\n  const handleSubtitleSize = (action: 'increase' | 'decrease') => {\r\n    if (fontSize < 5 || fontSize > 30) return;\r\n    if (action === 'increase') {\r\n      const newSize = Math.min(fontSize + 1, 30);\r\n      settingsStorage.setSubtitleFontSize(newSize);\r\n      setFontSize(newSize);\r\n    }\r\n    if (action === 'decrease') {\r\n      const newSize = Math.max(fontSize - 1, 10);\r\n      settingsStorage.setSubtitleFontSize(newSize);\r\n      setFontSize(newSize);\r\n    }\r\n  };\r\n\r\n  const handleSubtitleOpacity = (action: 'increase' | 'decrease') => {\r\n    if (action === 'increase') {\r\n      const newOpacity = Math.min(opacity + 0.1, 1).toFixed(1);\r\n      settingsStorage.setSubtitleOpacity(parseFloat(newOpacity));\r\n      setOpacity(parseFloat(newOpacity));\r\n    }\r\n    if (action === 'decrease') {\r\n      const newOpacity = Math.max(opacity - 0.1, 0).toFixed(1);\r\n      settingsStorage.setSubtitleOpacity(parseFloat(newOpacity));\r\n      setOpacity(parseFloat(newOpacity));\r\n    }\r\n  };\r\n\r\n  const handleSubtitleBottomPadding = (action: 'increase' | 'decrease') => {\r\n    if (bottomElevation < 0 || bottomElevation > 99) return;\r\n    if (action === 'increase') {\r\n      const newPadding = Math.min(bottomElevation + 1, 99);\r\n      settingsStorage.setSubtitleBottomPadding(newPadding);\r\n      setBottomElevation(newPadding);\r\n    }\r\n    if (action === 'decrease') {\r\n      const newPadding = Math.max(bottomElevation - 1, 0);\r\n      settingsStorage.setSubtitleBottomPadding(newPadding);\r\n      setBottomElevation(newPadding);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <ScrollView\r\n      className=\"w-full h-full bg-black\"\r\n      contentContainerStyle={{\r\n        paddingTop: StatusBar.currentHeight || 0,\r\n      }}>\r\n      <View className=\"p-5\">\r\n        <Text className=\"text-2xl font-bold text-white mb-6\">\r\n          Subtitle Preferences\r\n        </Text>\r\n\r\n        <View className=\"bg-[#1A1A1A] rounded-xl overflow-hidden\">\r\n          <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n            <Text className=\"text-white text-base\">Font Size</Text>\r\n            <View className=\"flex-row items-center gap-4\">\r\n              <TouchableOpacity onPress={() => handleSubtitleSize('decrease')}>\r\n                <Entypo name=\"minus\" size={23} color={primary} />\r\n              </TouchableOpacity>\r\n              <Text className=\"text-white text-base bg-[#262626] px-3 rounded-md w-12 text-center\">\r\n                {fontSize}\r\n              </Text>\r\n              <TouchableOpacity onPress={() => handleSubtitleSize('increase')}>\r\n                <Entypo name=\"plus\" size={23} color={primary} />\r\n              </TouchableOpacity>\r\n            </View>\r\n          </View>\r\n\r\n          {/* opacity */}\r\n          <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n            <Text className=\"text-white text-base\">Opacity</Text>\r\n            <View className=\"flex-row items-center gap-4\">\r\n              <TouchableOpacity\r\n                onPress={() => handleSubtitleOpacity('decrease')}>\r\n                <Entypo name=\"minus\" size={23} color={primary} />\r\n              </TouchableOpacity>\r\n              <Text className=\"text-white text-base bg-[#262626] px-3 rounded-md w-12 text-center\">\r\n                {opacity}\r\n              </Text>\r\n              <TouchableOpacity\r\n                onPress={() => handleSubtitleOpacity('increase')}>\r\n                <Entypo name=\"plus\" size={23} color={primary} />\r\n              </TouchableOpacity>\r\n            </View>\r\n          </View>\r\n\r\n          {/* bottom padding */}\r\n          <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n            <Text className=\"text-white text-base\">Bottom Elevation</Text>\r\n            <View className=\"flex-row items-center gap-4\">\r\n              <TouchableOpacity\r\n                onPress={() => handleSubtitleBottomPadding('decrease')}>\r\n                <Entypo name=\"minus\" size={23} color={primary} />\r\n              </TouchableOpacity>\r\n              <Text className=\"text-white text-base bg-[#262626] px-3 rounded-md w-12 text-center\">\r\n                {bottomElevation}\r\n              </Text>\r\n              <TouchableOpacity\r\n                onPress={() => handleSubtitleBottomPadding('increase')}>\r\n                <Entypo name=\"plus\" size={23} color={primary} />\r\n              </TouchableOpacity>\r\n            </View>\r\n          </View>\r\n\r\n          {/* More Settings */}\r\n          <TouchableNativeFeedback\r\n            onPress={async () => {\r\n              await startActivityAsync(ActivityAction.CAPTIONING_SETTINGS);\r\n            }}\r\n            background={TouchableNativeFeedback.Ripple('#333333', false)}>\r\n            <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n              <View className=\"flex-row items-center\">\r\n                <Text className=\"text-white text-base\">\r\n                  More Subtitle Settings\r\n                </Text>\r\n              </View>\r\n              <Feather name=\"chevron-right\" size={20} color=\"gray\" />\r\n            </View>\r\n          </TouchableNativeFeedback>\r\n\r\n          {/* reset */}\r\n          <View className=\"flex-row items-center justify-between p-4 border-b border-[#262626]\">\r\n            <Text className=\"text-white text-base\">Reset to Default</Text>\r\n            <TouchableOpacity\r\n              onPress={() => {\r\n                settingsStorage.setSubtitleFontSize(16);\r\n                settingsStorage.setSubtitleOpacity(1);\r\n                settingsStorage.setSubtitleBottomPadding(10);\r\n                setFontSize(16);\r\n                setOpacity(1);\r\n                setBottomElevation(10);\r\n              }}>\r\n              <View className=\"w-32 flex-row items-center justify-center\">\r\n                <Text className=\"text-white text-base bg-[#262626] px-3 py-1 rounded-md text-center\">\r\n                  Reset\r\n                </Text>\r\n              </View>\r\n            </TouchableOpacity>\r\n          </View>\r\n        </View>\r\n        <View className=\"h-16\" />\r\n      </View>\r\n    </ScrollView>\r\n  );\r\n};\r\n\r\nexport default SubtitlePreference;\r\n","size_bytes":6959},"android/app/src/main/java/com/vega/MainActivity.kt":{"content":"package com.vega\nimport com.zoontek.rnbootsplash.RNBootSplash\n\nimport android.os.Build\nimport android.os.Bundle\n\nimport com.facebook.react.ReactActivity\nimport com.facebook.react.ReactActivityDelegate\nimport com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled\nimport com.facebook.react.defaults.DefaultReactActivityDelegate\n\nimport expo.modules.ReactActivityDelegateWrapper\n\nclass MainActivity : ReactActivity() {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    // Set the theme to AppTheme BEFORE onCreate to support\n    // coloring the background, status bar, and navigation bar.\n    // This is required for expo-splash-screen.\n    // setTheme(R.style.AppTheme);\n    // @generated begin bootsplash-init - expo prebuild (DO NOT MODIFY) sync-f0f7dbc46f1d82498f47676b4197e1949dc7790f\n    RNBootSplash.init(this, R.style.BootTheme)\n    // @generated end bootsplash-init\n    super.onCreate(null)\n  }\n\n  /**\n   * Returns the name of the main component registered from JavaScript. This is used to schedule\n   * rendering of the component.\n   */\n  override fun getMainComponentName(): String = \"main\"\n\n  /**\n   * Returns the instance of the [ReactActivityDelegate]. We use [DefaultReactActivityDelegate]\n   * which allows you to enable New Architecture with a single boolean flags [fabricEnabled]\n   */\n  override fun createReactActivityDelegate(): ReactActivityDelegate {\n    return ReactActivityDelegateWrapper(\n          this,\n          BuildConfig.IS_NEW_ARCHITECTURE_ENABLED,\n          object : DefaultReactActivityDelegate(\n              this,\n              mainComponentName,\n              fabricEnabled\n          ){})\n  }\n\n  /**\n    * Align the back button behavior with Android S\n    * where moving root activities to background instead of finishing activities.\n    * @see <a href=\"https://developer.android.com/reference/android/app/Activity#onBackPressed()\">onBackPressed</a>\n    */\n  override fun invokeDefaultOnBackPressed() {\n      if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.R) {\n          if (!moveTaskToBack(false)) {\n              // For non-root activities, use the default implementation to finish them.\n              super.invokeDefaultOnBackPressed()\n          }\n          return\n      }\n\n      // Use the default back button implementation on Android S\n      // because it's doing more than [Activity.moveTaskToBack] in fact.\n      super.invokeDefaultOnBackPressed()\n  }\n}\n","size_bytes":2429},"android/app/src/main/java/com/vega/MainApplication.kt":{"content":"package com.vega\n\nimport android.app.Application\nimport android.content.res.Configuration\n\nimport com.facebook.react.PackageList\nimport com.facebook.react.ReactApplication\nimport com.facebook.react.ReactNativeHost\nimport com.facebook.react.ReactPackage\nimport com.facebook.react.ReactHost\nimport com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load\nimport com.facebook.react.defaults.DefaultReactNativeHost\nimport com.facebook.react.soloader.OpenSourceMergedSoMapping\nimport com.facebook.soloader.SoLoader\n\nimport expo.modules.ApplicationLifecycleDispatcher\nimport expo.modules.ReactNativeHostWrapper\n\nclass MainApplication : Application(), ReactApplication {\n\n  override val reactNativeHost: ReactNativeHost = ReactNativeHostWrapper(\n        this,\n        object : DefaultReactNativeHost(this) {\n          override fun getPackages(): List<ReactPackage> {\n            val packages = PackageList(this).packages\n            // Packages that cannot be autolinked yet can be added manually here, for example:\n            // packages.add(new MyReactNativePackage());\n            return packages\n          }\n\n          override fun getJSMainModuleName(): String = \".expo/.virtual-metro-entry\"\n\n          override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG\n\n          override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED\n          override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED\n      }\n  )\n\n  override val reactHost: ReactHost\n    get() = ReactNativeHostWrapper.createReactHost(applicationContext, reactNativeHost)\n\n  override fun onCreate() {\n    super.onCreate()\n    SoLoader.init(this, OpenSourceMergedSoMapping)\n    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {\n      // If you opted-in for the New Architecture, we load the native entry point for this app.\n      load()\n    }\n    ApplicationLifecycleDispatcher.onApplicationCreate(this)\n  }\n\n  override fun onConfigurationChanged(newConfig: Configuration) {\n    super.onConfigurationChanged(newConfig)\n    ApplicationLifecycleDispatcher.onConfigurationChanged(this, newConfig)\n  }\n}\n","size_bytes":2111}},"version":1}